// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: rental.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { DecimalString, FeeRate, Network } from "./models";

export const protobufPackage = "hydra_app";

export enum PaymentMethod {
  ONCHAIN = 0,
  OFFCHAIN = 1,
  UNRECOGNIZED = -1,
}

export function paymentMethodFromJSON(object: any): PaymentMethod {
  switch (object) {
    case 0:
    case "ONCHAIN":
      return PaymentMethod.ONCHAIN;
    case 1:
    case "OFFCHAIN":
      return PaymentMethod.OFFCHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentMethod.UNRECOGNIZED;
  }
}

export function paymentMethodToJSON(object: PaymentMethod): string {
  switch (object) {
    case PaymentMethod.ONCHAIN:
      return "ONCHAIN";
    case PaymentMethod.OFFCHAIN:
      return "OFFCHAIN";
    case PaymentMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetRentalNodeInfoRequest {
}

export interface RentalAssetConfig {
  network?: Network | undefined;
  assetId: string;
  rentalFeeRatio?: DecimalString | undefined;
  pricingTicker?: string | undefined;
}

export interface GetRentalNodeInfoResponse {
  minDurationSeconds: string;
  maxDurationSeconds: string;
  minCapacityUsd?: DecimalString | undefined;
  maxCapacityUsd?: DecimalString | undefined;
  rentalAssets: RentalAssetConfig[];
}

export interface GetRentableAssetInfoRequest {
  network?: Network | undefined;
  assetId: string;
}

export interface GetRentableAssetInfoResponse {
  availableLiquidity?: DecimalString | undefined;
  minCapacity?: DecimalString | undefined;
  maxCapacity?: DecimalString | undefined;
  minDurationSeconds: string;
  maxDurationSeconds: string;
  rentalFeeRatio?: DecimalString | undefined;
}

export interface RentalOption {
  payment?: RentalOption_Payment | undefined;
  dualFund?: RentalOption_DualFund | undefined;
}

export interface RentalOption_Payment {
  rentalTxFeeRate?: FeeRate | undefined;
  paymentNetwork?: Network | undefined;
  paymentAssetId: string;
  paymentMethod: PaymentMethod;
}

export interface RentalOption_DualFund {
  selfAmount?: DecimalString | undefined;
}

export interface RentChannelRequest {
  network?: Network | undefined;
  assetId: string;
  lifetimeSeconds: string;
  amount?: DecimalString | undefined;
  rentalOption?: RentalOption | undefined;
}

export interface RentalPayment {
  onchain?: RentalPayment_Onchain | undefined;
  offchain?: RentalPayment_Offchain | undefined;
}

export interface RentalPayment_Onchain {
  paymentTxid: string;
  depositAddress: string;
  feeAmount?: DecimalString | undefined;
  metadata: Uint8Array;
}

export interface RentalPayment_Offchain {
  paymentId: string;
  paymentRequest: string;
}

export interface RentChannelResponse {
  rentalTxid: string;
  rentedChannelId: string;
  rentalPayment?: RentalPayment | undefined;
}

export interface EstimateRentChannelFeeRequest {
  network?: Network | undefined;
  assetId: string;
  lifetimeSeconds: string;
  amount?: DecimalString | undefined;
  rentalOption?: RentalOption | undefined;
}

export interface EstimateRentChannelFeeResponse {
  fee?: DecimalString | undefined;
}

function createBaseGetRentalNodeInfoRequest(): GetRentalNodeInfoRequest {
  return {};
}

export const GetRentalNodeInfoRequest: MessageFns<GetRentalNodeInfoRequest> = {
  encode(_: GetRentalNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRentalNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRentalNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetRentalNodeInfoRequest {
    return {};
  },

  toJSON(_: GetRentalNodeInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRentalNodeInfoRequest>, I>>(base?: I): GetRentalNodeInfoRequest {
    return GetRentalNodeInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRentalNodeInfoRequest>, I>>(_: I): GetRentalNodeInfoRequest {
    const message = createBaseGetRentalNodeInfoRequest();
    return message;
  },
};

function createBaseRentalAssetConfig(): RentalAssetConfig {
  return { network: undefined, assetId: "", rentalFeeRatio: undefined, pricingTicker: undefined };
}

export const RentalAssetConfig: MessageFns<RentalAssetConfig> = {
  encode(message: RentalAssetConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.rentalFeeRatio !== undefined) {
      DecimalString.encode(message.rentalFeeRatio, writer.uint32(26).fork()).join();
    }
    if (message.pricingTicker !== undefined) {
      writer.uint32(34).string(message.pricingTicker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalAssetConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalAssetConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rentalFeeRatio = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pricingTicker = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalAssetConfig {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      rentalFeeRatio: isSet(object.rentalFeeRatio) ? DecimalString.fromJSON(object.rentalFeeRatio) : undefined,
      pricingTicker: isSet(object.pricingTicker) ? globalThis.String(object.pricingTicker) : undefined,
    };
  },

  toJSON(message: RentalAssetConfig): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.rentalFeeRatio !== undefined) {
      obj.rentalFeeRatio = DecimalString.toJSON(message.rentalFeeRatio);
    }
    if (message.pricingTicker !== undefined) {
      obj.pricingTicker = message.pricingTicker;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalAssetConfig>, I>>(base?: I): RentalAssetConfig {
    return RentalAssetConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalAssetConfig>, I>>(object: I): RentalAssetConfig {
    const message = createBaseRentalAssetConfig();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.rentalFeeRatio = (object.rentalFeeRatio !== undefined && object.rentalFeeRatio !== null)
      ? DecimalString.fromPartial(object.rentalFeeRatio)
      : undefined;
    message.pricingTicker = object.pricingTicker ?? undefined;
    return message;
  },
};

function createBaseGetRentalNodeInfoResponse(): GetRentalNodeInfoResponse {
  return {
    minDurationSeconds: "0",
    maxDurationSeconds: "0",
    minCapacityUsd: undefined,
    maxCapacityUsd: undefined,
    rentalAssets: [],
  };
}

export const GetRentalNodeInfoResponse: MessageFns<GetRentalNodeInfoResponse> = {
  encode(message: GetRentalNodeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minDurationSeconds !== "0") {
      writer.uint32(8).uint64(message.minDurationSeconds);
    }
    if (message.maxDurationSeconds !== "0") {
      writer.uint32(16).uint64(message.maxDurationSeconds);
    }
    if (message.minCapacityUsd !== undefined) {
      DecimalString.encode(message.minCapacityUsd, writer.uint32(26).fork()).join();
    }
    if (message.maxCapacityUsd !== undefined) {
      DecimalString.encode(message.maxCapacityUsd, writer.uint32(34).fork()).join();
    }
    for (const v of message.rentalAssets) {
      RentalAssetConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRentalNodeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRentalNodeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minDurationSeconds = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxDurationSeconds = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minCapacityUsd = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxCapacityUsd = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rentalAssets.push(RentalAssetConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRentalNodeInfoResponse {
    return {
      minDurationSeconds: isSet(object.minDurationSeconds) ? globalThis.String(object.minDurationSeconds) : "0",
      maxDurationSeconds: isSet(object.maxDurationSeconds) ? globalThis.String(object.maxDurationSeconds) : "0",
      minCapacityUsd: isSet(object.minCapacityUsd) ? DecimalString.fromJSON(object.minCapacityUsd) : undefined,
      maxCapacityUsd: isSet(object.maxCapacityUsd) ? DecimalString.fromJSON(object.maxCapacityUsd) : undefined,
      rentalAssets: globalThis.Array.isArray(object?.rentalAssets)
        ? object.rentalAssets.map((e: any) => RentalAssetConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetRentalNodeInfoResponse): unknown {
    const obj: any = {};
    if (message.minDurationSeconds !== "0") {
      obj.minDurationSeconds = message.minDurationSeconds;
    }
    if (message.maxDurationSeconds !== "0") {
      obj.maxDurationSeconds = message.maxDurationSeconds;
    }
    if (message.minCapacityUsd !== undefined) {
      obj.minCapacityUsd = DecimalString.toJSON(message.minCapacityUsd);
    }
    if (message.maxCapacityUsd !== undefined) {
      obj.maxCapacityUsd = DecimalString.toJSON(message.maxCapacityUsd);
    }
    if (message.rentalAssets?.length) {
      obj.rentalAssets = message.rentalAssets.map((e) => RentalAssetConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRentalNodeInfoResponse>, I>>(base?: I): GetRentalNodeInfoResponse {
    return GetRentalNodeInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRentalNodeInfoResponse>, I>>(object: I): GetRentalNodeInfoResponse {
    const message = createBaseGetRentalNodeInfoResponse();
    message.minDurationSeconds = object.minDurationSeconds ?? "0";
    message.maxDurationSeconds = object.maxDurationSeconds ?? "0";
    message.minCapacityUsd = (object.minCapacityUsd !== undefined && object.minCapacityUsd !== null)
      ? DecimalString.fromPartial(object.minCapacityUsd)
      : undefined;
    message.maxCapacityUsd = (object.maxCapacityUsd !== undefined && object.maxCapacityUsd !== null)
      ? DecimalString.fromPartial(object.maxCapacityUsd)
      : undefined;
    message.rentalAssets = object.rentalAssets?.map((e) => RentalAssetConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRentableAssetInfoRequest(): GetRentableAssetInfoRequest {
  return { network: undefined, assetId: "" };
}

export const GetRentableAssetInfoRequest: MessageFns<GetRentableAssetInfoRequest> = {
  encode(message: GetRentableAssetInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRentableAssetInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRentableAssetInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRentableAssetInfoRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
    };
  },

  toJSON(message: GetRentableAssetInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRentableAssetInfoRequest>, I>>(base?: I): GetRentableAssetInfoRequest {
    return GetRentableAssetInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRentableAssetInfoRequest>, I>>(object: I): GetRentableAssetInfoRequest {
    const message = createBaseGetRentableAssetInfoRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.assetId = object.assetId ?? "";
    return message;
  },
};

function createBaseGetRentableAssetInfoResponse(): GetRentableAssetInfoResponse {
  return {
    availableLiquidity: undefined,
    minCapacity: undefined,
    maxCapacity: undefined,
    minDurationSeconds: "0",
    maxDurationSeconds: "0",
    rentalFeeRatio: undefined,
  };
}

export const GetRentableAssetInfoResponse: MessageFns<GetRentableAssetInfoResponse> = {
  encode(message: GetRentableAssetInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.availableLiquidity !== undefined) {
      DecimalString.encode(message.availableLiquidity, writer.uint32(10).fork()).join();
    }
    if (message.minCapacity !== undefined) {
      DecimalString.encode(message.minCapacity, writer.uint32(18).fork()).join();
    }
    if (message.maxCapacity !== undefined) {
      DecimalString.encode(message.maxCapacity, writer.uint32(26).fork()).join();
    }
    if (message.minDurationSeconds !== "0") {
      writer.uint32(32).uint64(message.minDurationSeconds);
    }
    if (message.maxDurationSeconds !== "0") {
      writer.uint32(40).uint64(message.maxDurationSeconds);
    }
    if (message.rentalFeeRatio !== undefined) {
      DecimalString.encode(message.rentalFeeRatio, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRentableAssetInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRentableAssetInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.availableLiquidity = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.minCapacity = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxCapacity = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minDurationSeconds = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxDurationSeconds = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rentalFeeRatio = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRentableAssetInfoResponse {
    return {
      availableLiquidity: isSet(object.availableLiquidity)
        ? DecimalString.fromJSON(object.availableLiquidity)
        : undefined,
      minCapacity: isSet(object.minCapacity) ? DecimalString.fromJSON(object.minCapacity) : undefined,
      maxCapacity: isSet(object.maxCapacity) ? DecimalString.fromJSON(object.maxCapacity) : undefined,
      minDurationSeconds: isSet(object.minDurationSeconds) ? globalThis.String(object.minDurationSeconds) : "0",
      maxDurationSeconds: isSet(object.maxDurationSeconds) ? globalThis.String(object.maxDurationSeconds) : "0",
      rentalFeeRatio: isSet(object.rentalFeeRatio) ? DecimalString.fromJSON(object.rentalFeeRatio) : undefined,
    };
  },

  toJSON(message: GetRentableAssetInfoResponse): unknown {
    const obj: any = {};
    if (message.availableLiquidity !== undefined) {
      obj.availableLiquidity = DecimalString.toJSON(message.availableLiquidity);
    }
    if (message.minCapacity !== undefined) {
      obj.minCapacity = DecimalString.toJSON(message.minCapacity);
    }
    if (message.maxCapacity !== undefined) {
      obj.maxCapacity = DecimalString.toJSON(message.maxCapacity);
    }
    if (message.minDurationSeconds !== "0") {
      obj.minDurationSeconds = message.minDurationSeconds;
    }
    if (message.maxDurationSeconds !== "0") {
      obj.maxDurationSeconds = message.maxDurationSeconds;
    }
    if (message.rentalFeeRatio !== undefined) {
      obj.rentalFeeRatio = DecimalString.toJSON(message.rentalFeeRatio);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRentableAssetInfoResponse>, I>>(base?: I): GetRentableAssetInfoResponse {
    return GetRentableAssetInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRentableAssetInfoResponse>, I>>(object: I): GetRentableAssetInfoResponse {
    const message = createBaseGetRentableAssetInfoResponse();
    message.availableLiquidity = (object.availableLiquidity !== undefined && object.availableLiquidity !== null)
      ? DecimalString.fromPartial(object.availableLiquidity)
      : undefined;
    message.minCapacity = (object.minCapacity !== undefined && object.minCapacity !== null)
      ? DecimalString.fromPartial(object.minCapacity)
      : undefined;
    message.maxCapacity = (object.maxCapacity !== undefined && object.maxCapacity !== null)
      ? DecimalString.fromPartial(object.maxCapacity)
      : undefined;
    message.minDurationSeconds = object.minDurationSeconds ?? "0";
    message.maxDurationSeconds = object.maxDurationSeconds ?? "0";
    message.rentalFeeRatio = (object.rentalFeeRatio !== undefined && object.rentalFeeRatio !== null)
      ? DecimalString.fromPartial(object.rentalFeeRatio)
      : undefined;
    return message;
  },
};

function createBaseRentalOption(): RentalOption {
  return { payment: undefined, dualFund: undefined };
}

export const RentalOption: MessageFns<RentalOption> = {
  encode(message: RentalOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      RentalOption_Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    if (message.dualFund !== undefined) {
      RentalOption_DualFund.encode(message.dualFund, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = RentalOption_Payment.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dualFund = RentalOption_DualFund.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalOption {
    return {
      payment: isSet(object.payment) ? RentalOption_Payment.fromJSON(object.payment) : undefined,
      dualFund: isSet(object.dualFund) ? RentalOption_DualFund.fromJSON(object.dualFund) : undefined,
    };
  },

  toJSON(message: RentalOption): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = RentalOption_Payment.toJSON(message.payment);
    }
    if (message.dualFund !== undefined) {
      obj.dualFund = RentalOption_DualFund.toJSON(message.dualFund);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalOption>, I>>(base?: I): RentalOption {
    return RentalOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalOption>, I>>(object: I): RentalOption {
    const message = createBaseRentalOption();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? RentalOption_Payment.fromPartial(object.payment)
      : undefined;
    message.dualFund = (object.dualFund !== undefined && object.dualFund !== null)
      ? RentalOption_DualFund.fromPartial(object.dualFund)
      : undefined;
    return message;
  },
};

function createBaseRentalOption_Payment(): RentalOption_Payment {
  return { rentalTxFeeRate: undefined, paymentNetwork: undefined, paymentAssetId: "", paymentMethod: 0 };
}

export const RentalOption_Payment: MessageFns<RentalOption_Payment> = {
  encode(message: RentalOption_Payment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rentalTxFeeRate !== undefined) {
      FeeRate.encode(message.rentalTxFeeRate, writer.uint32(10).fork()).join();
    }
    if (message.paymentNetwork !== undefined) {
      Network.encode(message.paymentNetwork, writer.uint32(18).fork()).join();
    }
    if (message.paymentAssetId !== "") {
      writer.uint32(26).string(message.paymentAssetId);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(32).int32(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalOption_Payment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalOption_Payment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rentalTxFeeRate = FeeRate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentNetwork = Network.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentAssetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalOption_Payment {
    return {
      rentalTxFeeRate: isSet(object.rentalTxFeeRate) ? FeeRate.fromJSON(object.rentalTxFeeRate) : undefined,
      paymentNetwork: isSet(object.paymentNetwork) ? Network.fromJSON(object.paymentNetwork) : undefined,
      paymentAssetId: isSet(object.paymentAssetId) ? globalThis.String(object.paymentAssetId) : "",
      paymentMethod: isSet(object.paymentMethod) ? paymentMethodFromJSON(object.paymentMethod) : 0,
    };
  },

  toJSON(message: RentalOption_Payment): unknown {
    const obj: any = {};
    if (message.rentalTxFeeRate !== undefined) {
      obj.rentalTxFeeRate = FeeRate.toJSON(message.rentalTxFeeRate);
    }
    if (message.paymentNetwork !== undefined) {
      obj.paymentNetwork = Network.toJSON(message.paymentNetwork);
    }
    if (message.paymentAssetId !== "") {
      obj.paymentAssetId = message.paymentAssetId;
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = paymentMethodToJSON(message.paymentMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalOption_Payment>, I>>(base?: I): RentalOption_Payment {
    return RentalOption_Payment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalOption_Payment>, I>>(object: I): RentalOption_Payment {
    const message = createBaseRentalOption_Payment();
    message.rentalTxFeeRate = (object.rentalTxFeeRate !== undefined && object.rentalTxFeeRate !== null)
      ? FeeRate.fromPartial(object.rentalTxFeeRate)
      : undefined;
    message.paymentNetwork = (object.paymentNetwork !== undefined && object.paymentNetwork !== null)
      ? Network.fromPartial(object.paymentNetwork)
      : undefined;
    message.paymentAssetId = object.paymentAssetId ?? "";
    message.paymentMethod = object.paymentMethod ?? 0;
    return message;
  },
};

function createBaseRentalOption_DualFund(): RentalOption_DualFund {
  return { selfAmount: undefined };
}

export const RentalOption_DualFund: MessageFns<RentalOption_DualFund> = {
  encode(message: RentalOption_DualFund, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.selfAmount !== undefined) {
      DecimalString.encode(message.selfAmount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalOption_DualFund {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalOption_DualFund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.selfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalOption_DualFund {
    return { selfAmount: isSet(object.selfAmount) ? DecimalString.fromJSON(object.selfAmount) : undefined };
  },

  toJSON(message: RentalOption_DualFund): unknown {
    const obj: any = {};
    if (message.selfAmount !== undefined) {
      obj.selfAmount = DecimalString.toJSON(message.selfAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalOption_DualFund>, I>>(base?: I): RentalOption_DualFund {
    return RentalOption_DualFund.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalOption_DualFund>, I>>(object: I): RentalOption_DualFund {
    const message = createBaseRentalOption_DualFund();
    message.selfAmount = (object.selfAmount !== undefined && object.selfAmount !== null)
      ? DecimalString.fromPartial(object.selfAmount)
      : undefined;
    return message;
  },
};

function createBaseRentChannelRequest(): RentChannelRequest {
  return { network: undefined, assetId: "", lifetimeSeconds: "0", amount: undefined, rentalOption: undefined };
}

export const RentChannelRequest: MessageFns<RentChannelRequest> = {
  encode(message: RentChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.lifetimeSeconds !== "0") {
      writer.uint32(24).uint64(message.lifetimeSeconds);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.rentalOption !== undefined) {
      RentalOption.encode(message.rentalOption, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lifetimeSeconds = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rentalOption = RentalOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      lifetimeSeconds: isSet(object.lifetimeSeconds) ? globalThis.String(object.lifetimeSeconds) : "0",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      rentalOption: isSet(object.rentalOption) ? RentalOption.fromJSON(object.rentalOption) : undefined,
    };
  },

  toJSON(message: RentChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.lifetimeSeconds !== "0") {
      obj.lifetimeSeconds = message.lifetimeSeconds;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.rentalOption !== undefined) {
      obj.rentalOption = RentalOption.toJSON(message.rentalOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentChannelRequest>, I>>(base?: I): RentChannelRequest {
    return RentChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentChannelRequest>, I>>(object: I): RentChannelRequest {
    const message = createBaseRentChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.lifetimeSeconds = object.lifetimeSeconds ?? "0";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.rentalOption = (object.rentalOption !== undefined && object.rentalOption !== null)
      ? RentalOption.fromPartial(object.rentalOption)
      : undefined;
    return message;
  },
};

function createBaseRentalPayment(): RentalPayment {
  return { onchain: undefined, offchain: undefined };
}

export const RentalPayment: MessageFns<RentalPayment> = {
  encode(message: RentalPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onchain !== undefined) {
      RentalPayment_Onchain.encode(message.onchain, writer.uint32(10).fork()).join();
    }
    if (message.offchain !== undefined) {
      RentalPayment_Offchain.encode(message.offchain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onchain = RentalPayment_Onchain.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.offchain = RentalPayment_Offchain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalPayment {
    return {
      onchain: isSet(object.onchain) ? RentalPayment_Onchain.fromJSON(object.onchain) : undefined,
      offchain: isSet(object.offchain) ? RentalPayment_Offchain.fromJSON(object.offchain) : undefined,
    };
  },

  toJSON(message: RentalPayment): unknown {
    const obj: any = {};
    if (message.onchain !== undefined) {
      obj.onchain = RentalPayment_Onchain.toJSON(message.onchain);
    }
    if (message.offchain !== undefined) {
      obj.offchain = RentalPayment_Offchain.toJSON(message.offchain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalPayment>, I>>(base?: I): RentalPayment {
    return RentalPayment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalPayment>, I>>(object: I): RentalPayment {
    const message = createBaseRentalPayment();
    message.onchain = (object.onchain !== undefined && object.onchain !== null)
      ? RentalPayment_Onchain.fromPartial(object.onchain)
      : undefined;
    message.offchain = (object.offchain !== undefined && object.offchain !== null)
      ? RentalPayment_Offchain.fromPartial(object.offchain)
      : undefined;
    return message;
  },
};

function createBaseRentalPayment_Onchain(): RentalPayment_Onchain {
  return { paymentTxid: "", depositAddress: "", feeAmount: undefined, metadata: new Uint8Array(0) };
}

export const RentalPayment_Onchain: MessageFns<RentalPayment_Onchain> = {
  encode(message: RentalPayment_Onchain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentTxid !== "") {
      writer.uint32(10).string(message.paymentTxid);
    }
    if (message.depositAddress !== "") {
      writer.uint32(18).string(message.depositAddress);
    }
    if (message.feeAmount !== undefined) {
      DecimalString.encode(message.feeAmount, writer.uint32(26).fork()).join();
    }
    if (message.metadata.length !== 0) {
      writer.uint32(34).bytes(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalPayment_Onchain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalPayment_Onchain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentTxid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.feeAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalPayment_Onchain {
    return {
      paymentTxid: isSet(object.paymentTxid) ? globalThis.String(object.paymentTxid) : "",
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      feeAmount: isSet(object.feeAmount) ? DecimalString.fromJSON(object.feeAmount) : undefined,
      metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array(0),
    };
  },

  toJSON(message: RentalPayment_Onchain): unknown {
    const obj: any = {};
    if (message.paymentTxid !== "") {
      obj.paymentTxid = message.paymentTxid;
    }
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.feeAmount !== undefined) {
      obj.feeAmount = DecimalString.toJSON(message.feeAmount);
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalPayment_Onchain>, I>>(base?: I): RentalPayment_Onchain {
    return RentalPayment_Onchain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalPayment_Onchain>, I>>(object: I): RentalPayment_Onchain {
    const message = createBaseRentalPayment_Onchain();
    message.paymentTxid = object.paymentTxid ?? "";
    message.depositAddress = object.depositAddress ?? "";
    message.feeAmount = (object.feeAmount !== undefined && object.feeAmount !== null)
      ? DecimalString.fromPartial(object.feeAmount)
      : undefined;
    message.metadata = object.metadata ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRentalPayment_Offchain(): RentalPayment_Offchain {
  return { paymentId: "", paymentRequest: "" };
}

export const RentalPayment_Offchain: MessageFns<RentalPayment_Offchain> = {
  encode(message: RentalPayment_Offchain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentalPayment_Offchain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentalPayment_Offchain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentalPayment_Offchain {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
    };
  },

  toJSON(message: RentalPayment_Offchain): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentalPayment_Offchain>, I>>(base?: I): RentalPayment_Offchain {
    return RentalPayment_Offchain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentalPayment_Offchain>, I>>(object: I): RentalPayment_Offchain {
    const message = createBaseRentalPayment_Offchain();
    message.paymentId = object.paymentId ?? "";
    message.paymentRequest = object.paymentRequest ?? "";
    return message;
  },
};

function createBaseRentChannelResponse(): RentChannelResponse {
  return { rentalTxid: "", rentedChannelId: "", rentalPayment: undefined };
}

export const RentChannelResponse: MessageFns<RentChannelResponse> = {
  encode(message: RentChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rentalTxid !== "") {
      writer.uint32(10).string(message.rentalTxid);
    }
    if (message.rentedChannelId !== "") {
      writer.uint32(18).string(message.rentedChannelId);
    }
    if (message.rentalPayment !== undefined) {
      RentalPayment.encode(message.rentalPayment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RentChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRentChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rentalTxid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rentedChannelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rentalPayment = RentalPayment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RentChannelResponse {
    return {
      rentalTxid: isSet(object.rentalTxid) ? globalThis.String(object.rentalTxid) : "",
      rentedChannelId: isSet(object.rentedChannelId) ? globalThis.String(object.rentedChannelId) : "",
      rentalPayment: isSet(object.rentalPayment) ? RentalPayment.fromJSON(object.rentalPayment) : undefined,
    };
  },

  toJSON(message: RentChannelResponse): unknown {
    const obj: any = {};
    if (message.rentalTxid !== "") {
      obj.rentalTxid = message.rentalTxid;
    }
    if (message.rentedChannelId !== "") {
      obj.rentedChannelId = message.rentedChannelId;
    }
    if (message.rentalPayment !== undefined) {
      obj.rentalPayment = RentalPayment.toJSON(message.rentalPayment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RentChannelResponse>, I>>(base?: I): RentChannelResponse {
    return RentChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RentChannelResponse>, I>>(object: I): RentChannelResponse {
    const message = createBaseRentChannelResponse();
    message.rentalTxid = object.rentalTxid ?? "";
    message.rentedChannelId = object.rentedChannelId ?? "";
    message.rentalPayment = (object.rentalPayment !== undefined && object.rentalPayment !== null)
      ? RentalPayment.fromPartial(object.rentalPayment)
      : undefined;
    return message;
  },
};

function createBaseEstimateRentChannelFeeRequest(): EstimateRentChannelFeeRequest {
  return { network: undefined, assetId: "", lifetimeSeconds: "0", amount: undefined, rentalOption: undefined };
}

export const EstimateRentChannelFeeRequest: MessageFns<EstimateRentChannelFeeRequest> = {
  encode(message: EstimateRentChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.lifetimeSeconds !== "0") {
      writer.uint32(24).uint64(message.lifetimeSeconds);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.rentalOption !== undefined) {
      RentalOption.encode(message.rentalOption, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateRentChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateRentChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lifetimeSeconds = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rentalOption = RentalOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateRentChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      lifetimeSeconds: isSet(object.lifetimeSeconds) ? globalThis.String(object.lifetimeSeconds) : "0",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      rentalOption: isSet(object.rentalOption) ? RentalOption.fromJSON(object.rentalOption) : undefined,
    };
  },

  toJSON(message: EstimateRentChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.lifetimeSeconds !== "0") {
      obj.lifetimeSeconds = message.lifetimeSeconds;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.rentalOption !== undefined) {
      obj.rentalOption = RentalOption.toJSON(message.rentalOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateRentChannelFeeRequest>, I>>(base?: I): EstimateRentChannelFeeRequest {
    return EstimateRentChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateRentChannelFeeRequest>, I>>(
    object: I,
  ): EstimateRentChannelFeeRequest {
    const message = createBaseEstimateRentChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.lifetimeSeconds = object.lifetimeSeconds ?? "0";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.rentalOption = (object.rentalOption !== undefined && object.rentalOption !== null)
      ? RentalOption.fromPartial(object.rentalOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateRentChannelFeeResponse(): EstimateRentChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateRentChannelFeeResponse: MessageFns<EstimateRentChannelFeeResponse> = {
  encode(message: EstimateRentChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateRentChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateRentChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateRentChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateRentChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateRentChannelFeeResponse>, I>>(base?: I): EstimateRentChannelFeeResponse {
    return EstimateRentChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateRentChannelFeeResponse>, I>>(
    object: I,
  ): EstimateRentChannelFeeResponse {
    const message = createBaseEstimateRentChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

/**
 * Rental service definition for renting channels and managing
 * rentals.
 */
export interface RentalService {
  /**
   * Get the rental info from the node. This includes the
   * min/max rental amounts, duration, and the rental fees for the different
   * assets.
   */
  GetRentalNodeInfo(request: GetRentalNodeInfoRequest): Promise<GetRentalNodeInfoResponse>;
  /**
   * Get the rental info for a specific asset. This includes the
   * available asset liquidity, the min/max rental amounts, duration, and the
   * rental fee for the asset.
   */
  GetRentableAssetInfo(request: GetRentableAssetInfoRequest): Promise<GetRentableAssetInfoResponse>;
  /**
   * Rent a channel for a specific asset specifiying the amount of inbound
   * liquidity, the rental lifetime, and the payment option to rent the channel.
   * This is useful when the user needs inbound liquidity for a specific asset
   * to be able to receive payments from other users, for example when receiving
   * the asset in a swap.
   */
  RentChannel(request: RentChannelRequest): Promise<RentChannelResponse>;
  /**
   * Estimate the rental fee for a specific asset, amount and duration.
   * This is useful to know the rental fee before renting the channel.
   */
  EstimateRentChannelFee(request: EstimateRentChannelFeeRequest): Promise<EstimateRentChannelFeeResponse>;
}

export const RentalServiceServiceName = "hydra_app.RentalService";
export class RentalServiceClientImpl implements RentalService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RentalServiceServiceName;
    this.rpc = rpc;
    this.GetRentalNodeInfo = this.GetRentalNodeInfo.bind(this);
    this.GetRentableAssetInfo = this.GetRentableAssetInfo.bind(this);
    this.RentChannel = this.RentChannel.bind(this);
    this.EstimateRentChannelFee = this.EstimateRentChannelFee.bind(this);
  }
  GetRentalNodeInfo(request: GetRentalNodeInfoRequest): Promise<GetRentalNodeInfoResponse> {
    const data = GetRentalNodeInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRentalNodeInfo", data);
    return promise.then((data) => GetRentalNodeInfoResponse.decode(new BinaryReader(data)));
  }

  GetRentableAssetInfo(request: GetRentableAssetInfoRequest): Promise<GetRentableAssetInfoResponse> {
    const data = GetRentableAssetInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRentableAssetInfo", data);
    return promise.then((data) => GetRentableAssetInfoResponse.decode(new BinaryReader(data)));
  }

  RentChannel(request: RentChannelRequest): Promise<RentChannelResponse> {
    const data = RentChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RentChannel", data);
    return promise.then((data) => RentChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateRentChannelFee(request: EstimateRentChannelFeeRequest): Promise<EstimateRentChannelFeeResponse> {
    const data = EstimateRentChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateRentChannelFee", data);
    return promise.then((data) => EstimateRentChannelFeeResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
