// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { DecimalString, DualFundAmount, FeeOption, Hashlock, Invoice, Network, SendAmount } from "./models";

export const protobufPackage = "hydra_app";

export interface ConnectToPeerRequest {
  network?: Network | undefined;
  peerUrl: string;
}

export interface ConnectToPeerResponse {
}

export interface GetConnectedPeersRequest {
  network?: Network | undefined;
}

export interface GetConnectedPeersResponse {
  nodeIds: string[];
}

export interface EstimateOpenChannelFeeRequest {
  network?: Network | undefined;
  nodeId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  feeOption?: FeeOption | undefined;
}

export interface EstimateOpenChannelFeeRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface EstimateOpenChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface OpenChannelRequest {
  network?: Network | undefined;
  nodeId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  feeOption?: FeeOption | undefined;
}

export interface OpenChannelRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface OpenChannelResponse {
  txid: string;
  channelId: string;
}

export interface EstimateDepositChannelFeeRequest {
  network?: Network | undefined;
  channelId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  feeOption?: FeeOption | undefined;
}

export interface EstimateDepositChannelFeeRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface EstimateDepositChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface DepositChannelRequest {
  network?: Network | undefined;
  channelId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  feeOption?: FeeOption | undefined;
}

export interface DepositChannelRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface DepositChannelResponse {
  txid: string;
}

export interface WithdrawAmount {
  selfWithdrawal?: SendAmount | undefined;
  counterpartyWithdrawal?: SendAmount | undefined;
}

export interface EstimateWithdrawChannelFeeRequest {
  network?: Network | undefined;
  channelId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: WithdrawAmount };
  feeOption?: FeeOption | undefined;
}

export interface EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
  key: string;
  value?: WithdrawAmount | undefined;
}

export interface EstimateWithdrawChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface WithdrawChannelRequest {
  network?: Network | undefined;
  channelId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: WithdrawAmount };
  feeOption?: FeeOption | undefined;
}

export interface WithdrawChannelRequest_AssetAmountsEntry {
  key: string;
  value?: WithdrawAmount | undefined;
}

export interface WithdrawChannelResponse {
  txid: string;
}

export interface EstimateCloseChannelFeeRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface EstimateCloseChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface CloseChannelRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface CloseChannelResponse {
  txid: string;
}

export interface EstimateForceCloseChannelFeeRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface EstimateForceCloseChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface ForceCloseChannelRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface ForceCloseChannelResponse {
  txid: string;
}

export interface EstimateRedeemClosedChannelFeeRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface EstimateRedeemClosedChannelFeeResponse {
  fee?: DecimalString | undefined;
}

export interface RedeemClosedChannelRequest {
  network?: Network | undefined;
  channelId: string;
  assetIds: string[];
  feeOption?: FeeOption | undefined;
}

export interface RedeemClosedChannelResponse {
  txid: string;
}

export interface WaitForActiveAssetChannelRequest {
  network?: Network | undefined;
  channelId: string;
  assetId: string;
  activeSending: boolean;
  activeReceiving: boolean;
  updatable: boolean;
}

export interface WaitForActiveAssetChannelResponse {
}

export interface SendChannelPaymentRequest {
  network?: Network | undefined;
  channelId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  hashlock?: Hashlock | undefined;
  expiryTimeoutSecs?: string | undefined;
}

export interface SendChannelPaymentRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface SendChannelPaymentResponse {
  paymentId: string;
}

export interface EstimateSendPaymentFeeRequest {
  network?: Network | undefined;
  recipientNodeId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  hashlock?: Hashlock | undefined;
  expiryTimeoutSecs?: string | undefined;
}

export interface EstimateSendPaymentFeeRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface EstimateSendPaymentFeeResponse {
  /** key: asset_id */
  fees: { [key: string]: DecimalString };
}

export interface EstimateSendPaymentFeeResponse_FeesEntry {
  key: string;
  value?: DecimalString | undefined;
}

export interface SendPaymentRequest {
  network?: Network | undefined;
  recipientNodeId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: SendAmount };
  hashlock?: Hashlock | undefined;
  expiryTimeoutSecs?: string | undefined;
}

export interface SendPaymentRequest_AssetAmountsEntry {
  key: string;
  value?: SendAmount | undefined;
}

export interface SendPaymentResponse {
  paymentId: string;
}

export interface CreateInvoiceRequest {
  network?: Network | undefined;
  assetId: string;
  amount?: DecimalString | undefined;
  hashlock?: Hashlock | undefined;
  expiryTimeoutSecs?: string | undefined;
}

export interface CreateInvoiceResponse {
  invoice?: Invoice | undefined;
}

export interface DecodeInvoiceRequest {
  network?: Network | undefined;
  paymentRequest: string;
}

export interface DecodeInvoiceResponse {
  invoice?: Invoice | undefined;
}

export interface EstimatePayInvoiceFeeRequest {
  network?: Network | undefined;
  paymentRequest: string;
}

export interface EstimatePayInvoiceFeeResponse {
  fee?: DecimalString | undefined;
}

export interface EstimatePayEmptyInvoiceFeeRequest {
  network?: Network | undefined;
  paymentRequest: string;
  amount?: SendAmount | undefined;
}

export interface EstimatePayEmptyInvoiceFeeResponse {
  fee?: DecimalString | undefined;
}

export interface PayEmptyInvoiceRequest {
  network?: Network | undefined;
  paymentRequest: string;
  amount?: SendAmount | undefined;
}

export interface PayEmptyInvoiceResponse {
  paymentId: string;
}

export interface PayInvoiceRequest {
  network?: Network | undefined;
  paymentRequest: string;
}

export interface PayInvoiceResponse {
  paymentId: string;
}

export interface ResolveHashlockPaymentRequest {
  network?: Network | undefined;
  paymentId: string;
  paymentPreimage: string;
}

export interface ResolveHashlockPaymentResponse {
}

export interface RejectPaymentRequest {
  network?: Network | undefined;
  paymentId: string;
}

export interface RejectPaymentResponse {
}

export interface AllowDualFundedChannelRequest {
  network?: Network | undefined;
  nodeId: string;
  /** key: asset_id */
  assetAmounts: { [key: string]: DualFundAmount };
}

export interface AllowDualFundedChannelRequest_AssetAmountsEntry {
  key: string;
  value?: DualFundAmount | undefined;
}

export interface AllowDualFundedChannelResponse {
}

function createBaseConnectToPeerRequest(): ConnectToPeerRequest {
  return { network: undefined, peerUrl: "" };
}

export const ConnectToPeerRequest: MessageFns<ConnectToPeerRequest> = {
  encode(message: ConnectToPeerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.peerUrl !== "") {
      writer.uint32(18).string(message.peerUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectToPeerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectToPeerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.peerUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectToPeerRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      peerUrl: isSet(object.peerUrl) ? globalThis.String(object.peerUrl) : "",
    };
  },

  toJSON(message: ConnectToPeerRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.peerUrl !== "") {
      obj.peerUrl = message.peerUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectToPeerRequest>, I>>(base?: I): ConnectToPeerRequest {
    return ConnectToPeerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectToPeerRequest>, I>>(object: I): ConnectToPeerRequest {
    const message = createBaseConnectToPeerRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.peerUrl = object.peerUrl ?? "";
    return message;
  },
};

function createBaseConnectToPeerResponse(): ConnectToPeerResponse {
  return {};
}

export const ConnectToPeerResponse: MessageFns<ConnectToPeerResponse> = {
  encode(_: ConnectToPeerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectToPeerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectToPeerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConnectToPeerResponse {
    return {};
  },

  toJSON(_: ConnectToPeerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectToPeerResponse>, I>>(base?: I): ConnectToPeerResponse {
    return ConnectToPeerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectToPeerResponse>, I>>(_: I): ConnectToPeerResponse {
    const message = createBaseConnectToPeerResponse();
    return message;
  },
};

function createBaseGetConnectedPeersRequest(): GetConnectedPeersRequest {
  return { network: undefined };
}

export const GetConnectedPeersRequest: MessageFns<GetConnectedPeersRequest> = {
  encode(message: GetConnectedPeersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedPeersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectedPeersRequest {
    return { network: isSet(object.network) ? Network.fromJSON(object.network) : undefined };
  },

  toJSON(message: GetConnectedPeersRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectedPeersRequest>, I>>(base?: I): GetConnectedPeersRequest {
    return GetConnectedPeersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectedPeersRequest>, I>>(object: I): GetConnectedPeersRequest {
    const message = createBaseGetConnectedPeersRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    return message;
  },
};

function createBaseGetConnectedPeersResponse(): GetConnectedPeersResponse {
  return { nodeIds: [] };
}

export const GetConnectedPeersResponse: MessageFns<GetConnectedPeersResponse> = {
  encode(message: GetConnectedPeersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedPeersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectedPeersResponse {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetConnectedPeersResponse): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectedPeersResponse>, I>>(base?: I): GetConnectedPeersResponse {
    return GetConnectedPeersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectedPeersResponse>, I>>(object: I): GetConnectedPeersResponse {
    const message = createBaseGetConnectedPeersResponse();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseEstimateOpenChannelFeeRequest(): EstimateOpenChannelFeeRequest {
  return { network: undefined, nodeId: "", assetAmounts: {}, feeOption: undefined };
}

export const EstimateOpenChannelFeeRequest: MessageFns<EstimateOpenChannelFeeRequest> = {
  encode(message: EstimateOpenChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      EstimateOpenChannelFeeRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateOpenChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateOpenChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = EstimateOpenChannelFeeRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateOpenChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateOpenChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateOpenChannelFeeRequest>, I>>(base?: I): EstimateOpenChannelFeeRequest {
    return EstimateOpenChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateOpenChannelFeeRequest>, I>>(
    object: I,
  ): EstimateOpenChannelFeeRequest {
    const message = createBaseEstimateOpenChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.nodeId = object.nodeId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateOpenChannelFeeRequest_AssetAmountsEntry(): EstimateOpenChannelFeeRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const EstimateOpenChannelFeeRequest_AssetAmountsEntry: MessageFns<
  EstimateOpenChannelFeeRequest_AssetAmountsEntry
> = {
  encode(
    message: EstimateOpenChannelFeeRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateOpenChannelFeeRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateOpenChannelFeeRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateOpenChannelFeeRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EstimateOpenChannelFeeRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateOpenChannelFeeRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): EstimateOpenChannelFeeRequest_AssetAmountsEntry {
    return EstimateOpenChannelFeeRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateOpenChannelFeeRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): EstimateOpenChannelFeeRequest_AssetAmountsEntry {
    const message = createBaseEstimateOpenChannelFeeRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEstimateOpenChannelFeeResponse(): EstimateOpenChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateOpenChannelFeeResponse: MessageFns<EstimateOpenChannelFeeResponse> = {
  encode(message: EstimateOpenChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateOpenChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateOpenChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateOpenChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateOpenChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateOpenChannelFeeResponse>, I>>(base?: I): EstimateOpenChannelFeeResponse {
    return EstimateOpenChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateOpenChannelFeeResponse>, I>>(
    object: I,
  ): EstimateOpenChannelFeeResponse {
    const message = createBaseEstimateOpenChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseOpenChannelRequest(): OpenChannelRequest {
  return { network: undefined, nodeId: "", assetAmounts: {}, feeOption: undefined };
}

export const OpenChannelRequest: MessageFns<OpenChannelRequest> = {
  encode(message: OpenChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      OpenChannelRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = OpenChannelRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: OpenChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenChannelRequest>, I>>(base?: I): OpenChannelRequest {
    return OpenChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenChannelRequest>, I>>(object: I): OpenChannelRequest {
    const message = createBaseOpenChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.nodeId = object.nodeId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseOpenChannelRequest_AssetAmountsEntry(): OpenChannelRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const OpenChannelRequest_AssetAmountsEntry: MessageFns<OpenChannelRequest_AssetAmountsEntry> = {
  encode(message: OpenChannelRequest_AssetAmountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenChannelRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenChannelRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenChannelRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OpenChannelRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenChannelRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): OpenChannelRequest_AssetAmountsEntry {
    return OpenChannelRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenChannelRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): OpenChannelRequest_AssetAmountsEntry {
    const message = createBaseOpenChannelRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOpenChannelResponse(): OpenChannelResponse {
  return { txid: "", channelId: "" };
}

export const OpenChannelResponse: MessageFns<OpenChannelResponse> = {
  encode(message: OpenChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenChannelResponse {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
    };
  },

  toJSON(message: OpenChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenChannelResponse>, I>>(base?: I): OpenChannelResponse {
    return OpenChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenChannelResponse>, I>>(object: I): OpenChannelResponse {
    const message = createBaseOpenChannelResponse();
    message.txid = object.txid ?? "";
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseEstimateDepositChannelFeeRequest(): EstimateDepositChannelFeeRequest {
  return { network: undefined, channelId: "", assetAmounts: {}, feeOption: undefined };
}

export const EstimateDepositChannelFeeRequest: MessageFns<EstimateDepositChannelFeeRequest> = {
  encode(message: EstimateDepositChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      EstimateDepositChannelFeeRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateDepositChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateDepositChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = EstimateDepositChannelFeeRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateDepositChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateDepositChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateDepositChannelFeeRequest>, I>>(
    base?: I,
  ): EstimateDepositChannelFeeRequest {
    return EstimateDepositChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateDepositChannelFeeRequest>, I>>(
    object: I,
  ): EstimateDepositChannelFeeRequest {
    const message = createBaseEstimateDepositChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateDepositChannelFeeRequest_AssetAmountsEntry(): EstimateDepositChannelFeeRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const EstimateDepositChannelFeeRequest_AssetAmountsEntry: MessageFns<
  EstimateDepositChannelFeeRequest_AssetAmountsEntry
> = {
  encode(
    message: EstimateDepositChannelFeeRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateDepositChannelFeeRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateDepositChannelFeeRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateDepositChannelFeeRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EstimateDepositChannelFeeRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateDepositChannelFeeRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): EstimateDepositChannelFeeRequest_AssetAmountsEntry {
    return EstimateDepositChannelFeeRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateDepositChannelFeeRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): EstimateDepositChannelFeeRequest_AssetAmountsEntry {
    const message = createBaseEstimateDepositChannelFeeRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEstimateDepositChannelFeeResponse(): EstimateDepositChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateDepositChannelFeeResponse: MessageFns<EstimateDepositChannelFeeResponse> = {
  encode(message: EstimateDepositChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateDepositChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateDepositChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateDepositChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateDepositChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateDepositChannelFeeResponse>, I>>(
    base?: I,
  ): EstimateDepositChannelFeeResponse {
    return EstimateDepositChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateDepositChannelFeeResponse>, I>>(
    object: I,
  ): EstimateDepositChannelFeeResponse {
    const message = createBaseEstimateDepositChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseDepositChannelRequest(): DepositChannelRequest {
  return { network: undefined, channelId: "", assetAmounts: {}, feeOption: undefined };
}

export const DepositChannelRequest: MessageFns<DepositChannelRequest> = {
  encode(message: DepositChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      DepositChannelRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = DepositChannelRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: DepositChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositChannelRequest>, I>>(base?: I): DepositChannelRequest {
    return DepositChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositChannelRequest>, I>>(object: I): DepositChannelRequest {
    const message = createBaseDepositChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseDepositChannelRequest_AssetAmountsEntry(): DepositChannelRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const DepositChannelRequest_AssetAmountsEntry: MessageFns<DepositChannelRequest_AssetAmountsEntry> = {
  encode(message: DepositChannelRequest_AssetAmountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositChannelRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositChannelRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositChannelRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DepositChannelRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositChannelRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): DepositChannelRequest_AssetAmountsEntry {
    return DepositChannelRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositChannelRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): DepositChannelRequest_AssetAmountsEntry {
    const message = createBaseDepositChannelRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDepositChannelResponse(): DepositChannelResponse {
  return { txid: "" };
}

export const DepositChannelResponse: MessageFns<DepositChannelResponse> = {
  encode(message: DepositChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositChannelResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: DepositChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositChannelResponse>, I>>(base?: I): DepositChannelResponse {
    return DepositChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositChannelResponse>, I>>(object: I): DepositChannelResponse {
    const message = createBaseDepositChannelResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseWithdrawAmount(): WithdrawAmount {
  return { selfWithdrawal: undefined, counterpartyWithdrawal: undefined };
}

export const WithdrawAmount: MessageFns<WithdrawAmount> = {
  encode(message: WithdrawAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.selfWithdrawal !== undefined) {
      SendAmount.encode(message.selfWithdrawal, writer.uint32(10).fork()).join();
    }
    if (message.counterpartyWithdrawal !== undefined) {
      SendAmount.encode(message.counterpartyWithdrawal, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.selfWithdrawal = SendAmount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterpartyWithdrawal = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawAmount {
    return {
      selfWithdrawal: isSet(object.selfWithdrawal) ? SendAmount.fromJSON(object.selfWithdrawal) : undefined,
      counterpartyWithdrawal: isSet(object.counterpartyWithdrawal)
        ? SendAmount.fromJSON(object.counterpartyWithdrawal)
        : undefined,
    };
  },

  toJSON(message: WithdrawAmount): unknown {
    const obj: any = {};
    if (message.selfWithdrawal !== undefined) {
      obj.selfWithdrawal = SendAmount.toJSON(message.selfWithdrawal);
    }
    if (message.counterpartyWithdrawal !== undefined) {
      obj.counterpartyWithdrawal = SendAmount.toJSON(message.counterpartyWithdrawal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawAmount>, I>>(base?: I): WithdrawAmount {
    return WithdrawAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawAmount>, I>>(object: I): WithdrawAmount {
    const message = createBaseWithdrawAmount();
    message.selfWithdrawal = (object.selfWithdrawal !== undefined && object.selfWithdrawal !== null)
      ? SendAmount.fromPartial(object.selfWithdrawal)
      : undefined;
    message.counterpartyWithdrawal =
      (object.counterpartyWithdrawal !== undefined && object.counterpartyWithdrawal !== null)
        ? SendAmount.fromPartial(object.counterpartyWithdrawal)
        : undefined;
    return message;
  },
};

function createBaseEstimateWithdrawChannelFeeRequest(): EstimateWithdrawChannelFeeRequest {
  return { network: undefined, channelId: "", assetAmounts: {}, feeOption: undefined };
}

export const EstimateWithdrawChannelFeeRequest: MessageFns<EstimateWithdrawChannelFeeRequest> = {
  encode(message: EstimateWithdrawChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      EstimateWithdrawChannelFeeRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateWithdrawChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateWithdrawChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = EstimateWithdrawChannelFeeRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateWithdrawChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: WithdrawAmount }>((acc, [key, value]) => {
          acc[key] = WithdrawAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateWithdrawChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = WithdrawAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeRequest>, I>>(
    base?: I,
  ): EstimateWithdrawChannelFeeRequest {
    return EstimateWithdrawChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeRequest>, I>>(
    object: I,
  ): EstimateWithdrawChannelFeeRequest {
    const message = createBaseEstimateWithdrawChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: WithdrawAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WithdrawAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateWithdrawChannelFeeRequest_AssetAmountsEntry(): EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const EstimateWithdrawChannelFeeRequest_AssetAmountsEntry: MessageFns<
  EstimateWithdrawChannelFeeRequest_AssetAmountsEntry
> = {
  encode(
    message: EstimateWithdrawChannelFeeRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WithdrawAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateWithdrawChannelFeeRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WithdrawAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? WithdrawAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EstimateWithdrawChannelFeeRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WithdrawAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
    return EstimateWithdrawChannelFeeRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): EstimateWithdrawChannelFeeRequest_AssetAmountsEntry {
    const message = createBaseEstimateWithdrawChannelFeeRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WithdrawAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEstimateWithdrawChannelFeeResponse(): EstimateWithdrawChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateWithdrawChannelFeeResponse: MessageFns<EstimateWithdrawChannelFeeResponse> = {
  encode(message: EstimateWithdrawChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateWithdrawChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateWithdrawChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateWithdrawChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateWithdrawChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeResponse>, I>>(
    base?: I,
  ): EstimateWithdrawChannelFeeResponse {
    return EstimateWithdrawChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateWithdrawChannelFeeResponse>, I>>(
    object: I,
  ): EstimateWithdrawChannelFeeResponse {
    const message = createBaseEstimateWithdrawChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseWithdrawChannelRequest(): WithdrawChannelRequest {
  return { network: undefined, channelId: "", assetAmounts: {}, feeOption: undefined };
}

export const WithdrawChannelRequest: MessageFns<WithdrawChannelRequest> = {
  encode(message: WithdrawChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      WithdrawChannelRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = WithdrawChannelRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: WithdrawAmount }>((acc, [key, value]) => {
          acc[key] = WithdrawAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: WithdrawChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = WithdrawAmount.toJSON(v);
        });
      }
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawChannelRequest>, I>>(base?: I): WithdrawChannelRequest {
    return WithdrawChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawChannelRequest>, I>>(object: I): WithdrawChannelRequest {
    const message = createBaseWithdrawChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: WithdrawAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WithdrawAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseWithdrawChannelRequest_AssetAmountsEntry(): WithdrawChannelRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const WithdrawChannelRequest_AssetAmountsEntry: MessageFns<WithdrawChannelRequest_AssetAmountsEntry> = {
  encode(message: WithdrawChannelRequest_AssetAmountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WithdrawAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawChannelRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawChannelRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WithdrawAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawChannelRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? WithdrawAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WithdrawChannelRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WithdrawAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawChannelRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): WithdrawChannelRequest_AssetAmountsEntry {
    return WithdrawChannelRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawChannelRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): WithdrawChannelRequest_AssetAmountsEntry {
    const message = createBaseWithdrawChannelRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WithdrawAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWithdrawChannelResponse(): WithdrawChannelResponse {
  return { txid: "" };
}

export const WithdrawChannelResponse: MessageFns<WithdrawChannelResponse> = {
  encode(message: WithdrawChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawChannelResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: WithdrawChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawChannelResponse>, I>>(base?: I): WithdrawChannelResponse {
    return WithdrawChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawChannelResponse>, I>>(object: I): WithdrawChannelResponse {
    const message = createBaseWithdrawChannelResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseEstimateCloseChannelFeeRequest(): EstimateCloseChannelFeeRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const EstimateCloseChannelFeeRequest: MessageFns<EstimateCloseChannelFeeRequest> = {
  encode(message: EstimateCloseChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateCloseChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateCloseChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateCloseChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateCloseChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateCloseChannelFeeRequest>, I>>(base?: I): EstimateCloseChannelFeeRequest {
    return EstimateCloseChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateCloseChannelFeeRequest>, I>>(
    object: I,
  ): EstimateCloseChannelFeeRequest {
    const message = createBaseEstimateCloseChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateCloseChannelFeeResponse(): EstimateCloseChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateCloseChannelFeeResponse: MessageFns<EstimateCloseChannelFeeResponse> = {
  encode(message: EstimateCloseChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateCloseChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateCloseChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateCloseChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateCloseChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateCloseChannelFeeResponse>, I>>(base?: I): EstimateCloseChannelFeeResponse {
    return EstimateCloseChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateCloseChannelFeeResponse>, I>>(
    object: I,
  ): EstimateCloseChannelFeeResponse {
    const message = createBaseEstimateCloseChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseCloseChannelRequest(): CloseChannelRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const CloseChannelRequest: MessageFns<CloseChannelRequest> = {
  encode(message: CloseChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: CloseChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseChannelRequest>, I>>(base?: I): CloseChannelRequest {
    return CloseChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseChannelRequest>, I>>(object: I): CloseChannelRequest {
    const message = createBaseCloseChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseCloseChannelResponse(): CloseChannelResponse {
  return { txid: "" };
}

export const CloseChannelResponse: MessageFns<CloseChannelResponse> = {
  encode(message: CloseChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseChannelResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: CloseChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseChannelResponse>, I>>(base?: I): CloseChannelResponse {
    return CloseChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseChannelResponse>, I>>(object: I): CloseChannelResponse {
    const message = createBaseCloseChannelResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseEstimateForceCloseChannelFeeRequest(): EstimateForceCloseChannelFeeRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const EstimateForceCloseChannelFeeRequest: MessageFns<EstimateForceCloseChannelFeeRequest> = {
  encode(message: EstimateForceCloseChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateForceCloseChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateForceCloseChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateForceCloseChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateForceCloseChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateForceCloseChannelFeeRequest>, I>>(
    base?: I,
  ): EstimateForceCloseChannelFeeRequest {
    return EstimateForceCloseChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateForceCloseChannelFeeRequest>, I>>(
    object: I,
  ): EstimateForceCloseChannelFeeRequest {
    const message = createBaseEstimateForceCloseChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateForceCloseChannelFeeResponse(): EstimateForceCloseChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateForceCloseChannelFeeResponse: MessageFns<EstimateForceCloseChannelFeeResponse> = {
  encode(message: EstimateForceCloseChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateForceCloseChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateForceCloseChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateForceCloseChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateForceCloseChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateForceCloseChannelFeeResponse>, I>>(
    base?: I,
  ): EstimateForceCloseChannelFeeResponse {
    return EstimateForceCloseChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateForceCloseChannelFeeResponse>, I>>(
    object: I,
  ): EstimateForceCloseChannelFeeResponse {
    const message = createBaseEstimateForceCloseChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseForceCloseChannelRequest(): ForceCloseChannelRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const ForceCloseChannelRequest: MessageFns<ForceCloseChannelRequest> = {
  encode(message: ForceCloseChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForceCloseChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceCloseChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceCloseChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: ForceCloseChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForceCloseChannelRequest>, I>>(base?: I): ForceCloseChannelRequest {
    return ForceCloseChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForceCloseChannelRequest>, I>>(object: I): ForceCloseChannelRequest {
    const message = createBaseForceCloseChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseForceCloseChannelResponse(): ForceCloseChannelResponse {
  return { txid: "" };
}

export const ForceCloseChannelResponse: MessageFns<ForceCloseChannelResponse> = {
  encode(message: ForceCloseChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForceCloseChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceCloseChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceCloseChannelResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: ForceCloseChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForceCloseChannelResponse>, I>>(base?: I): ForceCloseChannelResponse {
    return ForceCloseChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForceCloseChannelResponse>, I>>(object: I): ForceCloseChannelResponse {
    const message = createBaseForceCloseChannelResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseEstimateRedeemClosedChannelFeeRequest(): EstimateRedeemClosedChannelFeeRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const EstimateRedeemClosedChannelFeeRequest: MessageFns<EstimateRedeemClosedChannelFeeRequest> = {
  encode(message: EstimateRedeemClosedChannelFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateRedeemClosedChannelFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateRedeemClosedChannelFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateRedeemClosedChannelFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: EstimateRedeemClosedChannelFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateRedeemClosedChannelFeeRequest>, I>>(
    base?: I,
  ): EstimateRedeemClosedChannelFeeRequest {
    return EstimateRedeemClosedChannelFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateRedeemClosedChannelFeeRequest>, I>>(
    object: I,
  ): EstimateRedeemClosedChannelFeeRequest {
    const message = createBaseEstimateRedeemClosedChannelFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseEstimateRedeemClosedChannelFeeResponse(): EstimateRedeemClosedChannelFeeResponse {
  return { fee: undefined };
}

export const EstimateRedeemClosedChannelFeeResponse: MessageFns<EstimateRedeemClosedChannelFeeResponse> = {
  encode(message: EstimateRedeemClosedChannelFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateRedeemClosedChannelFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateRedeemClosedChannelFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateRedeemClosedChannelFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimateRedeemClosedChannelFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateRedeemClosedChannelFeeResponse>, I>>(
    base?: I,
  ): EstimateRedeemClosedChannelFeeResponse {
    return EstimateRedeemClosedChannelFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateRedeemClosedChannelFeeResponse>, I>>(
    object: I,
  ): EstimateRedeemClosedChannelFeeResponse {
    const message = createBaseEstimateRedeemClosedChannelFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseRedeemClosedChannelRequest(): RedeemClosedChannelRequest {
  return { network: undefined, channelId: "", assetIds: [], feeOption: undefined };
}

export const RedeemClosedChannelRequest: MessageFns<RedeemClosedChannelRequest> = {
  encode(message: RedeemClosedChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    for (const v of message.assetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.feeOption !== undefined) {
      FeeOption.encode(message.feeOption, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedeemClosedChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemClosedChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeOption = FeeOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedeemClosedChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
      feeOption: isSet(object.feeOption) ? FeeOption.fromJSON(object.feeOption) : undefined,
    };
  },

  toJSON(message: RedeemClosedChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    if (message.feeOption !== undefined) {
      obj.feeOption = FeeOption.toJSON(message.feeOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedeemClosedChannelRequest>, I>>(base?: I): RedeemClosedChannelRequest {
    return RedeemClosedChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedeemClosedChannelRequest>, I>>(object: I): RedeemClosedChannelRequest {
    const message = createBaseRedeemClosedChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetIds = object.assetIds?.map((e) => e) || [];
    message.feeOption = (object.feeOption !== undefined && object.feeOption !== null)
      ? FeeOption.fromPartial(object.feeOption)
      : undefined;
    return message;
  },
};

function createBaseRedeemClosedChannelResponse(): RedeemClosedChannelResponse {
  return { txid: "" };
}

export const RedeemClosedChannelResponse: MessageFns<RedeemClosedChannelResponse> = {
  encode(message: RedeemClosedChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedeemClosedChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemClosedChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedeemClosedChannelResponse {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: RedeemClosedChannelResponse): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedeemClosedChannelResponse>, I>>(base?: I): RedeemClosedChannelResponse {
    return RedeemClosedChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedeemClosedChannelResponse>, I>>(object: I): RedeemClosedChannelResponse {
    const message = createBaseRedeemClosedChannelResponse();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseWaitForActiveAssetChannelRequest(): WaitForActiveAssetChannelRequest {
  return {
    network: undefined,
    channelId: "",
    assetId: "",
    activeSending: false,
    activeReceiving: false,
    updatable: false,
  };
}

export const WaitForActiveAssetChannelRequest: MessageFns<WaitForActiveAssetChannelRequest> = {
  encode(message: WaitForActiveAssetChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.activeSending !== false) {
      writer.uint32(32).bool(message.activeSending);
    }
    if (message.activeReceiving !== false) {
      writer.uint32(40).bool(message.activeReceiving);
    }
    if (message.updatable !== false) {
      writer.uint32(48).bool(message.updatable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WaitForActiveAssetChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForActiveAssetChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activeSending = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activeReceiving = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.updatable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitForActiveAssetChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      activeSending: isSet(object.activeSending) ? globalThis.Boolean(object.activeSending) : false,
      activeReceiving: isSet(object.activeReceiving) ? globalThis.Boolean(object.activeReceiving) : false,
      updatable: isSet(object.updatable) ? globalThis.Boolean(object.updatable) : false,
    };
  },

  toJSON(message: WaitForActiveAssetChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.activeSending !== false) {
      obj.activeSending = message.activeSending;
    }
    if (message.activeReceiving !== false) {
      obj.activeReceiving = message.activeReceiving;
    }
    if (message.updatable !== false) {
      obj.updatable = message.updatable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WaitForActiveAssetChannelRequest>, I>>(
    base?: I,
  ): WaitForActiveAssetChannelRequest {
    return WaitForActiveAssetChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WaitForActiveAssetChannelRequest>, I>>(
    object: I,
  ): WaitForActiveAssetChannelRequest {
    const message = createBaseWaitForActiveAssetChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetId = object.assetId ?? "";
    message.activeSending = object.activeSending ?? false;
    message.activeReceiving = object.activeReceiving ?? false;
    message.updatable = object.updatable ?? false;
    return message;
  },
};

function createBaseWaitForActiveAssetChannelResponse(): WaitForActiveAssetChannelResponse {
  return {};
}

export const WaitForActiveAssetChannelResponse: MessageFns<WaitForActiveAssetChannelResponse> = {
  encode(_: WaitForActiveAssetChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WaitForActiveAssetChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForActiveAssetChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WaitForActiveAssetChannelResponse {
    return {};
  },

  toJSON(_: WaitForActiveAssetChannelResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WaitForActiveAssetChannelResponse>, I>>(
    base?: I,
  ): WaitForActiveAssetChannelResponse {
    return WaitForActiveAssetChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WaitForActiveAssetChannelResponse>, I>>(
    _: I,
  ): WaitForActiveAssetChannelResponse {
    const message = createBaseWaitForActiveAssetChannelResponse();
    return message;
  },
};

function createBaseSendChannelPaymentRequest(): SendChannelPaymentRequest {
  return { network: undefined, channelId: "", assetAmounts: {}, hashlock: undefined, expiryTimeoutSecs: undefined };
}

export const SendChannelPaymentRequest: MessageFns<SendChannelPaymentRequest> = {
  encode(message: SendChannelPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      SendChannelPaymentRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.hashlock !== undefined) {
      Hashlock.encode(message.hashlock, writer.uint32(34).fork()).join();
    }
    if (message.expiryTimeoutSecs !== undefined) {
      writer.uint32(40).uint64(message.expiryTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendChannelPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendChannelPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendChannelPaymentRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashlock = Hashlock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiryTimeoutSecs = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendChannelPaymentRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      hashlock: isSet(object.hashlock) ? Hashlock.fromJSON(object.hashlock) : undefined,
      expiryTimeoutSecs: isSet(object.expiryTimeoutSecs) ? globalThis.String(object.expiryTimeoutSecs) : undefined,
    };
  },

  toJSON(message: SendChannelPaymentRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.hashlock !== undefined) {
      obj.hashlock = Hashlock.toJSON(message.hashlock);
    }
    if (message.expiryTimeoutSecs !== undefined) {
      obj.expiryTimeoutSecs = message.expiryTimeoutSecs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendChannelPaymentRequest>, I>>(base?: I): SendChannelPaymentRequest {
    return SendChannelPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendChannelPaymentRequest>, I>>(object: I): SendChannelPaymentRequest {
    const message = createBaseSendChannelPaymentRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.hashlock = (object.hashlock !== undefined && object.hashlock !== null)
      ? Hashlock.fromPartial(object.hashlock)
      : undefined;
    message.expiryTimeoutSecs = object.expiryTimeoutSecs ?? undefined;
    return message;
  },
};

function createBaseSendChannelPaymentRequest_AssetAmountsEntry(): SendChannelPaymentRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const SendChannelPaymentRequest_AssetAmountsEntry: MessageFns<SendChannelPaymentRequest_AssetAmountsEntry> = {
  encode(
    message: SendChannelPaymentRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendChannelPaymentRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendChannelPaymentRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendChannelPaymentRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SendChannelPaymentRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendChannelPaymentRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): SendChannelPaymentRequest_AssetAmountsEntry {
    return SendChannelPaymentRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendChannelPaymentRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): SendChannelPaymentRequest_AssetAmountsEntry {
    const message = createBaseSendChannelPaymentRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSendChannelPaymentResponse(): SendChannelPaymentResponse {
  return { paymentId: "" };
}

export const SendChannelPaymentResponse: MessageFns<SendChannelPaymentResponse> = {
  encode(message: SendChannelPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendChannelPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendChannelPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendChannelPaymentResponse {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: SendChannelPaymentResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendChannelPaymentResponse>, I>>(base?: I): SendChannelPaymentResponse {
    return SendChannelPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendChannelPaymentResponse>, I>>(object: I): SendChannelPaymentResponse {
    const message = createBaseSendChannelPaymentResponse();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseEstimateSendPaymentFeeRequest(): EstimateSendPaymentFeeRequest {
  return {
    network: undefined,
    recipientNodeId: "",
    assetAmounts: {},
    hashlock: undefined,
    expiryTimeoutSecs: undefined,
  };
}

export const EstimateSendPaymentFeeRequest: MessageFns<EstimateSendPaymentFeeRequest> = {
  encode(message: EstimateSendPaymentFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.recipientNodeId !== "") {
      writer.uint32(18).string(message.recipientNodeId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      EstimateSendPaymentFeeRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    if (message.hashlock !== undefined) {
      Hashlock.encode(message.hashlock, writer.uint32(34).fork()).join();
    }
    if (message.expiryTimeoutSecs !== undefined) {
      writer.uint32(40).uint64(message.expiryTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSendPaymentFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSendPaymentFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipientNodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = EstimateSendPaymentFeeRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashlock = Hashlock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiryTimeoutSecs = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSendPaymentFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      recipientNodeId: isSet(object.recipientNodeId) ? globalThis.String(object.recipientNodeId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      hashlock: isSet(object.hashlock) ? Hashlock.fromJSON(object.hashlock) : undefined,
      expiryTimeoutSecs: isSet(object.expiryTimeoutSecs) ? globalThis.String(object.expiryTimeoutSecs) : undefined,
    };
  },

  toJSON(message: EstimateSendPaymentFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.recipientNodeId !== "") {
      obj.recipientNodeId = message.recipientNodeId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.hashlock !== undefined) {
      obj.hashlock = Hashlock.toJSON(message.hashlock);
    }
    if (message.expiryTimeoutSecs !== undefined) {
      obj.expiryTimeoutSecs = message.expiryTimeoutSecs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSendPaymentFeeRequest>, I>>(base?: I): EstimateSendPaymentFeeRequest {
    return EstimateSendPaymentFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSendPaymentFeeRequest>, I>>(
    object: I,
  ): EstimateSendPaymentFeeRequest {
    const message = createBaseEstimateSendPaymentFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.recipientNodeId = object.recipientNodeId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.hashlock = (object.hashlock !== undefined && object.hashlock !== null)
      ? Hashlock.fromPartial(object.hashlock)
      : undefined;
    message.expiryTimeoutSecs = object.expiryTimeoutSecs ?? undefined;
    return message;
  },
};

function createBaseEstimateSendPaymentFeeRequest_AssetAmountsEntry(): EstimateSendPaymentFeeRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const EstimateSendPaymentFeeRequest_AssetAmountsEntry: MessageFns<
  EstimateSendPaymentFeeRequest_AssetAmountsEntry
> = {
  encode(
    message: EstimateSendPaymentFeeRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSendPaymentFeeRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSendPaymentFeeRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSendPaymentFeeRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EstimateSendPaymentFeeRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSendPaymentFeeRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): EstimateSendPaymentFeeRequest_AssetAmountsEntry {
    return EstimateSendPaymentFeeRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSendPaymentFeeRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): EstimateSendPaymentFeeRequest_AssetAmountsEntry {
    const message = createBaseEstimateSendPaymentFeeRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEstimateSendPaymentFeeResponse(): EstimateSendPaymentFeeResponse {
  return { fees: {} };
}

export const EstimateSendPaymentFeeResponse: MessageFns<EstimateSendPaymentFeeResponse> = {
  encode(message: EstimateSendPaymentFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fees).forEach(([key, value]) => {
      EstimateSendPaymentFeeResponse_FeesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSendPaymentFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSendPaymentFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = EstimateSendPaymentFeeResponse_FeesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fees[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSendPaymentFeeResponse {
    return {
      fees: isObject(object.fees)
        ? Object.entries(object.fees).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
          acc[key] = DecimalString.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EstimateSendPaymentFeeResponse): unknown {
    const obj: any = {};
    if (message.fees) {
      const entries = Object.entries(message.fees);
      if (entries.length > 0) {
        obj.fees = {};
        entries.forEach(([k, v]) => {
          obj.fees[k] = DecimalString.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSendPaymentFeeResponse>, I>>(base?: I): EstimateSendPaymentFeeResponse {
    return EstimateSendPaymentFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSendPaymentFeeResponse>, I>>(
    object: I,
  ): EstimateSendPaymentFeeResponse {
    const message = createBaseEstimateSendPaymentFeeResponse();
    message.fees = Object.entries(object.fees ?? {}).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DecimalString.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseEstimateSendPaymentFeeResponse_FeesEntry(): EstimateSendPaymentFeeResponse_FeesEntry {
  return { key: "", value: undefined };
}

export const EstimateSendPaymentFeeResponse_FeesEntry: MessageFns<EstimateSendPaymentFeeResponse_FeesEntry> = {
  encode(message: EstimateSendPaymentFeeResponse_FeesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DecimalString.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSendPaymentFeeResponse_FeesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSendPaymentFeeResponse_FeesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSendPaymentFeeResponse_FeesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DecimalString.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EstimateSendPaymentFeeResponse_FeesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DecimalString.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSendPaymentFeeResponse_FeesEntry>, I>>(
    base?: I,
  ): EstimateSendPaymentFeeResponse_FeesEntry {
    return EstimateSendPaymentFeeResponse_FeesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSendPaymentFeeResponse_FeesEntry>, I>>(
    object: I,
  ): EstimateSendPaymentFeeResponse_FeesEntry {
    const message = createBaseEstimateSendPaymentFeeResponse_FeesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DecimalString.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSendPaymentRequest(): SendPaymentRequest {
  return {
    network: undefined,
    recipientNodeId: "",
    assetAmounts: {},
    hashlock: undefined,
    expiryTimeoutSecs: undefined,
  };
}

export const SendPaymentRequest: MessageFns<SendPaymentRequest> = {
  encode(message: SendPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.recipientNodeId !== "") {
      writer.uint32(18).string(message.recipientNodeId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      SendPaymentRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.hashlock !== undefined) {
      Hashlock.encode(message.hashlock, writer.uint32(34).fork()).join();
    }
    if (message.expiryTimeoutSecs !== undefined) {
      writer.uint32(40).uint64(message.expiryTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipientNodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendPaymentRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashlock = Hashlock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiryTimeoutSecs = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPaymentRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      recipientNodeId: isSet(object.recipientNodeId) ? globalThis.String(object.recipientNodeId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: SendAmount }>((acc, [key, value]) => {
          acc[key] = SendAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
      hashlock: isSet(object.hashlock) ? Hashlock.fromJSON(object.hashlock) : undefined,
      expiryTimeoutSecs: isSet(object.expiryTimeoutSecs) ? globalThis.String(object.expiryTimeoutSecs) : undefined,
    };
  },

  toJSON(message: SendPaymentRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.recipientNodeId !== "") {
      obj.recipientNodeId = message.recipientNodeId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = SendAmount.toJSON(v);
        });
      }
    }
    if (message.hashlock !== undefined) {
      obj.hashlock = Hashlock.toJSON(message.hashlock);
    }
    if (message.expiryTimeoutSecs !== undefined) {
      obj.expiryTimeoutSecs = message.expiryTimeoutSecs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPaymentRequest>, I>>(base?: I): SendPaymentRequest {
    return SendPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPaymentRequest>, I>>(object: I): SendPaymentRequest {
    const message = createBaseSendPaymentRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.recipientNodeId = object.recipientNodeId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: SendAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SendAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.hashlock = (object.hashlock !== undefined && object.hashlock !== null)
      ? Hashlock.fromPartial(object.hashlock)
      : undefined;
    message.expiryTimeoutSecs = object.expiryTimeoutSecs ?? undefined;
    return message;
  },
};

function createBaseSendPaymentRequest_AssetAmountsEntry(): SendPaymentRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const SendPaymentRequest_AssetAmountsEntry: MessageFns<SendPaymentRequest_AssetAmountsEntry> = {
  encode(message: SendPaymentRequest_AssetAmountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SendAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPaymentRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPaymentRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPaymentRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SendAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SendPaymentRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SendAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPaymentRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): SendPaymentRequest_AssetAmountsEntry {
    return SendPaymentRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPaymentRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): SendPaymentRequest_AssetAmountsEntry {
    const message = createBaseSendPaymentRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SendAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSendPaymentResponse(): SendPaymentResponse {
  return { paymentId: "" };
}

export const SendPaymentResponse: MessageFns<SendPaymentResponse> = {
  encode(message: SendPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPaymentResponse {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: SendPaymentResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPaymentResponse>, I>>(base?: I): SendPaymentResponse {
    return SendPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPaymentResponse>, I>>(object: I): SendPaymentResponse {
    const message = createBaseSendPaymentResponse();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseCreateInvoiceRequest(): CreateInvoiceRequest {
  return { network: undefined, assetId: "", amount: undefined, hashlock: undefined, expiryTimeoutSecs: undefined };
}

export const CreateInvoiceRequest: MessageFns<CreateInvoiceRequest> = {
  encode(message: CreateInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.hashlock !== undefined) {
      Hashlock.encode(message.hashlock, writer.uint32(34).fork()).join();
    }
    if (message.expiryTimeoutSecs !== undefined) {
      writer.uint32(40).uint64(message.expiryTimeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashlock = Hashlock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiryTimeoutSecs = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      hashlock: isSet(object.hashlock) ? Hashlock.fromJSON(object.hashlock) : undefined,
      expiryTimeoutSecs: isSet(object.expiryTimeoutSecs) ? globalThis.String(object.expiryTimeoutSecs) : undefined,
    };
  },

  toJSON(message: CreateInvoiceRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.hashlock !== undefined) {
      obj.hashlock = Hashlock.toJSON(message.hashlock);
    }
    if (message.expiryTimeoutSecs !== undefined) {
      obj.expiryTimeoutSecs = message.expiryTimeoutSecs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(base?: I): CreateInvoiceRequest {
    return CreateInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(object: I): CreateInvoiceRequest {
    const message = createBaseCreateInvoiceRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.hashlock = (object.hashlock !== undefined && object.hashlock !== null)
      ? Hashlock.fromPartial(object.hashlock)
      : undefined;
    message.expiryTimeoutSecs = object.expiryTimeoutSecs ?? undefined;
    return message;
  },
};

function createBaseCreateInvoiceResponse(): CreateInvoiceResponse {
  return { invoice: undefined };
}

export const CreateInvoiceResponse: MessageFns<CreateInvoiceResponse> = {
  encode(message: CreateInvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoice !== undefined) {
      Invoice.encode(message.invoice, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoice = Invoice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceResponse {
    return { invoice: isSet(object.invoice) ? Invoice.fromJSON(object.invoice) : undefined };
  },

  toJSON(message: CreateInvoiceResponse): unknown {
    const obj: any = {};
    if (message.invoice !== undefined) {
      obj.invoice = Invoice.toJSON(message.invoice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceResponse>, I>>(base?: I): CreateInvoiceResponse {
    return CreateInvoiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceResponse>, I>>(object: I): CreateInvoiceResponse {
    const message = createBaseCreateInvoiceResponse();
    message.invoice = (object.invoice !== undefined && object.invoice !== null)
      ? Invoice.fromPartial(object.invoice)
      : undefined;
    return message;
  },
};

function createBaseDecodeInvoiceRequest(): DecodeInvoiceRequest {
  return { network: undefined, paymentRequest: "" };
}

export const DecodeInvoiceRequest: MessageFns<DecodeInvoiceRequest> = {
  encode(message: DecodeInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecodeInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecodeInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecodeInvoiceRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
    };
  },

  toJSON(message: DecodeInvoiceRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecodeInvoiceRequest>, I>>(base?: I): DecodeInvoiceRequest {
    return DecodeInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecodeInvoiceRequest>, I>>(object: I): DecodeInvoiceRequest {
    const message = createBaseDecodeInvoiceRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    return message;
  },
};

function createBaseDecodeInvoiceResponse(): DecodeInvoiceResponse {
  return { invoice: undefined };
}

export const DecodeInvoiceResponse: MessageFns<DecodeInvoiceResponse> = {
  encode(message: DecodeInvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoice !== undefined) {
      Invoice.encode(message.invoice, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecodeInvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecodeInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoice = Invoice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecodeInvoiceResponse {
    return { invoice: isSet(object.invoice) ? Invoice.fromJSON(object.invoice) : undefined };
  },

  toJSON(message: DecodeInvoiceResponse): unknown {
    const obj: any = {};
    if (message.invoice !== undefined) {
      obj.invoice = Invoice.toJSON(message.invoice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecodeInvoiceResponse>, I>>(base?: I): DecodeInvoiceResponse {
    return DecodeInvoiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecodeInvoiceResponse>, I>>(object: I): DecodeInvoiceResponse {
    const message = createBaseDecodeInvoiceResponse();
    message.invoice = (object.invoice !== undefined && object.invoice !== null)
      ? Invoice.fromPartial(object.invoice)
      : undefined;
    return message;
  },
};

function createBaseEstimatePayInvoiceFeeRequest(): EstimatePayInvoiceFeeRequest {
  return { network: undefined, paymentRequest: "" };
}

export const EstimatePayInvoiceFeeRequest: MessageFns<EstimatePayInvoiceFeeRequest> = {
  encode(message: EstimatePayInvoiceFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimatePayInvoiceFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimatePayInvoiceFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimatePayInvoiceFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
    };
  },

  toJSON(message: EstimatePayInvoiceFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimatePayInvoiceFeeRequest>, I>>(base?: I): EstimatePayInvoiceFeeRequest {
    return EstimatePayInvoiceFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimatePayInvoiceFeeRequest>, I>>(object: I): EstimatePayInvoiceFeeRequest {
    const message = createBaseEstimatePayInvoiceFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    return message;
  },
};

function createBaseEstimatePayInvoiceFeeResponse(): EstimatePayInvoiceFeeResponse {
  return { fee: undefined };
}

export const EstimatePayInvoiceFeeResponse: MessageFns<EstimatePayInvoiceFeeResponse> = {
  encode(message: EstimatePayInvoiceFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimatePayInvoiceFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimatePayInvoiceFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimatePayInvoiceFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimatePayInvoiceFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimatePayInvoiceFeeResponse>, I>>(base?: I): EstimatePayInvoiceFeeResponse {
    return EstimatePayInvoiceFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimatePayInvoiceFeeResponse>, I>>(
    object: I,
  ): EstimatePayInvoiceFeeResponse {
    const message = createBaseEstimatePayInvoiceFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseEstimatePayEmptyInvoiceFeeRequest(): EstimatePayEmptyInvoiceFeeRequest {
  return { network: undefined, paymentRequest: "", amount: undefined };
}

export const EstimatePayEmptyInvoiceFeeRequest: MessageFns<EstimatePayEmptyInvoiceFeeRequest> = {
  encode(message: EstimatePayEmptyInvoiceFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    if (message.amount !== undefined) {
      SendAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimatePayEmptyInvoiceFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimatePayEmptyInvoiceFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimatePayEmptyInvoiceFeeRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
      amount: isSet(object.amount) ? SendAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: EstimatePayEmptyInvoiceFeeRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    if (message.amount !== undefined) {
      obj.amount = SendAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimatePayEmptyInvoiceFeeRequest>, I>>(
    base?: I,
  ): EstimatePayEmptyInvoiceFeeRequest {
    return EstimatePayEmptyInvoiceFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimatePayEmptyInvoiceFeeRequest>, I>>(
    object: I,
  ): EstimatePayEmptyInvoiceFeeRequest {
    const message = createBaseEstimatePayEmptyInvoiceFeeRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SendAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseEstimatePayEmptyInvoiceFeeResponse(): EstimatePayEmptyInvoiceFeeResponse {
  return { fee: undefined };
}

export const EstimatePayEmptyInvoiceFeeResponse: MessageFns<EstimatePayEmptyInvoiceFeeResponse> = {
  encode(message: EstimatePayEmptyInvoiceFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimatePayEmptyInvoiceFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimatePayEmptyInvoiceFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimatePayEmptyInvoiceFeeResponse {
    return { fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined };
  },

  toJSON(message: EstimatePayEmptyInvoiceFeeResponse): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimatePayEmptyInvoiceFeeResponse>, I>>(
    base?: I,
  ): EstimatePayEmptyInvoiceFeeResponse {
    return EstimatePayEmptyInvoiceFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimatePayEmptyInvoiceFeeResponse>, I>>(
    object: I,
  ): EstimatePayEmptyInvoiceFeeResponse {
    const message = createBaseEstimatePayEmptyInvoiceFeeResponse();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBasePayEmptyInvoiceRequest(): PayEmptyInvoiceRequest {
  return { network: undefined, paymentRequest: "", amount: undefined };
}

export const PayEmptyInvoiceRequest: MessageFns<PayEmptyInvoiceRequest> = {
  encode(message: PayEmptyInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    if (message.amount !== undefined) {
      SendAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayEmptyInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayEmptyInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SendAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayEmptyInvoiceRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
      amount: isSet(object.amount) ? SendAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: PayEmptyInvoiceRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    if (message.amount !== undefined) {
      obj.amount = SendAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayEmptyInvoiceRequest>, I>>(base?: I): PayEmptyInvoiceRequest {
    return PayEmptyInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayEmptyInvoiceRequest>, I>>(object: I): PayEmptyInvoiceRequest {
    const message = createBasePayEmptyInvoiceRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SendAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePayEmptyInvoiceResponse(): PayEmptyInvoiceResponse {
  return { paymentId: "" };
}

export const PayEmptyInvoiceResponse: MessageFns<PayEmptyInvoiceResponse> = {
  encode(message: PayEmptyInvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayEmptyInvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayEmptyInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayEmptyInvoiceResponse {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: PayEmptyInvoiceResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayEmptyInvoiceResponse>, I>>(base?: I): PayEmptyInvoiceResponse {
    return PayEmptyInvoiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayEmptyInvoiceResponse>, I>>(object: I): PayEmptyInvoiceResponse {
    const message = createBasePayEmptyInvoiceResponse();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBasePayInvoiceRequest(): PayInvoiceRequest {
  return { network: undefined, paymentRequest: "" };
}

export const PayInvoiceRequest: MessageFns<PayInvoiceRequest> = {
  encode(message: PayInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayInvoiceRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
    };
  },

  toJSON(message: PayInvoiceRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayInvoiceRequest>, I>>(base?: I): PayInvoiceRequest {
    return PayInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayInvoiceRequest>, I>>(object: I): PayInvoiceRequest {
    const message = createBasePayInvoiceRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    return message;
  },
};

function createBasePayInvoiceResponse(): PayInvoiceResponse {
  return { paymentId: "" };
}

export const PayInvoiceResponse: MessageFns<PayInvoiceResponse> = {
  encode(message: PayInvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayInvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayInvoiceResponse {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: PayInvoiceResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayInvoiceResponse>, I>>(base?: I): PayInvoiceResponse {
    return PayInvoiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayInvoiceResponse>, I>>(object: I): PayInvoiceResponse {
    const message = createBasePayInvoiceResponse();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseResolveHashlockPaymentRequest(): ResolveHashlockPaymentRequest {
  return { network: undefined, paymentId: "", paymentPreimage: "" };
}

export const ResolveHashlockPaymentRequest: MessageFns<ResolveHashlockPaymentRequest> = {
  encode(message: ResolveHashlockPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.paymentPreimage !== "") {
      writer.uint32(26).string(message.paymentPreimage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveHashlockPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveHashlockPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentPreimage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolveHashlockPaymentRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      paymentPreimage: isSet(object.paymentPreimage) ? globalThis.String(object.paymentPreimage) : "",
    };
  },

  toJSON(message: ResolveHashlockPaymentRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.paymentPreimage !== "") {
      obj.paymentPreimage = message.paymentPreimage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolveHashlockPaymentRequest>, I>>(base?: I): ResolveHashlockPaymentRequest {
    return ResolveHashlockPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolveHashlockPaymentRequest>, I>>(
    object: I,
  ): ResolveHashlockPaymentRequest {
    const message = createBaseResolveHashlockPaymentRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentId = object.paymentId ?? "";
    message.paymentPreimage = object.paymentPreimage ?? "";
    return message;
  },
};

function createBaseResolveHashlockPaymentResponse(): ResolveHashlockPaymentResponse {
  return {};
}

export const ResolveHashlockPaymentResponse: MessageFns<ResolveHashlockPaymentResponse> = {
  encode(_: ResolveHashlockPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveHashlockPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveHashlockPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResolveHashlockPaymentResponse {
    return {};
  },

  toJSON(_: ResolveHashlockPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolveHashlockPaymentResponse>, I>>(base?: I): ResolveHashlockPaymentResponse {
    return ResolveHashlockPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolveHashlockPaymentResponse>, I>>(_: I): ResolveHashlockPaymentResponse {
    const message = createBaseResolveHashlockPaymentResponse();
    return message;
  },
};

function createBaseRejectPaymentRequest(): RejectPaymentRequest {
  return { network: undefined, paymentId: "" };
}

export const RejectPaymentRequest: MessageFns<RejectPaymentRequest> = {
  encode(message: RejectPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectPaymentRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
    };
  },

  toJSON(message: RejectPaymentRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectPaymentRequest>, I>>(base?: I): RejectPaymentRequest {
    return RejectPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectPaymentRequest>, I>>(object: I): RejectPaymentRequest {
    const message = createBaseRejectPaymentRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseRejectPaymentResponse(): RejectPaymentResponse {
  return {};
}

export const RejectPaymentResponse: MessageFns<RejectPaymentResponse> = {
  encode(_: RejectPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RejectPaymentResponse {
    return {};
  },

  toJSON(_: RejectPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectPaymentResponse>, I>>(base?: I): RejectPaymentResponse {
    return RejectPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectPaymentResponse>, I>>(_: I): RejectPaymentResponse {
    const message = createBaseRejectPaymentResponse();
    return message;
  },
};

function createBaseAllowDualFundedChannelRequest(): AllowDualFundedChannelRequest {
  return { network: undefined, nodeId: "", assetAmounts: {} };
}

export const AllowDualFundedChannelRequest: MessageFns<AllowDualFundedChannelRequest> = {
  encode(message: AllowDualFundedChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    Object.entries(message.assetAmounts).forEach(([key, value]) => {
      AllowDualFundedChannelRequest_AssetAmountsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowDualFundedChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowDualFundedChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = AllowDualFundedChannelRequest_AssetAmountsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.assetAmounts[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowDualFundedChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      assetAmounts: isObject(object.assetAmounts)
        ? Object.entries(object.assetAmounts).reduce<{ [key: string]: DualFundAmount }>((acc, [key, value]) => {
          acc[key] = DualFundAmount.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AllowDualFundedChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.assetAmounts) {
      const entries = Object.entries(message.assetAmounts);
      if (entries.length > 0) {
        obj.assetAmounts = {};
        entries.forEach(([k, v]) => {
          obj.assetAmounts[k] = DualFundAmount.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowDualFundedChannelRequest>, I>>(base?: I): AllowDualFundedChannelRequest {
    return AllowDualFundedChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowDualFundedChannelRequest>, I>>(
    object: I,
  ): AllowDualFundedChannelRequest {
    const message = createBaseAllowDualFundedChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.nodeId = object.nodeId ?? "";
    message.assetAmounts = Object.entries(object.assetAmounts ?? {}).reduce<{ [key: string]: DualFundAmount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DualFundAmount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAllowDualFundedChannelRequest_AssetAmountsEntry(): AllowDualFundedChannelRequest_AssetAmountsEntry {
  return { key: "", value: undefined };
}

export const AllowDualFundedChannelRequest_AssetAmountsEntry: MessageFns<
  AllowDualFundedChannelRequest_AssetAmountsEntry
> = {
  encode(
    message: AllowDualFundedChannelRequest_AssetAmountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DualFundAmount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowDualFundedChannelRequest_AssetAmountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowDualFundedChannelRequest_AssetAmountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DualFundAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowDualFundedChannelRequest_AssetAmountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DualFundAmount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AllowDualFundedChannelRequest_AssetAmountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DualFundAmount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowDualFundedChannelRequest_AssetAmountsEntry>, I>>(
    base?: I,
  ): AllowDualFundedChannelRequest_AssetAmountsEntry {
    return AllowDualFundedChannelRequest_AssetAmountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowDualFundedChannelRequest_AssetAmountsEntry>, I>>(
    object: I,
  ): AllowDualFundedChannelRequest_AssetAmountsEntry {
    const message = createBaseAllowDualFundedChannelRequest_AssetAmountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DualFundAmount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAllowDualFundedChannelResponse(): AllowDualFundedChannelResponse {
  return {};
}

export const AllowDualFundedChannelResponse: MessageFns<AllowDualFundedChannelResponse> = {
  encode(_: AllowDualFundedChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowDualFundedChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowDualFundedChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AllowDualFundedChannelResponse {
    return {};
  },

  toJSON(_: AllowDualFundedChannelResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowDualFundedChannelResponse>, I>>(base?: I): AllowDualFundedChannelResponse {
    return AllowDualFundedChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowDualFundedChannelResponse>, I>>(_: I): AllowDualFundedChannelResponse {
    const message = createBaseAllowDualFundedChannelResponse();
    return message;
  },
};

/**
 * Node service definition for managing node-specific operations.
 * This service provides methods to manage channels, payments, and
 * connections to peers on different networks.
 */
export interface NodeService {
  /**
   * Connect to a peer on a specific network.
   * This allows the node to establish a connection with another node
   * for communication and channel management.
   */
  ConnectToPeer(request: ConnectToPeerRequest): Promise<ConnectToPeerResponse>;
  /** Get the list of connected peers on a specific network. */
  GetConnectedPeers(request: GetConnectedPeersRequest): Promise<GetConnectedPeersResponse>;
  /** Estimate the onchain fee for opening a channel with a specific peer. */
  EstimateOpenChannelFee(request: EstimateOpenChannelFeeRequest): Promise<EstimateOpenChannelFeeResponse>;
  /**
   * Open a channel with a specific peer on a specific network.
   * This operation will create a channel and allocate assets to it.
   * The channel will be funded with the specified asset amounts.
   */
  OpenChannel(request: OpenChannelRequest): Promise<OpenChannelResponse>;
  /** Estimate the onchain fee for depositing assets into an existing channel. */
  EstimateDepositChannelFee(request: EstimateDepositChannelFeeRequest): Promise<EstimateDepositChannelFeeResponse>;
  /**
   * Deposit assets into an existing channel on a specific network.
   * This operation will add more assets to the channel, increasing its
   * capacity for future transactions.
   */
  DepositChannel(request: DepositChannelRequest): Promise<DepositChannelResponse>;
  /** Estimate the onchain fee for withdrawing assets from an existing channel. */
  EstimateWithdrawChannelFee(request: EstimateWithdrawChannelFeeRequest): Promise<EstimateWithdrawChannelFeeResponse>;
  /**
   * Withdraw assets from an existing channel on a specific network.
   * This operation will remove assets from the channel, reducing its
   * capacity for future transactions.
   * The assets will be sent back to the respective parties.
   */
  WithdrawChannel(request: WithdrawChannelRequest): Promise<WithdrawChannelResponse>;
  /** Estimate the onchain fee for closing a channel. */
  EstimateCloseChannelFee(request: EstimateCloseChannelFeeRequest): Promise<EstimateCloseChannelFeeResponse>;
  /**
   * Close a channel on a specific network.
   * This operation will settle the channel and return the assets to
   * the respective parties.
   */
  CloseChannel(request: CloseChannelRequest): Promise<CloseChannelResponse>;
  /** Estimate the onchain fee for force-closing a channel. */
  EstimateForceCloseChannelFee(
    request: EstimateForceCloseChannelFeeRequest,
  ): Promise<EstimateForceCloseChannelFeeResponse>;
  /**
   * Force-close a channel on a specific network.
   * This operation will close the channel without waiting for the
   * normal settlement process. It is typically used in cases where
   * the channel is stuck or one party is unresponsive.
   * The assets will be spendable only after a dispute period.
   * Depending on the protocol, this may require an additional
   * transaction to redeem the assets after the dispute period expires.
   * This operation may incur higher fees than a normal close.
   */
  ForceCloseChannel(request: ForceCloseChannelRequest): Promise<ForceCloseChannelResponse>;
  /** Estimate the onchain fee for redeeming a closed channel. */
  EstimateRedeemClosedChannelFee(
    request: EstimateRedeemClosedChannelFeeRequest,
  ): Promise<EstimateRedeemClosedChannelFeeResponse>;
  /**
   * Redeem a closed channel on a specific network.
   * This operation will settle the channel and return the assets to
   * the respective parties. It is used after a force-close
   * operation to finalize the settlement process and withdraw the
   * assets from the channel.
   */
  RedeemClosedChannel(request: RedeemClosedChannelRequest): Promise<RedeemClosedChannelResponse>;
  /**
   * Waits for an asset channel to updatable and/or active for sending/receiving
   * funds.
   */
  WaitForActiveAssetChannel(request: WaitForActiveAssetChannelRequest): Promise<WaitForActiveAssetChannelResponse>;
  /** Send a payment through a specific channel on a specific network. */
  SendChannelPayment(request: SendChannelPaymentRequest): Promise<SendChannelPaymentResponse>;
  /**
   * Estimate the offchain fee for sending a payment on a
   * network. This operation will find the best route for the payment
   * and calculate the fee for sending the payment through the
   * network.
   */
  EstimateSendPaymentFee(request: EstimateSendPaymentFeeRequest): Promise<EstimateSendPaymentFeeResponse>;
  /**
   * Send a payment on a specific network. This operation will find the
   * best route for the payment and send the payment through the
   * network. The payment will be routed through the channels and
   * nodes in the network to reach the recipient.
   */
  SendPayment(request: SendPaymentRequest): Promise<SendPaymentResponse>;
  /**
   * Create an invoice for a specific asset on a network.
   * This operation will generate a payment request that can be
   * shared with the payer.
   */
  CreateInvoice(request: CreateInvoiceRequest): Promise<CreateInvoiceResponse>;
  /** Decode an invoice to retrieve its details. */
  DecodeInvoice(request: DecodeInvoiceRequest): Promise<DecodeInvoiceResponse>;
  /** Estimate the offchain fee for paying an invoice. */
  EstimatePayInvoiceFee(request: EstimatePayInvoiceFeeRequest): Promise<EstimatePayInvoiceFeeResponse>;
  /** Pay an invoice on a specific network. */
  PayInvoice(request: PayInvoiceRequest): Promise<PayInvoiceResponse>;
  /**
   * Estimate the offchain fee for paying an empty invoice by providing the
   * amount to pay.
   */
  EstimatePayEmptyInvoiceFee(request: EstimatePayEmptyInvoiceFeeRequest): Promise<EstimatePayEmptyInvoiceFeeResponse>;
  /**
   * Pay an empty invoice on a specific network by providing the
   * amount to pay.
   */
  PayEmptyInvoice(request: PayEmptyInvoiceRequest): Promise<PayEmptyInvoiceResponse>;
  /**
   * Resolve a hashlock payment by providing the payment preimage.
   * This operation will finalize the offchain payment and allow the recipient
   * to claim the funds.
   */
  ResolveHashlockPayment(request: ResolveHashlockPaymentRequest): Promise<ResolveHashlockPaymentResponse>;
  /**
   * Reject a hashlock payment on a specific network.
   * This operation will cancel the payment and unlock the funds for
   * the sender.
   */
  RejectPayment(request: RejectPaymentRequest): Promise<RejectPaymentResponse>;
  /**
   * Allow dual-funded channels for a specific peer on a network.
   * This operation will add the specified asset amounts for the channel to a
   * whitelist and allow the counterparty to dual-fund the channel with those
   * assets when opening a channel. This allows to dual-fund the channel with a
   * single transaction, instead of two separate transactions, saving on fees.
   */
  AllowDualFundedChannel(request: AllowDualFundedChannelRequest): Promise<AllowDualFundedChannelResponse>;
}

export const NodeServiceServiceName = "hydra_app.NodeService";
export class NodeServiceClientImpl implements NodeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NodeServiceServiceName;
    this.rpc = rpc;
    this.ConnectToPeer = this.ConnectToPeer.bind(this);
    this.GetConnectedPeers = this.GetConnectedPeers.bind(this);
    this.EstimateOpenChannelFee = this.EstimateOpenChannelFee.bind(this);
    this.OpenChannel = this.OpenChannel.bind(this);
    this.EstimateDepositChannelFee = this.EstimateDepositChannelFee.bind(this);
    this.DepositChannel = this.DepositChannel.bind(this);
    this.EstimateWithdrawChannelFee = this.EstimateWithdrawChannelFee.bind(this);
    this.WithdrawChannel = this.WithdrawChannel.bind(this);
    this.EstimateCloseChannelFee = this.EstimateCloseChannelFee.bind(this);
    this.CloseChannel = this.CloseChannel.bind(this);
    this.EstimateForceCloseChannelFee = this.EstimateForceCloseChannelFee.bind(this);
    this.ForceCloseChannel = this.ForceCloseChannel.bind(this);
    this.EstimateRedeemClosedChannelFee = this.EstimateRedeemClosedChannelFee.bind(this);
    this.RedeemClosedChannel = this.RedeemClosedChannel.bind(this);
    this.WaitForActiveAssetChannel = this.WaitForActiveAssetChannel.bind(this);
    this.SendChannelPayment = this.SendChannelPayment.bind(this);
    this.EstimateSendPaymentFee = this.EstimateSendPaymentFee.bind(this);
    this.SendPayment = this.SendPayment.bind(this);
    this.CreateInvoice = this.CreateInvoice.bind(this);
    this.DecodeInvoice = this.DecodeInvoice.bind(this);
    this.EstimatePayInvoiceFee = this.EstimatePayInvoiceFee.bind(this);
    this.PayInvoice = this.PayInvoice.bind(this);
    this.EstimatePayEmptyInvoiceFee = this.EstimatePayEmptyInvoiceFee.bind(this);
    this.PayEmptyInvoice = this.PayEmptyInvoice.bind(this);
    this.ResolveHashlockPayment = this.ResolveHashlockPayment.bind(this);
    this.RejectPayment = this.RejectPayment.bind(this);
    this.AllowDualFundedChannel = this.AllowDualFundedChannel.bind(this);
  }
  ConnectToPeer(request: ConnectToPeerRequest): Promise<ConnectToPeerResponse> {
    const data = ConnectToPeerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ConnectToPeer", data);
    return promise.then((data) => ConnectToPeerResponse.decode(new BinaryReader(data)));
  }

  GetConnectedPeers(request: GetConnectedPeersRequest): Promise<GetConnectedPeersResponse> {
    const data = GetConnectedPeersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetConnectedPeers", data);
    return promise.then((data) => GetConnectedPeersResponse.decode(new BinaryReader(data)));
  }

  EstimateOpenChannelFee(request: EstimateOpenChannelFeeRequest): Promise<EstimateOpenChannelFeeResponse> {
    const data = EstimateOpenChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateOpenChannelFee", data);
    return promise.then((data) => EstimateOpenChannelFeeResponse.decode(new BinaryReader(data)));
  }

  OpenChannel(request: OpenChannelRequest): Promise<OpenChannelResponse> {
    const data = OpenChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OpenChannel", data);
    return promise.then((data) => OpenChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateDepositChannelFee(request: EstimateDepositChannelFeeRequest): Promise<EstimateDepositChannelFeeResponse> {
    const data = EstimateDepositChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateDepositChannelFee", data);
    return promise.then((data) => EstimateDepositChannelFeeResponse.decode(new BinaryReader(data)));
  }

  DepositChannel(request: DepositChannelRequest): Promise<DepositChannelResponse> {
    const data = DepositChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DepositChannel", data);
    return promise.then((data) => DepositChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateWithdrawChannelFee(request: EstimateWithdrawChannelFeeRequest): Promise<EstimateWithdrawChannelFeeResponse> {
    const data = EstimateWithdrawChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateWithdrawChannelFee", data);
    return promise.then((data) => EstimateWithdrawChannelFeeResponse.decode(new BinaryReader(data)));
  }

  WithdrawChannel(request: WithdrawChannelRequest): Promise<WithdrawChannelResponse> {
    const data = WithdrawChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WithdrawChannel", data);
    return promise.then((data) => WithdrawChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateCloseChannelFee(request: EstimateCloseChannelFeeRequest): Promise<EstimateCloseChannelFeeResponse> {
    const data = EstimateCloseChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateCloseChannelFee", data);
    return promise.then((data) => EstimateCloseChannelFeeResponse.decode(new BinaryReader(data)));
  }

  CloseChannel(request: CloseChannelRequest): Promise<CloseChannelResponse> {
    const data = CloseChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CloseChannel", data);
    return promise.then((data) => CloseChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateForceCloseChannelFee(
    request: EstimateForceCloseChannelFeeRequest,
  ): Promise<EstimateForceCloseChannelFeeResponse> {
    const data = EstimateForceCloseChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateForceCloseChannelFee", data);
    return promise.then((data) => EstimateForceCloseChannelFeeResponse.decode(new BinaryReader(data)));
  }

  ForceCloseChannel(request: ForceCloseChannelRequest): Promise<ForceCloseChannelResponse> {
    const data = ForceCloseChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ForceCloseChannel", data);
    return promise.then((data) => ForceCloseChannelResponse.decode(new BinaryReader(data)));
  }

  EstimateRedeemClosedChannelFee(
    request: EstimateRedeemClosedChannelFeeRequest,
  ): Promise<EstimateRedeemClosedChannelFeeResponse> {
    const data = EstimateRedeemClosedChannelFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateRedeemClosedChannelFee", data);
    return promise.then((data) => EstimateRedeemClosedChannelFeeResponse.decode(new BinaryReader(data)));
  }

  RedeemClosedChannel(request: RedeemClosedChannelRequest): Promise<RedeemClosedChannelResponse> {
    const data = RedeemClosedChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RedeemClosedChannel", data);
    return promise.then((data) => RedeemClosedChannelResponse.decode(new BinaryReader(data)));
  }

  WaitForActiveAssetChannel(request: WaitForActiveAssetChannelRequest): Promise<WaitForActiveAssetChannelResponse> {
    const data = WaitForActiveAssetChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WaitForActiveAssetChannel", data);
    return promise.then((data) => WaitForActiveAssetChannelResponse.decode(new BinaryReader(data)));
  }

  SendChannelPayment(request: SendChannelPaymentRequest): Promise<SendChannelPaymentResponse> {
    const data = SendChannelPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendChannelPayment", data);
    return promise.then((data) => SendChannelPaymentResponse.decode(new BinaryReader(data)));
  }

  EstimateSendPaymentFee(request: EstimateSendPaymentFeeRequest): Promise<EstimateSendPaymentFeeResponse> {
    const data = EstimateSendPaymentFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateSendPaymentFee", data);
    return promise.then((data) => EstimateSendPaymentFeeResponse.decode(new BinaryReader(data)));
  }

  SendPayment(request: SendPaymentRequest): Promise<SendPaymentResponse> {
    const data = SendPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendPayment", data);
    return promise.then((data) => SendPaymentResponse.decode(new BinaryReader(data)));
  }

  CreateInvoice(request: CreateInvoiceRequest): Promise<CreateInvoiceResponse> {
    const data = CreateInvoiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateInvoice", data);
    return promise.then((data) => CreateInvoiceResponse.decode(new BinaryReader(data)));
  }

  DecodeInvoice(request: DecodeInvoiceRequest): Promise<DecodeInvoiceResponse> {
    const data = DecodeInvoiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DecodeInvoice", data);
    return promise.then((data) => DecodeInvoiceResponse.decode(new BinaryReader(data)));
  }

  EstimatePayInvoiceFee(request: EstimatePayInvoiceFeeRequest): Promise<EstimatePayInvoiceFeeResponse> {
    const data = EstimatePayInvoiceFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimatePayInvoiceFee", data);
    return promise.then((data) => EstimatePayInvoiceFeeResponse.decode(new BinaryReader(data)));
  }

  PayInvoice(request: PayInvoiceRequest): Promise<PayInvoiceResponse> {
    const data = PayInvoiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PayInvoice", data);
    return promise.then((data) => PayInvoiceResponse.decode(new BinaryReader(data)));
  }

  EstimatePayEmptyInvoiceFee(request: EstimatePayEmptyInvoiceFeeRequest): Promise<EstimatePayEmptyInvoiceFeeResponse> {
    const data = EstimatePayEmptyInvoiceFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimatePayEmptyInvoiceFee", data);
    return promise.then((data) => EstimatePayEmptyInvoiceFeeResponse.decode(new BinaryReader(data)));
  }

  PayEmptyInvoice(request: PayEmptyInvoiceRequest): Promise<PayEmptyInvoiceResponse> {
    const data = PayEmptyInvoiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PayEmptyInvoice", data);
    return promise.then((data) => PayEmptyInvoiceResponse.decode(new BinaryReader(data)));
  }

  ResolveHashlockPayment(request: ResolveHashlockPaymentRequest): Promise<ResolveHashlockPaymentResponse> {
    const data = ResolveHashlockPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResolveHashlockPayment", data);
    return promise.then((data) => ResolveHashlockPaymentResponse.decode(new BinaryReader(data)));
  }

  RejectPayment(request: RejectPaymentRequest): Promise<RejectPaymentResponse> {
    const data = RejectPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectPayment", data);
    return promise.then((data) => RejectPaymentResponse.decode(new BinaryReader(data)));
  }

  AllowDualFundedChannel(request: AllowDualFundedChannelRequest): Promise<AllowDualFundedChannelResponse> {
    const data = AllowDualFundedChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllowDualFundedChannel", data);
    return promise.then((data) => AllowDualFundedChannelResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
