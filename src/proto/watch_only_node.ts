// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: watch_only_node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Channel, Network, Payment } from "./models";

export const protobufPackage = "hydra_app";

export interface GetNodeIdRequest {
  network?: Network | undefined;
}

export interface GetNodeIdResponse {
  nodeId: string;
}

export interface GetChannelsRequest {
  network?: Network | undefined;
}

export interface GetChannelsResponse {
  channels: Channel[];
}

export interface GetChannelsWithCounterpartyRequest {
  network?: Network | undefined;
  counterpartyPubkey: string;
}

export interface GetChannelsWithCounterpartyResponse {
  channels: Channel[];
}

export interface GetChannelRequest {
  network?: Network | undefined;
  channelId: string;
}

export interface GetChannelResponse {
  channel?: Channel | undefined;
}

export interface GetPaymentsRequest {
  network?: Network | undefined;
}

export interface GetPaymentsResponse {
  payments: Payment[];
}

export interface GetPaymentRequest {
  network?: Network | undefined;
  paymentId: string;
}

export interface GetPaymentResponse {
  payment?: Payment | undefined;
}

function createBaseGetNodeIdRequest(): GetNodeIdRequest {
  return { network: undefined };
}

export const GetNodeIdRequest: MessageFns<GetNodeIdRequest> = {
  encode(message: GetNodeIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeIdRequest {
    return { network: isSet(object.network) ? Network.fromJSON(object.network) : undefined };
  },

  toJSON(message: GetNodeIdRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeIdRequest>, I>>(base?: I): GetNodeIdRequest {
    return GetNodeIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeIdRequest>, I>>(object: I): GetNodeIdRequest {
    const message = createBaseGetNodeIdRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    return message;
  },
};

function createBaseGetNodeIdResponse(): GetNodeIdResponse {
  return { nodeId: "" };
}

export const GetNodeIdResponse: MessageFns<GetNodeIdResponse> = {
  encode(message: GetNodeIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeIdResponse {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: GetNodeIdResponse): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeIdResponse>, I>>(base?: I): GetNodeIdResponse {
    return GetNodeIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeIdResponse>, I>>(object: I): GetNodeIdResponse {
    const message = createBaseGetNodeIdResponse();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseGetChannelsRequest(): GetChannelsRequest {
  return { network: undefined };
}

export const GetChannelsRequest: MessageFns<GetChannelsRequest> = {
  encode(message: GetChannelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelsRequest {
    return { network: isSet(object.network) ? Network.fromJSON(object.network) : undefined };
  },

  toJSON(message: GetChannelsRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelsRequest>, I>>(base?: I): GetChannelsRequest {
    return GetChannelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelsRequest>, I>>(object: I): GetChannelsRequest {
    const message = createBaseGetChannelsRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    return message;
  },
};

function createBaseGetChannelsResponse(): GetChannelsResponse {
  return { channels: [] };
}

export const GetChannelsResponse: MessageFns<GetChannelsResponse> = {
  encode(message: GetChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channels) {
      Channel.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channels.push(Channel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelsResponse {
    return {
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e: any) => Channel.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetChannelsResponse): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => Channel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelsResponse>, I>>(base?: I): GetChannelsResponse {
    return GetChannelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelsResponse>, I>>(object: I): GetChannelsResponse {
    const message = createBaseGetChannelsResponse();
    message.channels = object.channels?.map((e) => Channel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChannelsWithCounterpartyRequest(): GetChannelsWithCounterpartyRequest {
  return { network: undefined, counterpartyPubkey: "" };
}

export const GetChannelsWithCounterpartyRequest: MessageFns<GetChannelsWithCounterpartyRequest> = {
  encode(message: GetChannelsWithCounterpartyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.counterpartyPubkey !== "") {
      writer.uint32(18).string(message.counterpartyPubkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelsWithCounterpartyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelsWithCounterpartyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterpartyPubkey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelsWithCounterpartyRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      counterpartyPubkey: isSet(object.counterpartyPubkey) ? globalThis.String(object.counterpartyPubkey) : "",
    };
  },

  toJSON(message: GetChannelsWithCounterpartyRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.counterpartyPubkey !== "") {
      obj.counterpartyPubkey = message.counterpartyPubkey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelsWithCounterpartyRequest>, I>>(
    base?: I,
  ): GetChannelsWithCounterpartyRequest {
    return GetChannelsWithCounterpartyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelsWithCounterpartyRequest>, I>>(
    object: I,
  ): GetChannelsWithCounterpartyRequest {
    const message = createBaseGetChannelsWithCounterpartyRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.counterpartyPubkey = object.counterpartyPubkey ?? "";
    return message;
  },
};

function createBaseGetChannelsWithCounterpartyResponse(): GetChannelsWithCounterpartyResponse {
  return { channels: [] };
}

export const GetChannelsWithCounterpartyResponse: MessageFns<GetChannelsWithCounterpartyResponse> = {
  encode(message: GetChannelsWithCounterpartyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channels) {
      Channel.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelsWithCounterpartyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelsWithCounterpartyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channels.push(Channel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelsWithCounterpartyResponse {
    return {
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e: any) => Channel.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetChannelsWithCounterpartyResponse): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => Channel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelsWithCounterpartyResponse>, I>>(
    base?: I,
  ): GetChannelsWithCounterpartyResponse {
    return GetChannelsWithCounterpartyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelsWithCounterpartyResponse>, I>>(
    object: I,
  ): GetChannelsWithCounterpartyResponse {
    const message = createBaseGetChannelsWithCounterpartyResponse();
    message.channels = object.channels?.map((e) => Channel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChannelRequest(): GetChannelRequest {
  return { network: undefined, channelId: "" };
}

export const GetChannelRequest: MessageFns<GetChannelRequest> = {
  encode(message: GetChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
    };
  },

  toJSON(message: GetChannelRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelRequest>, I>>(base?: I): GetChannelRequest {
    return GetChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelRequest>, I>>(object: I): GetChannelRequest {
    const message = createBaseGetChannelRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseGetChannelResponse(): GetChannelResponse {
  return { channel: undefined };
}

export const GetChannelResponse: MessageFns<GetChannelResponse> = {
  encode(message: GetChannelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelResponse {
    return { channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined };
  },

  toJSON(message: GetChannelResponse): unknown {
    const obj: any = {};
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChannelResponse>, I>>(base?: I): GetChannelResponse {
    return GetChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChannelResponse>, I>>(object: I): GetChannelResponse {
    const message = createBaseGetChannelResponse();
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? Channel.fromPartial(object.channel)
      : undefined;
    return message;
  },
};

function createBaseGetPaymentsRequest(): GetPaymentsRequest {
  return { network: undefined };
}

export const GetPaymentsRequest: MessageFns<GetPaymentsRequest> = {
  encode(message: GetPaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentsRequest {
    return { network: isSet(object.network) ? Network.fromJSON(object.network) : undefined };
  },

  toJSON(message: GetPaymentsRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentsRequest>, I>>(base?: I): GetPaymentsRequest {
    return GetPaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentsRequest>, I>>(object: I): GetPaymentsRequest {
    const message = createBaseGetPaymentsRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    return message;
  },
};

function createBaseGetPaymentsResponse(): GetPaymentsResponse {
  return { payments: [] };
}

export const GetPaymentsResponse: MessageFns<GetPaymentsResponse> = {
  encode(message: GetPaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      Payment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentsResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments) ? object.payments.map((e: any) => Payment.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetPaymentsResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => Payment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentsResponse>, I>>(base?: I): GetPaymentsResponse {
    return GetPaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentsResponse>, I>>(object: I): GetPaymentsResponse {
    const message = createBaseGetPaymentsResponse();
    message.payments = object.payments?.map((e) => Payment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPaymentRequest(): GetPaymentRequest {
  return { network: undefined, paymentId: "" };
}

export const GetPaymentRequest: MessageFns<GetPaymentRequest> = {
  encode(message: GetPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
    };
  },

  toJSON(message: GetPaymentRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentRequest>, I>>(base?: I): GetPaymentRequest {
    return GetPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentRequest>, I>>(object: I): GetPaymentRequest {
    const message = createBaseGetPaymentRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseGetPaymentResponse(): GetPaymentResponse {
  return { payment: undefined };
}

export const GetPaymentResponse: MessageFns<GetPaymentResponse> = {
  encode(message: GetPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentResponse {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: GetPaymentResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentResponse>, I>>(base?: I): GetPaymentResponse {
    return GetPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentResponse>, I>>(object: I): GetPaymentResponse {
    const message = createBaseGetPaymentResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

/**
 * Service definition for managing watch-only related operations for a node on a
 * specific network. This service provides methods for retrieving node
 * information, channels, payments, and other related data without requiring
 * access to the private keys or signing capabilities of the node.
 */
export interface WatchOnlyNodeService {
  /** Get the node ID (public key) for a specific network. */
  GetNodeId(request: GetNodeIdRequest): Promise<GetNodeIdResponse>;
  /** Get the list of channels associated with the node on a specific network. */
  GetChannels(request: GetChannelsRequest): Promise<GetChannelsResponse>;
  /**
   * Get the list of channels associated with the node and with a specific
   * counterparty on a specific network.
   */
  GetChannelsWithCounterparty(
    request: GetChannelsWithCounterpartyRequest,
  ): Promise<GetChannelsWithCounterpartyResponse>;
  /** Get the details of a specific channel by its ID for a specific network. */
  GetChannel(request: GetChannelRequest): Promise<GetChannelResponse>;
  /**
   * Get the list of offchain payments associated with the node on a specific
   * network.
   */
  GetPayments(request: GetPaymentsRequest): Promise<GetPaymentsResponse>;
  /**
   * Get the details of a specific offchain payment by its ID for a specific
   * network.
   */
  GetPayment(request: GetPaymentRequest): Promise<GetPaymentResponse>;
}

export const WatchOnlyNodeServiceServiceName = "hydra_app.WatchOnlyNodeService";
export class WatchOnlyNodeServiceClientImpl implements WatchOnlyNodeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WatchOnlyNodeServiceServiceName;
    this.rpc = rpc;
    this.GetNodeId = this.GetNodeId.bind(this);
    this.GetChannels = this.GetChannels.bind(this);
    this.GetChannelsWithCounterparty = this.GetChannelsWithCounterparty.bind(this);
    this.GetChannel = this.GetChannel.bind(this);
    this.GetPayments = this.GetPayments.bind(this);
    this.GetPayment = this.GetPayment.bind(this);
  }
  GetNodeId(request: GetNodeIdRequest): Promise<GetNodeIdResponse> {
    const data = GetNodeIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNodeId", data);
    return promise.then((data) => GetNodeIdResponse.decode(new BinaryReader(data)));
  }

  GetChannels(request: GetChannelsRequest): Promise<GetChannelsResponse> {
    const data = GetChannelsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChannels", data);
    return promise.then((data) => GetChannelsResponse.decode(new BinaryReader(data)));
  }

  GetChannelsWithCounterparty(
    request: GetChannelsWithCounterpartyRequest,
  ): Promise<GetChannelsWithCounterpartyResponse> {
    const data = GetChannelsWithCounterpartyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChannelsWithCounterparty", data);
    return promise.then((data) => GetChannelsWithCounterpartyResponse.decode(new BinaryReader(data)));
  }

  GetChannel(request: GetChannelRequest): Promise<GetChannelResponse> {
    const data = GetChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChannel", data);
    return promise.then((data) => GetChannelResponse.decode(new BinaryReader(data)));
  }

  GetPayments(request: GetPaymentsRequest): Promise<GetPaymentsResponse> {
    const data = GetPaymentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPayments", data);
    return promise.then((data) => GetPaymentsResponse.decode(new BinaryReader(data)));
  }

  GetPayment(request: GetPaymentRequest): Promise<GetPaymentResponse> {
    const data = GetPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPayment", data);
    return promise.then((data) => GetPaymentResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
