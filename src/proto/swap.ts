// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: swap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Timestamp } from "./google/protobuf/timestamp";
import { DecimalString, FeeRate, OrderbookCurrency, OrderMatch, SwapAmount } from "./models";

export const protobufPackage = "hydra_app";

export enum FeePaymentCurrency {
  /** SENDING - The fee is paid with the sending asset of the simple swap. */
  SENDING = 0,
  /** RECEIVING - The fee is paid with the receiving asset of the simple swap. */
  RECEIVING = 1,
  /**
   * NATIVE - The fee is paid with the native asset of the involved network, that is not
   * the sending or receiving asset of the simple swap.
   */
  NATIVE = 2,
  UNRECOGNIZED = -1,
}

export function feePaymentCurrencyFromJSON(object: any): FeePaymentCurrency {
  switch (object) {
    case 0:
    case "SENDING":
      return FeePaymentCurrency.SENDING;
    case 1:
    case "RECEIVING":
      return FeePaymentCurrency.RECEIVING;
    case 2:
    case "NATIVE":
      return FeePaymentCurrency.NATIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeePaymentCurrency.UNRECOGNIZED;
  }
}

export function feePaymentCurrencyToJSON(object: FeePaymentCurrency): string {
  switch (object) {
    case FeePaymentCurrency.SENDING:
      return "SENDING";
    case FeePaymentCurrency.RECEIVING:
      return "RECEIVING";
    case FeePaymentCurrency.NATIVE:
      return "NATIVE";
    case FeePaymentCurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EstimateSwapRequest {
  sendingCurrency?: OrderbookCurrency | undefined;
  receivingCurrency?: OrderbookCurrency | undefined;
  amount?: SwapAmount | undefined;
}

export interface EstimateSwapResponse {
  orderMatch?: OrderMatch | undefined;
}

export interface SwapRequest {
  sendingCurrency?: OrderbookCurrency | undefined;
  receivingCurrency?: OrderbookCurrency | undefined;
  amount?: SwapAmount | undefined;
}

export interface SwapResponse {
  orderId: string;
}

export interface EstimateSimpleSwapRequest {
  sendingCurrency?: OrderbookCurrency | undefined;
  receivingCurrency?: OrderbookCurrency | undefined;
  amount?:
    | SwapAmount
    | undefined;
  /**
   * The maximum tolerance for the price change in the orderbook when the swap
   * is performed. This is used to make sure that the swap is performed at a
   * price that is not too far from the price intended by the user at the
   * beginning of the operation. The price change tolerance is expressed as
   * (max_tolerated_price - intended_price) / intended_price. This applies to
   * both buys and sells, thus it's an absolute value.
   */
  priceChangeTolerance?:
    | DecimalString
    | undefined;
  /**
   * Whether to withdraw back onchain the sent funds at the end of the swap
   * operation.
   */
  withdrawSendingFunds: boolean;
  /**
   * Whether to withdraw back onchain the received funds at the end of the swap
   * operation.
   */
  withdrawReceivingFunds: boolean;
}

export interface SendingChannelDeposit {
  amount?: DecimalString | undefined;
  unspendableReserve?: DecimalString | undefined;
  fee?: DecimalString | undefined;
  feePaymentCurrency: FeePaymentCurrency;
  counterparty: string;
  /** Channel id of the channel to deposit to. None if opening a new channel */
  depositChannelId?: string | undefined;
}

export interface ReceivingChannelRental {
  amount?: DecimalString | undefined;
  unspendableReserve?: DecimalString | undefined;
  rentalFee?: DecimalString | undefined;
  rentalTxFeeRate?:
    | FeeRate
    | undefined;
  /** Whether the rental fee is paid with the sending asset of the simple swap. */
  payWithSending: boolean;
}

export interface DualFundDeposit {
  selfAmount?: DecimalString | undefined;
  counterpartyAmount?: DecimalString | undefined;
  unspendableSelfReserve?: DecimalString | undefined;
  unspendableCounterpartyReserve?: DecimalString | undefined;
  fee?: DecimalString | undefined;
  feePaymentCurrency: FeePaymentCurrency;
  isOpening: boolean;
}

export interface WithdrawalFee {
  /** The fee amount. */
  fee?:
    | DecimalString
    | undefined;
  /** The fee payment currency. */
  feePaymentCurrency: FeePaymentCurrency;
}

export interface SimpleSwapEstimate {
  instant?: SimpleSwapEstimate_Instant | undefined;
  deferred?: SimpleSwapEstimate_Deferred | undefined;
  dualFundDeferred?: SimpleSwapEstimate_DualFundDeferred | undefined;
  notEnoughBalance?: SimpleSwapEstimate_NotEnoughBalance | undefined;
  feesHigherThanAmount?: SimpleSwapEstimate_FeesHigherThanAmount | undefined;
  rentalTooBig?: SimpleSwapEstimate_RentalTooBig | undefined;
  noLiquidity?: SimpleSwapEstimate_NoLiquidity | undefined;
}

/**
 * There are enough sending and receiving funds in the channels, thus the swap
 * order will be performed immediately
 */
export interface SimpleSwapEstimate_Instant {
  orderMatch?: OrderMatch | undefined;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

/**
 * There are not enough sending and/or receiving funds in the channels, thus
 * the swap order will be performed after setting up the channels.
 * This can be done by either depositing funds in the channels or renting a
 * channel for the receiving asset.
 */
export interface SimpleSwapEstimate_Deferred {
  orderMatch?: OrderMatch | undefined;
  sendingChannelDeposit?: SendingChannelDeposit | undefined;
  receivingChannelRental?: ReceivingChannelRental | undefined;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

/**
 * There are not enough sending and/or receiving funds in the channels, thus
 * the swap order will be performed after setting up the channels.
 * This can be done by dual-funding both sending and receiving funds in a
 * channel.
 */
export interface SimpleSwapEstimate_DualFundDeferred {
  orderMatch?: OrderMatch | undefined;
  dualFundDeposit?: DualFundDeposit | undefined;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

/**
 * The user does not have enough onchain balance for the simple swap to be
 * performed, as the amount needed to set up the channels is greater than
 * the onchain balance available.
 */
export interface SimpleSwapEstimate_NotEnoughBalance {
  neededOnchainSending?: DecimalString | undefined;
}

/**
 * The fees that would be paid to set up the channels are higher than the
 * amount to be swapped, thus the swap cannot be performed.
 */
export interface SimpleSwapEstimate_FeesHigherThanAmount {
  /** The fees in the sending currency that would be paid for the simple swap. */
  sendingFee?:
    | DecimalString
    | undefined;
  /**
   * The fees in the receiving currency that would be paid for the simple
   * swap.
   */
  receivingFee?: DecimalString | undefined;
}

/**
 * The swap order cannot be performed because the rental amount needed to
 * set up the channels is greater than the available liquidity or the max
 * rental capacity. of the rental liquidity provider.
 */
export interface SimpleSwapEstimate_RentalTooBig {
  neededRental?: DecimalString | undefined;
  availableRentalLiquidity?: DecimalString | undefined;
  maxRentalCapacity?: DecimalString | undefined;
}

/**
 * The swap order cannot be performed because there's no liquidity available
 * between the sending and receiving currencies in the orderbook.
 */
export interface SimpleSwapEstimate_NoLiquidity {
}

export interface EstimateSimpleSwapResponse {
  estimate?: SimpleSwapEstimate | undefined;
}

export interface SimpleSwapOutput {
  simpleSwapId: string;
  instant?: SimpleSwapOutput_Instant | undefined;
  deferred?: SimpleSwapOutput_Deferred | undefined;
  dualFundDeferred?: SimpleSwapOutput_DualFundDeferred | undefined;
}

/** The swap order has been performed immediately. */
export interface SimpleSwapOutput_Instant {
  orderId: string;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

/**
 * The swap order will be performed after setting up the channels by either
 * depositing funds in the channels or renting a channel for the receiving
 * asset.
 */
export interface SimpleSwapOutput_Deferred {
  sendingChannelDeposit?: SendingChannelDeposit | undefined;
  receivingChannelRental?: ReceivingChannelRental | undefined;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

/**
 * The swap order will be performed after setting up the channels by
 * dual-funding both sending and receiving funds in a channel.
 */
export interface SimpleSwapOutput_DualFundDeferred {
  dualFundDeposit?: DualFundDeposit | undefined;
  sendingWithdrawalFee?: WithdrawalFee | undefined;
  receivingWithdrawalFee?: WithdrawalFee | undefined;
}

export interface SimpleSwapRequest {
  sendingCurrency?: OrderbookCurrency | undefined;
  receivingCurrency?: OrderbookCurrency | undefined;
  amount?:
    | SwapAmount
    | undefined;
  /**
   * The maximum tolerance for the price change in the orderbook when the swap
   * is performed. This is used to make sure that the swap is performed at a
   * price that is not too far from the price intended by the user at the
   * beginning of the operation. The price change tolerance is expressed as
   * (max_tolerated_price - intended_price) / intended_price. This applies to
   * both buys and sells, thus it's an absolute value.
   */
  priceChangeTolerance?:
    | DecimalString
    | undefined;
  /**
   * Whether to withdraw back onchain the sent funds at the end of the swap
   * operation.
   */
  withdrawSendingFunds: boolean;
  /**
   * Whether to withdraw back onchain the received funds at the end of the swap
   * operation.
   */
  withdrawReceivingFunds: boolean;
}

export interface SimpleSwapResponse {
  output?: SimpleSwapOutput | undefined;
}

export interface SimpleSwapUpdate {
  timestamp?: Date | undefined;
  simpleSwapId: string;
  fundingSendingChannel?: SimpleSwapUpdate_FundingSendingChannel | undefined;
  rentingReceivingChannel?: SimpleSwapUpdate_RentingReceivingChannel | undefined;
  dualFundingChannel?: SimpleSwapUpdate_DualFundingChannel | undefined;
  sendingChannelReady?: SimpleSwapUpdate_SendingChannelReady | undefined;
  receivingChannelReady?: SimpleSwapUpdate_ReceivingChannelReady | undefined;
  dualFundChannelReady?: SimpleSwapUpdate_DualFundChannelReady | undefined;
  waitingForBalances?: SimpleSwapUpdate_WaitingForBalances | undefined;
  balancesReady?: SimpleSwapUpdate_BalancesReady | undefined;
  orderCreated?: SimpleSwapUpdate_OrderCreated | undefined;
  orderCompleted?: SimpleSwapUpdate_OrderCompleted | undefined;
  withdrawingSendingFunds?: SimpleSwapUpdate_WithdrawingSendingFunds | undefined;
  withdrawingReceivingFunds?: SimpleSwapUpdate_WithdrawingReceivingFunds | undefined;
  withdrawingDualFundedFunds?: SimpleSwapUpdate_WithdrawingDualFundedFunds | undefined;
  sendingFundsWithdrawn?: SimpleSwapUpdate_SendingFundsWithdrawn | undefined;
  receivingFundsWithdrawn?: SimpleSwapUpdate_ReceivingFundsWithdrawn | undefined;
  dualFundedFundsWithdrawn?: SimpleSwapUpdate_DualFundedFundsWithdrawn | undefined;
  simpleSwapCompleted?: SimpleSwapUpdate_SimpleSwapCompleted | undefined;
  simpleSwapError?: SimpleSwapUpdate_SimpleSwapError | undefined;
}

/**
 * The sending channel is being funded, either by opening a new channel or
 * depositing in an existing one.
 */
export interface SimpleSwapUpdate_FundingSendingChannel {
  txid: string;
  channelId: string;
  amount?: DecimalString | undefined;
  isOpening: boolean;
}

/** The receiving channel is being rented. */
export interface SimpleSwapUpdate_RentingReceivingChannel {
  txid: string;
  channelId: string;
  amount?: DecimalString | undefined;
}

/** The channels are being dual-funded. */
export interface SimpleSwapUpdate_DualFundingChannel {
  txid: string;
  channelId: string;
  selfAmount?: DecimalString | undefined;
  counterpartyAmount?: DecimalString | undefined;
  isOpening: boolean;
}

/** The sending channel is ready for the swap. */
export interface SimpleSwapUpdate_SendingChannelReady {
  channelId: string;
}

/** The receiving channel is ready for the swap. */
export interface SimpleSwapUpdate_ReceivingChannelReady {
  channelId: string;
}

/** The dual-funded channel is ready for the swap. */
export interface SimpleSwapUpdate_DualFundChannelReady {
  channelId: string;
}

/** Waiting for the balances to be ready for the swap. */
export interface SimpleSwapUpdate_WaitingForBalances {
  neededSending?: DecimalString | undefined;
  neededReceiving?: DecimalString | undefined;
}

/** The balances are ready for the swap. */
export interface SimpleSwapUpdate_BalancesReady {
}

/** The swap order has been created. */
export interface SimpleSwapUpdate_OrderCreated {
  orderId: string;
}

/** The swap order has been completed. */
export interface SimpleSwapUpdate_OrderCompleted {
  orderId: string;
  sentAmount?: DecimalString | undefined;
  receivedAmount?: DecimalString | undefined;
}

/** The sending funds are being withdrawn. */
export interface SimpleSwapUpdate_WithdrawingSendingFunds {
  txids: string[];
  selfAmount?: DecimalString | undefined;
  counterpartyAmount?: DecimalString | undefined;
}

/** The receiving funds are being withdrawn. */
export interface SimpleSwapUpdate_WithdrawingReceivingFunds {
  txids: string[];
  selfAmount?: DecimalString | undefined;
  counterpartyAmount?: DecimalString | undefined;
}

/** The dual-funded funds are being withdrawn. */
export interface SimpleSwapUpdate_WithdrawingDualFundedFunds {
  txids: string[];
  sendingSelfAmount?: DecimalString | undefined;
  sendingCounterpartyAmount?: DecimalString | undefined;
  receivingSelfAmount?: DecimalString | undefined;
  receivingCounterpartyAmount?: DecimalString | undefined;
}

/** The sending funds have been withdrawn. */
export interface SimpleSwapUpdate_SendingFundsWithdrawn {
}

/** The receiving funds have been withdrawn. */
export interface SimpleSwapUpdate_ReceivingFundsWithdrawn {
}

/** The dual-funded funds have been withdrawn. */
export interface SimpleSwapUpdate_DualFundedFundsWithdrawn {
}

/** The simple swap has been completed. */
export interface SimpleSwapUpdate_SimpleSwapCompleted {
}

/** An error occurred during the simple swap. */
export interface SimpleSwapUpdate_SimpleSwapError {
  error: string;
}

export interface SubscribeSimpleSwapsRequest {
}

function createBaseEstimateSwapRequest(): EstimateSwapRequest {
  return { sendingCurrency: undefined, receivingCurrency: undefined, amount: undefined };
}

export const EstimateSwapRequest: MessageFns<EstimateSwapRequest> = {
  encode(message: EstimateSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.amount !== undefined) {
      SwapAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSwapRequest {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      amount: isSet(object.amount) ? SwapAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: EstimateSwapRequest): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.amount !== undefined) {
      obj.amount = SwapAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSwapRequest>, I>>(base?: I): EstimateSwapRequest {
    return EstimateSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSwapRequest>, I>>(object: I): EstimateSwapRequest {
    const message = createBaseEstimateSwapRequest();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SwapAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseEstimateSwapResponse(): EstimateSwapResponse {
  return { orderMatch: undefined };
}

export const EstimateSwapResponse: MessageFns<EstimateSwapResponse> = {
  encode(message: EstimateSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderMatch !== undefined) {
      OrderMatch.encode(message.orderMatch, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderMatch = OrderMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSwapResponse {
    return { orderMatch: isSet(object.orderMatch) ? OrderMatch.fromJSON(object.orderMatch) : undefined };
  },

  toJSON(message: EstimateSwapResponse): unknown {
    const obj: any = {};
    if (message.orderMatch !== undefined) {
      obj.orderMatch = OrderMatch.toJSON(message.orderMatch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSwapResponse>, I>>(base?: I): EstimateSwapResponse {
    return EstimateSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSwapResponse>, I>>(object: I): EstimateSwapResponse {
    const message = createBaseEstimateSwapResponse();
    message.orderMatch = (object.orderMatch !== undefined && object.orderMatch !== null)
      ? OrderMatch.fromPartial(object.orderMatch)
      : undefined;
    return message;
  },
};

function createBaseSwapRequest(): SwapRequest {
  return { sendingCurrency: undefined, receivingCurrency: undefined, amount: undefined };
}

export const SwapRequest: MessageFns<SwapRequest> = {
  encode(message: SwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.amount !== undefined) {
      SwapAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapRequest {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      amount: isSet(object.amount) ? SwapAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: SwapRequest): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.amount !== undefined) {
      obj.amount = SwapAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapRequest>, I>>(base?: I): SwapRequest {
    return SwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapRequest>, I>>(object: I): SwapRequest {
    const message = createBaseSwapRequest();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SwapAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseSwapResponse(): SwapResponse {
  return { orderId: "" };
}

export const SwapResponse: MessageFns<SwapResponse> = {
  encode(message: SwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapResponse {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: SwapResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapResponse>, I>>(base?: I): SwapResponse {
    return SwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapResponse>, I>>(object: I): SwapResponse {
    const message = createBaseSwapResponse();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseEstimateSimpleSwapRequest(): EstimateSimpleSwapRequest {
  return {
    sendingCurrency: undefined,
    receivingCurrency: undefined,
    amount: undefined,
    priceChangeTolerance: undefined,
    withdrawSendingFunds: false,
    withdrawReceivingFunds: false,
  };
}

export const EstimateSimpleSwapRequest: MessageFns<EstimateSimpleSwapRequest> = {
  encode(message: EstimateSimpleSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.amount !== undefined) {
      SwapAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.priceChangeTolerance !== undefined) {
      DecimalString.encode(message.priceChangeTolerance, writer.uint32(34).fork()).join();
    }
    if (message.withdrawSendingFunds !== false) {
      writer.uint32(40).bool(message.withdrawSendingFunds);
    }
    if (message.withdrawReceivingFunds !== false) {
      writer.uint32(48).bool(message.withdrawReceivingFunds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSimpleSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSimpleSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.priceChangeTolerance = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawSendingFunds = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.withdrawReceivingFunds = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSimpleSwapRequest {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      amount: isSet(object.amount) ? SwapAmount.fromJSON(object.amount) : undefined,
      priceChangeTolerance: isSet(object.priceChangeTolerance)
        ? DecimalString.fromJSON(object.priceChangeTolerance)
        : undefined,
      withdrawSendingFunds: isSet(object.withdrawSendingFunds)
        ? globalThis.Boolean(object.withdrawSendingFunds)
        : false,
      withdrawReceivingFunds: isSet(object.withdrawReceivingFunds)
        ? globalThis.Boolean(object.withdrawReceivingFunds)
        : false,
    };
  },

  toJSON(message: EstimateSimpleSwapRequest): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.amount !== undefined) {
      obj.amount = SwapAmount.toJSON(message.amount);
    }
    if (message.priceChangeTolerance !== undefined) {
      obj.priceChangeTolerance = DecimalString.toJSON(message.priceChangeTolerance);
    }
    if (message.withdrawSendingFunds !== false) {
      obj.withdrawSendingFunds = message.withdrawSendingFunds;
    }
    if (message.withdrawReceivingFunds !== false) {
      obj.withdrawReceivingFunds = message.withdrawReceivingFunds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSimpleSwapRequest>, I>>(base?: I): EstimateSimpleSwapRequest {
    return EstimateSimpleSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSimpleSwapRequest>, I>>(object: I): EstimateSimpleSwapRequest {
    const message = createBaseEstimateSimpleSwapRequest();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SwapAmount.fromPartial(object.amount)
      : undefined;
    message.priceChangeTolerance = (object.priceChangeTolerance !== undefined && object.priceChangeTolerance !== null)
      ? DecimalString.fromPartial(object.priceChangeTolerance)
      : undefined;
    message.withdrawSendingFunds = object.withdrawSendingFunds ?? false;
    message.withdrawReceivingFunds = object.withdrawReceivingFunds ?? false;
    return message;
  },
};

function createBaseSendingChannelDeposit(): SendingChannelDeposit {
  return {
    amount: undefined,
    unspendableReserve: undefined,
    fee: undefined,
    feePaymentCurrency: 0,
    counterparty: "",
    depositChannelId: undefined,
  };
}

export const SendingChannelDeposit: MessageFns<SendingChannelDeposit> = {
  encode(message: SendingChannelDeposit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.unspendableReserve !== undefined) {
      DecimalString.encode(message.unspendableReserve, writer.uint32(18).fork()).join();
    }
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(26).fork()).join();
    }
    if (message.feePaymentCurrency !== 0) {
      writer.uint32(32).int32(message.feePaymentCurrency);
    }
    if (message.counterparty !== "") {
      writer.uint32(42).string(message.counterparty);
    }
    if (message.depositChannelId !== undefined) {
      writer.uint32(50).string(message.depositChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendingChannelDeposit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendingChannelDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unspendableReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.feePaymentCurrency = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.counterparty = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.depositChannelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendingChannelDeposit {
    return {
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      unspendableReserve: isSet(object.unspendableReserve)
        ? DecimalString.fromJSON(object.unspendableReserve)
        : undefined,
      fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined,
      feePaymentCurrency: isSet(object.feePaymentCurrency) ? feePaymentCurrencyFromJSON(object.feePaymentCurrency) : 0,
      counterparty: isSet(object.counterparty) ? globalThis.String(object.counterparty) : "",
      depositChannelId: isSet(object.depositChannelId) ? globalThis.String(object.depositChannelId) : undefined,
    };
  },

  toJSON(message: SendingChannelDeposit): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.unspendableReserve !== undefined) {
      obj.unspendableReserve = DecimalString.toJSON(message.unspendableReserve);
    }
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    if (message.feePaymentCurrency !== 0) {
      obj.feePaymentCurrency = feePaymentCurrencyToJSON(message.feePaymentCurrency);
    }
    if (message.counterparty !== "") {
      obj.counterparty = message.counterparty;
    }
    if (message.depositChannelId !== undefined) {
      obj.depositChannelId = message.depositChannelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendingChannelDeposit>, I>>(base?: I): SendingChannelDeposit {
    return SendingChannelDeposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendingChannelDeposit>, I>>(object: I): SendingChannelDeposit {
    const message = createBaseSendingChannelDeposit();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.unspendableReserve = (object.unspendableReserve !== undefined && object.unspendableReserve !== null)
      ? DecimalString.fromPartial(object.unspendableReserve)
      : undefined;
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    message.feePaymentCurrency = object.feePaymentCurrency ?? 0;
    message.counterparty = object.counterparty ?? "";
    message.depositChannelId = object.depositChannelId ?? undefined;
    return message;
  },
};

function createBaseReceivingChannelRental(): ReceivingChannelRental {
  return {
    amount: undefined,
    unspendableReserve: undefined,
    rentalFee: undefined,
    rentalTxFeeRate: undefined,
    payWithSending: false,
  };
}

export const ReceivingChannelRental: MessageFns<ReceivingChannelRental> = {
  encode(message: ReceivingChannelRental, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.unspendableReserve !== undefined) {
      DecimalString.encode(message.unspendableReserve, writer.uint32(18).fork()).join();
    }
    if (message.rentalFee !== undefined) {
      DecimalString.encode(message.rentalFee, writer.uint32(26).fork()).join();
    }
    if (message.rentalTxFeeRate !== undefined) {
      FeeRate.encode(message.rentalTxFeeRate, writer.uint32(34).fork()).join();
    }
    if (message.payWithSending !== false) {
      writer.uint32(40).bool(message.payWithSending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivingChannelRental {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivingChannelRental();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unspendableReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rentalFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rentalTxFeeRate = FeeRate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.payWithSending = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivingChannelRental {
    return {
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      unspendableReserve: isSet(object.unspendableReserve)
        ? DecimalString.fromJSON(object.unspendableReserve)
        : undefined,
      rentalFee: isSet(object.rentalFee) ? DecimalString.fromJSON(object.rentalFee) : undefined,
      rentalTxFeeRate: isSet(object.rentalTxFeeRate) ? FeeRate.fromJSON(object.rentalTxFeeRate) : undefined,
      payWithSending: isSet(object.payWithSending) ? globalThis.Boolean(object.payWithSending) : false,
    };
  },

  toJSON(message: ReceivingChannelRental): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.unspendableReserve !== undefined) {
      obj.unspendableReserve = DecimalString.toJSON(message.unspendableReserve);
    }
    if (message.rentalFee !== undefined) {
      obj.rentalFee = DecimalString.toJSON(message.rentalFee);
    }
    if (message.rentalTxFeeRate !== undefined) {
      obj.rentalTxFeeRate = FeeRate.toJSON(message.rentalTxFeeRate);
    }
    if (message.payWithSending !== false) {
      obj.payWithSending = message.payWithSending;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceivingChannelRental>, I>>(base?: I): ReceivingChannelRental {
    return ReceivingChannelRental.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceivingChannelRental>, I>>(object: I): ReceivingChannelRental {
    const message = createBaseReceivingChannelRental();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.unspendableReserve = (object.unspendableReserve !== undefined && object.unspendableReserve !== null)
      ? DecimalString.fromPartial(object.unspendableReserve)
      : undefined;
    message.rentalFee = (object.rentalFee !== undefined && object.rentalFee !== null)
      ? DecimalString.fromPartial(object.rentalFee)
      : undefined;
    message.rentalTxFeeRate = (object.rentalTxFeeRate !== undefined && object.rentalTxFeeRate !== null)
      ? FeeRate.fromPartial(object.rentalTxFeeRate)
      : undefined;
    message.payWithSending = object.payWithSending ?? false;
    return message;
  },
};

function createBaseDualFundDeposit(): DualFundDeposit {
  return {
    selfAmount: undefined,
    counterpartyAmount: undefined,
    unspendableSelfReserve: undefined,
    unspendableCounterpartyReserve: undefined,
    fee: undefined,
    feePaymentCurrency: 0,
    isOpening: false,
  };
}

export const DualFundDeposit: MessageFns<DualFundDeposit> = {
  encode(message: DualFundDeposit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.selfAmount !== undefined) {
      DecimalString.encode(message.selfAmount, writer.uint32(10).fork()).join();
    }
    if (message.counterpartyAmount !== undefined) {
      DecimalString.encode(message.counterpartyAmount, writer.uint32(18).fork()).join();
    }
    if (message.unspendableSelfReserve !== undefined) {
      DecimalString.encode(message.unspendableSelfReserve, writer.uint32(26).fork()).join();
    }
    if (message.unspendableCounterpartyReserve !== undefined) {
      DecimalString.encode(message.unspendableCounterpartyReserve, writer.uint32(34).fork()).join();
    }
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(42).fork()).join();
    }
    if (message.feePaymentCurrency !== 0) {
      writer.uint32(48).int32(message.feePaymentCurrency);
    }
    if (message.isOpening !== false) {
      writer.uint32(56).bool(message.isOpening);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DualFundDeposit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDualFundDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.selfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unspendableSelfReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unspendableCounterpartyReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.feePaymentCurrency = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isOpening = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DualFundDeposit {
    return {
      selfAmount: isSet(object.selfAmount) ? DecimalString.fromJSON(object.selfAmount) : undefined,
      counterpartyAmount: isSet(object.counterpartyAmount)
        ? DecimalString.fromJSON(object.counterpartyAmount)
        : undefined,
      unspendableSelfReserve: isSet(object.unspendableSelfReserve)
        ? DecimalString.fromJSON(object.unspendableSelfReserve)
        : undefined,
      unspendableCounterpartyReserve: isSet(object.unspendableCounterpartyReserve)
        ? DecimalString.fromJSON(object.unspendableCounterpartyReserve)
        : undefined,
      fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined,
      feePaymentCurrency: isSet(object.feePaymentCurrency) ? feePaymentCurrencyFromJSON(object.feePaymentCurrency) : 0,
      isOpening: isSet(object.isOpening) ? globalThis.Boolean(object.isOpening) : false,
    };
  },

  toJSON(message: DualFundDeposit): unknown {
    const obj: any = {};
    if (message.selfAmount !== undefined) {
      obj.selfAmount = DecimalString.toJSON(message.selfAmount);
    }
    if (message.counterpartyAmount !== undefined) {
      obj.counterpartyAmount = DecimalString.toJSON(message.counterpartyAmount);
    }
    if (message.unspendableSelfReserve !== undefined) {
      obj.unspendableSelfReserve = DecimalString.toJSON(message.unspendableSelfReserve);
    }
    if (message.unspendableCounterpartyReserve !== undefined) {
      obj.unspendableCounterpartyReserve = DecimalString.toJSON(message.unspendableCounterpartyReserve);
    }
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    if (message.feePaymentCurrency !== 0) {
      obj.feePaymentCurrency = feePaymentCurrencyToJSON(message.feePaymentCurrency);
    }
    if (message.isOpening !== false) {
      obj.isOpening = message.isOpening;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DualFundDeposit>, I>>(base?: I): DualFundDeposit {
    return DualFundDeposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DualFundDeposit>, I>>(object: I): DualFundDeposit {
    const message = createBaseDualFundDeposit();
    message.selfAmount = (object.selfAmount !== undefined && object.selfAmount !== null)
      ? DecimalString.fromPartial(object.selfAmount)
      : undefined;
    message.counterpartyAmount = (object.counterpartyAmount !== undefined && object.counterpartyAmount !== null)
      ? DecimalString.fromPartial(object.counterpartyAmount)
      : undefined;
    message.unspendableSelfReserve =
      (object.unspendableSelfReserve !== undefined && object.unspendableSelfReserve !== null)
        ? DecimalString.fromPartial(object.unspendableSelfReserve)
        : undefined;
    message.unspendableCounterpartyReserve =
      (object.unspendableCounterpartyReserve !== undefined && object.unspendableCounterpartyReserve !== null)
        ? DecimalString.fromPartial(object.unspendableCounterpartyReserve)
        : undefined;
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    message.feePaymentCurrency = object.feePaymentCurrency ?? 0;
    message.isOpening = object.isOpening ?? false;
    return message;
  },
};

function createBaseWithdrawalFee(): WithdrawalFee {
  return { fee: undefined, feePaymentCurrency: 0 };
}

export const WithdrawalFee: MessageFns<WithdrawalFee> = {
  encode(message: WithdrawalFee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(10).fork()).join();
    }
    if (message.feePaymentCurrency !== 0) {
      writer.uint32(16).int32(message.feePaymentCurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawalFee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawalFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePaymentCurrency = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawalFee {
    return {
      fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined,
      feePaymentCurrency: isSet(object.feePaymentCurrency) ? feePaymentCurrencyFromJSON(object.feePaymentCurrency) : 0,
    };
  },

  toJSON(message: WithdrawalFee): unknown {
    const obj: any = {};
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    if (message.feePaymentCurrency !== 0) {
      obj.feePaymentCurrency = feePaymentCurrencyToJSON(message.feePaymentCurrency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawalFee>, I>>(base?: I): WithdrawalFee {
    return WithdrawalFee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawalFee>, I>>(object: I): WithdrawalFee {
    const message = createBaseWithdrawalFee();
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    message.feePaymentCurrency = object.feePaymentCurrency ?? 0;
    return message;
  },
};

function createBaseSimpleSwapEstimate(): SimpleSwapEstimate {
  return {
    instant: undefined,
    deferred: undefined,
    dualFundDeferred: undefined,
    notEnoughBalance: undefined,
    feesHigherThanAmount: undefined,
    rentalTooBig: undefined,
    noLiquidity: undefined,
  };
}

export const SimpleSwapEstimate: MessageFns<SimpleSwapEstimate> = {
  encode(message: SimpleSwapEstimate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instant !== undefined) {
      SimpleSwapEstimate_Instant.encode(message.instant, writer.uint32(10).fork()).join();
    }
    if (message.deferred !== undefined) {
      SimpleSwapEstimate_Deferred.encode(message.deferred, writer.uint32(18).fork()).join();
    }
    if (message.dualFundDeferred !== undefined) {
      SimpleSwapEstimate_DualFundDeferred.encode(message.dualFundDeferred, writer.uint32(26).fork()).join();
    }
    if (message.notEnoughBalance !== undefined) {
      SimpleSwapEstimate_NotEnoughBalance.encode(message.notEnoughBalance, writer.uint32(34).fork()).join();
    }
    if (message.feesHigherThanAmount !== undefined) {
      SimpleSwapEstimate_FeesHigherThanAmount.encode(message.feesHigherThanAmount, writer.uint32(42).fork()).join();
    }
    if (message.rentalTooBig !== undefined) {
      SimpleSwapEstimate_RentalTooBig.encode(message.rentalTooBig, writer.uint32(50).fork()).join();
    }
    if (message.noLiquidity !== undefined) {
      SimpleSwapEstimate_NoLiquidity.encode(message.noLiquidity, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instant = SimpleSwapEstimate_Instant.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deferred = SimpleSwapEstimate_Deferred.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dualFundDeferred = SimpleSwapEstimate_DualFundDeferred.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notEnoughBalance = SimpleSwapEstimate_NotEnoughBalance.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feesHigherThanAmount = SimpleSwapEstimate_FeesHigherThanAmount.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rentalTooBig = SimpleSwapEstimate_RentalTooBig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.noLiquidity = SimpleSwapEstimate_NoLiquidity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate {
    return {
      instant: isSet(object.instant) ? SimpleSwapEstimate_Instant.fromJSON(object.instant) : undefined,
      deferred: isSet(object.deferred) ? SimpleSwapEstimate_Deferred.fromJSON(object.deferred) : undefined,
      dualFundDeferred: isSet(object.dualFundDeferred)
        ? SimpleSwapEstimate_DualFundDeferred.fromJSON(object.dualFundDeferred)
        : undefined,
      notEnoughBalance: isSet(object.notEnoughBalance)
        ? SimpleSwapEstimate_NotEnoughBalance.fromJSON(object.notEnoughBalance)
        : undefined,
      feesHigherThanAmount: isSet(object.feesHigherThanAmount)
        ? SimpleSwapEstimate_FeesHigherThanAmount.fromJSON(object.feesHigherThanAmount)
        : undefined,
      rentalTooBig: isSet(object.rentalTooBig)
        ? SimpleSwapEstimate_RentalTooBig.fromJSON(object.rentalTooBig)
        : undefined,
      noLiquidity: isSet(object.noLiquidity) ? SimpleSwapEstimate_NoLiquidity.fromJSON(object.noLiquidity) : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate): unknown {
    const obj: any = {};
    if (message.instant !== undefined) {
      obj.instant = SimpleSwapEstimate_Instant.toJSON(message.instant);
    }
    if (message.deferred !== undefined) {
      obj.deferred = SimpleSwapEstimate_Deferred.toJSON(message.deferred);
    }
    if (message.dualFundDeferred !== undefined) {
      obj.dualFundDeferred = SimpleSwapEstimate_DualFundDeferred.toJSON(message.dualFundDeferred);
    }
    if (message.notEnoughBalance !== undefined) {
      obj.notEnoughBalance = SimpleSwapEstimate_NotEnoughBalance.toJSON(message.notEnoughBalance);
    }
    if (message.feesHigherThanAmount !== undefined) {
      obj.feesHigherThanAmount = SimpleSwapEstimate_FeesHigherThanAmount.toJSON(message.feesHigherThanAmount);
    }
    if (message.rentalTooBig !== undefined) {
      obj.rentalTooBig = SimpleSwapEstimate_RentalTooBig.toJSON(message.rentalTooBig);
    }
    if (message.noLiquidity !== undefined) {
      obj.noLiquidity = SimpleSwapEstimate_NoLiquidity.toJSON(message.noLiquidity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate>, I>>(base?: I): SimpleSwapEstimate {
    return SimpleSwapEstimate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate>, I>>(object: I): SimpleSwapEstimate {
    const message = createBaseSimpleSwapEstimate();
    message.instant = (object.instant !== undefined && object.instant !== null)
      ? SimpleSwapEstimate_Instant.fromPartial(object.instant)
      : undefined;
    message.deferred = (object.deferred !== undefined && object.deferred !== null)
      ? SimpleSwapEstimate_Deferred.fromPartial(object.deferred)
      : undefined;
    message.dualFundDeferred = (object.dualFundDeferred !== undefined && object.dualFundDeferred !== null)
      ? SimpleSwapEstimate_DualFundDeferred.fromPartial(object.dualFundDeferred)
      : undefined;
    message.notEnoughBalance = (object.notEnoughBalance !== undefined && object.notEnoughBalance !== null)
      ? SimpleSwapEstimate_NotEnoughBalance.fromPartial(object.notEnoughBalance)
      : undefined;
    message.feesHigherThanAmount = (object.feesHigherThanAmount !== undefined && object.feesHigherThanAmount !== null)
      ? SimpleSwapEstimate_FeesHigherThanAmount.fromPartial(object.feesHigherThanAmount)
      : undefined;
    message.rentalTooBig = (object.rentalTooBig !== undefined && object.rentalTooBig !== null)
      ? SimpleSwapEstimate_RentalTooBig.fromPartial(object.rentalTooBig)
      : undefined;
    message.noLiquidity = (object.noLiquidity !== undefined && object.noLiquidity !== null)
      ? SimpleSwapEstimate_NoLiquidity.fromPartial(object.noLiquidity)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_Instant(): SimpleSwapEstimate_Instant {
  return { orderMatch: undefined, sendingWithdrawalFee: undefined, receivingWithdrawalFee: undefined };
}

export const SimpleSwapEstimate_Instant: MessageFns<SimpleSwapEstimate_Instant> = {
  encode(message: SimpleSwapEstimate_Instant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderMatch !== undefined) {
      OrderMatch.encode(message.orderMatch, writer.uint32(10).fork()).join();
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(18).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_Instant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_Instant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderMatch = OrderMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_Instant {
    return {
      orderMatch: isSet(object.orderMatch) ? OrderMatch.fromJSON(object.orderMatch) : undefined,
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_Instant): unknown {
    const obj: any = {};
    if (message.orderMatch !== undefined) {
      obj.orderMatch = OrderMatch.toJSON(message.orderMatch);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_Instant>, I>>(base?: I): SimpleSwapEstimate_Instant {
    return SimpleSwapEstimate_Instant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_Instant>, I>>(object: I): SimpleSwapEstimate_Instant {
    const message = createBaseSimpleSwapEstimate_Instant();
    message.orderMatch = (object.orderMatch !== undefined && object.orderMatch !== null)
      ? OrderMatch.fromPartial(object.orderMatch)
      : undefined;
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_Deferred(): SimpleSwapEstimate_Deferred {
  return {
    orderMatch: undefined,
    sendingChannelDeposit: undefined,
    receivingChannelRental: undefined,
    sendingWithdrawalFee: undefined,
    receivingWithdrawalFee: undefined,
  };
}

export const SimpleSwapEstimate_Deferred: MessageFns<SimpleSwapEstimate_Deferred> = {
  encode(message: SimpleSwapEstimate_Deferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderMatch !== undefined) {
      OrderMatch.encode(message.orderMatch, writer.uint32(10).fork()).join();
    }
    if (message.sendingChannelDeposit !== undefined) {
      SendingChannelDeposit.encode(message.sendingChannelDeposit, writer.uint32(18).fork()).join();
    }
    if (message.receivingChannelRental !== undefined) {
      ReceivingChannelRental.encode(message.receivingChannelRental, writer.uint32(26).fork()).join();
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(34).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_Deferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_Deferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderMatch = OrderMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendingChannelDeposit = SendingChannelDeposit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receivingChannelRental = ReceivingChannelRental.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_Deferred {
    return {
      orderMatch: isSet(object.orderMatch) ? OrderMatch.fromJSON(object.orderMatch) : undefined,
      sendingChannelDeposit: isSet(object.sendingChannelDeposit)
        ? SendingChannelDeposit.fromJSON(object.sendingChannelDeposit)
        : undefined,
      receivingChannelRental: isSet(object.receivingChannelRental)
        ? ReceivingChannelRental.fromJSON(object.receivingChannelRental)
        : undefined,
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_Deferred): unknown {
    const obj: any = {};
    if (message.orderMatch !== undefined) {
      obj.orderMatch = OrderMatch.toJSON(message.orderMatch);
    }
    if (message.sendingChannelDeposit !== undefined) {
      obj.sendingChannelDeposit = SendingChannelDeposit.toJSON(message.sendingChannelDeposit);
    }
    if (message.receivingChannelRental !== undefined) {
      obj.receivingChannelRental = ReceivingChannelRental.toJSON(message.receivingChannelRental);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_Deferred>, I>>(base?: I): SimpleSwapEstimate_Deferred {
    return SimpleSwapEstimate_Deferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_Deferred>, I>>(object: I): SimpleSwapEstimate_Deferred {
    const message = createBaseSimpleSwapEstimate_Deferred();
    message.orderMatch = (object.orderMatch !== undefined && object.orderMatch !== null)
      ? OrderMatch.fromPartial(object.orderMatch)
      : undefined;
    message.sendingChannelDeposit =
      (object.sendingChannelDeposit !== undefined && object.sendingChannelDeposit !== null)
        ? SendingChannelDeposit.fromPartial(object.sendingChannelDeposit)
        : undefined;
    message.receivingChannelRental =
      (object.receivingChannelRental !== undefined && object.receivingChannelRental !== null)
        ? ReceivingChannelRental.fromPartial(object.receivingChannelRental)
        : undefined;
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_DualFundDeferred(): SimpleSwapEstimate_DualFundDeferred {
  return {
    orderMatch: undefined,
    dualFundDeposit: undefined,
    sendingWithdrawalFee: undefined,
    receivingWithdrawalFee: undefined,
  };
}

export const SimpleSwapEstimate_DualFundDeferred: MessageFns<SimpleSwapEstimate_DualFundDeferred> = {
  encode(message: SimpleSwapEstimate_DualFundDeferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderMatch !== undefined) {
      OrderMatch.encode(message.orderMatch, writer.uint32(10).fork()).join();
    }
    if (message.dualFundDeposit !== undefined) {
      DualFundDeposit.encode(message.dualFundDeposit, writer.uint32(18).fork()).join();
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(26).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_DualFundDeferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_DualFundDeferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderMatch = OrderMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dualFundDeposit = DualFundDeposit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_DualFundDeferred {
    return {
      orderMatch: isSet(object.orderMatch) ? OrderMatch.fromJSON(object.orderMatch) : undefined,
      dualFundDeposit: isSet(object.dualFundDeposit) ? DualFundDeposit.fromJSON(object.dualFundDeposit) : undefined,
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_DualFundDeferred): unknown {
    const obj: any = {};
    if (message.orderMatch !== undefined) {
      obj.orderMatch = OrderMatch.toJSON(message.orderMatch);
    }
    if (message.dualFundDeposit !== undefined) {
      obj.dualFundDeposit = DualFundDeposit.toJSON(message.dualFundDeposit);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_DualFundDeferred>, I>>(
    base?: I,
  ): SimpleSwapEstimate_DualFundDeferred {
    return SimpleSwapEstimate_DualFundDeferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_DualFundDeferred>, I>>(
    object: I,
  ): SimpleSwapEstimate_DualFundDeferred {
    const message = createBaseSimpleSwapEstimate_DualFundDeferred();
    message.orderMatch = (object.orderMatch !== undefined && object.orderMatch !== null)
      ? OrderMatch.fromPartial(object.orderMatch)
      : undefined;
    message.dualFundDeposit = (object.dualFundDeposit !== undefined && object.dualFundDeposit !== null)
      ? DualFundDeposit.fromPartial(object.dualFundDeposit)
      : undefined;
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_NotEnoughBalance(): SimpleSwapEstimate_NotEnoughBalance {
  return { neededOnchainSending: undefined };
}

export const SimpleSwapEstimate_NotEnoughBalance: MessageFns<SimpleSwapEstimate_NotEnoughBalance> = {
  encode(message: SimpleSwapEstimate_NotEnoughBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.neededOnchainSending !== undefined) {
      DecimalString.encode(message.neededOnchainSending, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_NotEnoughBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_NotEnoughBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.neededOnchainSending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_NotEnoughBalance {
    return {
      neededOnchainSending: isSet(object.neededOnchainSending)
        ? DecimalString.fromJSON(object.neededOnchainSending)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_NotEnoughBalance): unknown {
    const obj: any = {};
    if (message.neededOnchainSending !== undefined) {
      obj.neededOnchainSending = DecimalString.toJSON(message.neededOnchainSending);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_NotEnoughBalance>, I>>(
    base?: I,
  ): SimpleSwapEstimate_NotEnoughBalance {
    return SimpleSwapEstimate_NotEnoughBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_NotEnoughBalance>, I>>(
    object: I,
  ): SimpleSwapEstimate_NotEnoughBalance {
    const message = createBaseSimpleSwapEstimate_NotEnoughBalance();
    message.neededOnchainSending = (object.neededOnchainSending !== undefined && object.neededOnchainSending !== null)
      ? DecimalString.fromPartial(object.neededOnchainSending)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_FeesHigherThanAmount(): SimpleSwapEstimate_FeesHigherThanAmount {
  return { sendingFee: undefined, receivingFee: undefined };
}

export const SimpleSwapEstimate_FeesHigherThanAmount: MessageFns<SimpleSwapEstimate_FeesHigherThanAmount> = {
  encode(message: SimpleSwapEstimate_FeesHigherThanAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingFee !== undefined) {
      DecimalString.encode(message.sendingFee, writer.uint32(10).fork()).join();
    }
    if (message.receivingFee !== undefined) {
      DecimalString.encode(message.receivingFee, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_FeesHigherThanAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_FeesHigherThanAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_FeesHigherThanAmount {
    return {
      sendingFee: isSet(object.sendingFee) ? DecimalString.fromJSON(object.sendingFee) : undefined,
      receivingFee: isSet(object.receivingFee) ? DecimalString.fromJSON(object.receivingFee) : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_FeesHigherThanAmount): unknown {
    const obj: any = {};
    if (message.sendingFee !== undefined) {
      obj.sendingFee = DecimalString.toJSON(message.sendingFee);
    }
    if (message.receivingFee !== undefined) {
      obj.receivingFee = DecimalString.toJSON(message.receivingFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_FeesHigherThanAmount>, I>>(
    base?: I,
  ): SimpleSwapEstimate_FeesHigherThanAmount {
    return SimpleSwapEstimate_FeesHigherThanAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_FeesHigherThanAmount>, I>>(
    object: I,
  ): SimpleSwapEstimate_FeesHigherThanAmount {
    const message = createBaseSimpleSwapEstimate_FeesHigherThanAmount();
    message.sendingFee = (object.sendingFee !== undefined && object.sendingFee !== null)
      ? DecimalString.fromPartial(object.sendingFee)
      : undefined;
    message.receivingFee = (object.receivingFee !== undefined && object.receivingFee !== null)
      ? DecimalString.fromPartial(object.receivingFee)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_RentalTooBig(): SimpleSwapEstimate_RentalTooBig {
  return { neededRental: undefined, availableRentalLiquidity: undefined, maxRentalCapacity: undefined };
}

export const SimpleSwapEstimate_RentalTooBig: MessageFns<SimpleSwapEstimate_RentalTooBig> = {
  encode(message: SimpleSwapEstimate_RentalTooBig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.neededRental !== undefined) {
      DecimalString.encode(message.neededRental, writer.uint32(10).fork()).join();
    }
    if (message.availableRentalLiquidity !== undefined) {
      DecimalString.encode(message.availableRentalLiquidity, writer.uint32(18).fork()).join();
    }
    if (message.maxRentalCapacity !== undefined) {
      DecimalString.encode(message.maxRentalCapacity, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_RentalTooBig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_RentalTooBig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.neededRental = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableRentalLiquidity = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxRentalCapacity = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapEstimate_RentalTooBig {
    return {
      neededRental: isSet(object.neededRental) ? DecimalString.fromJSON(object.neededRental) : undefined,
      availableRentalLiquidity: isSet(object.availableRentalLiquidity)
        ? DecimalString.fromJSON(object.availableRentalLiquidity)
        : undefined,
      maxRentalCapacity: isSet(object.maxRentalCapacity) ? DecimalString.fromJSON(object.maxRentalCapacity) : undefined,
    };
  },

  toJSON(message: SimpleSwapEstimate_RentalTooBig): unknown {
    const obj: any = {};
    if (message.neededRental !== undefined) {
      obj.neededRental = DecimalString.toJSON(message.neededRental);
    }
    if (message.availableRentalLiquidity !== undefined) {
      obj.availableRentalLiquidity = DecimalString.toJSON(message.availableRentalLiquidity);
    }
    if (message.maxRentalCapacity !== undefined) {
      obj.maxRentalCapacity = DecimalString.toJSON(message.maxRentalCapacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_RentalTooBig>, I>>(base?: I): SimpleSwapEstimate_RentalTooBig {
    return SimpleSwapEstimate_RentalTooBig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_RentalTooBig>, I>>(
    object: I,
  ): SimpleSwapEstimate_RentalTooBig {
    const message = createBaseSimpleSwapEstimate_RentalTooBig();
    message.neededRental = (object.neededRental !== undefined && object.neededRental !== null)
      ? DecimalString.fromPartial(object.neededRental)
      : undefined;
    message.availableRentalLiquidity =
      (object.availableRentalLiquidity !== undefined && object.availableRentalLiquidity !== null)
        ? DecimalString.fromPartial(object.availableRentalLiquidity)
        : undefined;
    message.maxRentalCapacity = (object.maxRentalCapacity !== undefined && object.maxRentalCapacity !== null)
      ? DecimalString.fromPartial(object.maxRentalCapacity)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapEstimate_NoLiquidity(): SimpleSwapEstimate_NoLiquidity {
  return {};
}

export const SimpleSwapEstimate_NoLiquidity: MessageFns<SimpleSwapEstimate_NoLiquidity> = {
  encode(_: SimpleSwapEstimate_NoLiquidity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapEstimate_NoLiquidity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapEstimate_NoLiquidity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapEstimate_NoLiquidity {
    return {};
  },

  toJSON(_: SimpleSwapEstimate_NoLiquidity): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapEstimate_NoLiquidity>, I>>(base?: I): SimpleSwapEstimate_NoLiquidity {
    return SimpleSwapEstimate_NoLiquidity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapEstimate_NoLiquidity>, I>>(_: I): SimpleSwapEstimate_NoLiquidity {
    const message = createBaseSimpleSwapEstimate_NoLiquidity();
    return message;
  },
};

function createBaseEstimateSimpleSwapResponse(): EstimateSimpleSwapResponse {
  return { estimate: undefined };
}

export const EstimateSimpleSwapResponse: MessageFns<EstimateSimpleSwapResponse> = {
  encode(message: EstimateSimpleSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.estimate !== undefined) {
      SimpleSwapEstimate.encode(message.estimate, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateSimpleSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateSimpleSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.estimate = SimpleSwapEstimate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateSimpleSwapResponse {
    return { estimate: isSet(object.estimate) ? SimpleSwapEstimate.fromJSON(object.estimate) : undefined };
  },

  toJSON(message: EstimateSimpleSwapResponse): unknown {
    const obj: any = {};
    if (message.estimate !== undefined) {
      obj.estimate = SimpleSwapEstimate.toJSON(message.estimate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateSimpleSwapResponse>, I>>(base?: I): EstimateSimpleSwapResponse {
    return EstimateSimpleSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateSimpleSwapResponse>, I>>(object: I): EstimateSimpleSwapResponse {
    const message = createBaseEstimateSimpleSwapResponse();
    message.estimate = (object.estimate !== undefined && object.estimate !== null)
      ? SimpleSwapEstimate.fromPartial(object.estimate)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapOutput(): SimpleSwapOutput {
  return { simpleSwapId: "", instant: undefined, deferred: undefined, dualFundDeferred: undefined };
}

export const SimpleSwapOutput: MessageFns<SimpleSwapOutput> = {
  encode(message: SimpleSwapOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.simpleSwapId !== "") {
      writer.uint32(10).string(message.simpleSwapId);
    }
    if (message.instant !== undefined) {
      SimpleSwapOutput_Instant.encode(message.instant, writer.uint32(18).fork()).join();
    }
    if (message.deferred !== undefined) {
      SimpleSwapOutput_Deferred.encode(message.deferred, writer.uint32(26).fork()).join();
    }
    if (message.dualFundDeferred !== undefined) {
      SimpleSwapOutput_DualFundDeferred.encode(message.dualFundDeferred, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.simpleSwapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instant = SimpleSwapOutput_Instant.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deferred = SimpleSwapOutput_Deferred.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dualFundDeferred = SimpleSwapOutput_DualFundDeferred.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapOutput {
    return {
      simpleSwapId: isSet(object.simpleSwapId) ? globalThis.String(object.simpleSwapId) : "",
      instant: isSet(object.instant) ? SimpleSwapOutput_Instant.fromJSON(object.instant) : undefined,
      deferred: isSet(object.deferred) ? SimpleSwapOutput_Deferred.fromJSON(object.deferred) : undefined,
      dualFundDeferred: isSet(object.dualFundDeferred)
        ? SimpleSwapOutput_DualFundDeferred.fromJSON(object.dualFundDeferred)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapOutput): unknown {
    const obj: any = {};
    if (message.simpleSwapId !== "") {
      obj.simpleSwapId = message.simpleSwapId;
    }
    if (message.instant !== undefined) {
      obj.instant = SimpleSwapOutput_Instant.toJSON(message.instant);
    }
    if (message.deferred !== undefined) {
      obj.deferred = SimpleSwapOutput_Deferred.toJSON(message.deferred);
    }
    if (message.dualFundDeferred !== undefined) {
      obj.dualFundDeferred = SimpleSwapOutput_DualFundDeferred.toJSON(message.dualFundDeferred);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapOutput>, I>>(base?: I): SimpleSwapOutput {
    return SimpleSwapOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapOutput>, I>>(object: I): SimpleSwapOutput {
    const message = createBaseSimpleSwapOutput();
    message.simpleSwapId = object.simpleSwapId ?? "";
    message.instant = (object.instant !== undefined && object.instant !== null)
      ? SimpleSwapOutput_Instant.fromPartial(object.instant)
      : undefined;
    message.deferred = (object.deferred !== undefined && object.deferred !== null)
      ? SimpleSwapOutput_Deferred.fromPartial(object.deferred)
      : undefined;
    message.dualFundDeferred = (object.dualFundDeferred !== undefined && object.dualFundDeferred !== null)
      ? SimpleSwapOutput_DualFundDeferred.fromPartial(object.dualFundDeferred)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapOutput_Instant(): SimpleSwapOutput_Instant {
  return { orderId: "", sendingWithdrawalFee: undefined, receivingWithdrawalFee: undefined };
}

export const SimpleSwapOutput_Instant: MessageFns<SimpleSwapOutput_Instant> = {
  encode(message: SimpleSwapOutput_Instant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(18).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapOutput_Instant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapOutput_Instant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapOutput_Instant {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapOutput_Instant): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapOutput_Instant>, I>>(base?: I): SimpleSwapOutput_Instant {
    return SimpleSwapOutput_Instant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapOutput_Instant>, I>>(object: I): SimpleSwapOutput_Instant {
    const message = createBaseSimpleSwapOutput_Instant();
    message.orderId = object.orderId ?? "";
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapOutput_Deferred(): SimpleSwapOutput_Deferred {
  return {
    sendingChannelDeposit: undefined,
    receivingChannelRental: undefined,
    sendingWithdrawalFee: undefined,
    receivingWithdrawalFee: undefined,
  };
}

export const SimpleSwapOutput_Deferred: MessageFns<SimpleSwapOutput_Deferred> = {
  encode(message: SimpleSwapOutput_Deferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingChannelDeposit !== undefined) {
      SendingChannelDeposit.encode(message.sendingChannelDeposit, writer.uint32(10).fork()).join();
    }
    if (message.receivingChannelRental !== undefined) {
      ReceivingChannelRental.encode(message.receivingChannelRental, writer.uint32(18).fork()).join();
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(26).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapOutput_Deferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapOutput_Deferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingChannelDeposit = SendingChannelDeposit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingChannelRental = ReceivingChannelRental.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapOutput_Deferred {
    return {
      sendingChannelDeposit: isSet(object.sendingChannelDeposit)
        ? SendingChannelDeposit.fromJSON(object.sendingChannelDeposit)
        : undefined,
      receivingChannelRental: isSet(object.receivingChannelRental)
        ? ReceivingChannelRental.fromJSON(object.receivingChannelRental)
        : undefined,
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapOutput_Deferred): unknown {
    const obj: any = {};
    if (message.sendingChannelDeposit !== undefined) {
      obj.sendingChannelDeposit = SendingChannelDeposit.toJSON(message.sendingChannelDeposit);
    }
    if (message.receivingChannelRental !== undefined) {
      obj.receivingChannelRental = ReceivingChannelRental.toJSON(message.receivingChannelRental);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapOutput_Deferred>, I>>(base?: I): SimpleSwapOutput_Deferred {
    return SimpleSwapOutput_Deferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapOutput_Deferred>, I>>(object: I): SimpleSwapOutput_Deferred {
    const message = createBaseSimpleSwapOutput_Deferred();
    message.sendingChannelDeposit =
      (object.sendingChannelDeposit !== undefined && object.sendingChannelDeposit !== null)
        ? SendingChannelDeposit.fromPartial(object.sendingChannelDeposit)
        : undefined;
    message.receivingChannelRental =
      (object.receivingChannelRental !== undefined && object.receivingChannelRental !== null)
        ? ReceivingChannelRental.fromPartial(object.receivingChannelRental)
        : undefined;
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapOutput_DualFundDeferred(): SimpleSwapOutput_DualFundDeferred {
  return { dualFundDeposit: undefined, sendingWithdrawalFee: undefined, receivingWithdrawalFee: undefined };
}

export const SimpleSwapOutput_DualFundDeferred: MessageFns<SimpleSwapOutput_DualFundDeferred> = {
  encode(message: SimpleSwapOutput_DualFundDeferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dualFundDeposit !== undefined) {
      DualFundDeposit.encode(message.dualFundDeposit, writer.uint32(10).fork()).join();
    }
    if (message.sendingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.sendingWithdrawalFee, writer.uint32(18).fork()).join();
    }
    if (message.receivingWithdrawalFee !== undefined) {
      WithdrawalFee.encode(message.receivingWithdrawalFee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapOutput_DualFundDeferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapOutput_DualFundDeferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dualFundDeposit = DualFundDeposit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receivingWithdrawalFee = WithdrawalFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapOutput_DualFundDeferred {
    return {
      dualFundDeposit: isSet(object.dualFundDeposit) ? DualFundDeposit.fromJSON(object.dualFundDeposit) : undefined,
      sendingWithdrawalFee: isSet(object.sendingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.sendingWithdrawalFee)
        : undefined,
      receivingWithdrawalFee: isSet(object.receivingWithdrawalFee)
        ? WithdrawalFee.fromJSON(object.receivingWithdrawalFee)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapOutput_DualFundDeferred): unknown {
    const obj: any = {};
    if (message.dualFundDeposit !== undefined) {
      obj.dualFundDeposit = DualFundDeposit.toJSON(message.dualFundDeposit);
    }
    if (message.sendingWithdrawalFee !== undefined) {
      obj.sendingWithdrawalFee = WithdrawalFee.toJSON(message.sendingWithdrawalFee);
    }
    if (message.receivingWithdrawalFee !== undefined) {
      obj.receivingWithdrawalFee = WithdrawalFee.toJSON(message.receivingWithdrawalFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapOutput_DualFundDeferred>, I>>(
    base?: I,
  ): SimpleSwapOutput_DualFundDeferred {
    return SimpleSwapOutput_DualFundDeferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapOutput_DualFundDeferred>, I>>(
    object: I,
  ): SimpleSwapOutput_DualFundDeferred {
    const message = createBaseSimpleSwapOutput_DualFundDeferred();
    message.dualFundDeposit = (object.dualFundDeposit !== undefined && object.dualFundDeposit !== null)
      ? DualFundDeposit.fromPartial(object.dualFundDeposit)
      : undefined;
    message.sendingWithdrawalFee = (object.sendingWithdrawalFee !== undefined && object.sendingWithdrawalFee !== null)
      ? WithdrawalFee.fromPartial(object.sendingWithdrawalFee)
      : undefined;
    message.receivingWithdrawalFee =
      (object.receivingWithdrawalFee !== undefined && object.receivingWithdrawalFee !== null)
        ? WithdrawalFee.fromPartial(object.receivingWithdrawalFee)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapRequest(): SimpleSwapRequest {
  return {
    sendingCurrency: undefined,
    receivingCurrency: undefined,
    amount: undefined,
    priceChangeTolerance: undefined,
    withdrawSendingFunds: false,
    withdrawReceivingFunds: false,
  };
}

export const SimpleSwapRequest: MessageFns<SimpleSwapRequest> = {
  encode(message: SimpleSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.amount !== undefined) {
      SwapAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.priceChangeTolerance !== undefined) {
      DecimalString.encode(message.priceChangeTolerance, writer.uint32(34).fork()).join();
    }
    if (message.withdrawSendingFunds !== false) {
      writer.uint32(40).bool(message.withdrawSendingFunds);
    }
    if (message.withdrawReceivingFunds !== false) {
      writer.uint32(48).bool(message.withdrawReceivingFunds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.priceChangeTolerance = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawSendingFunds = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.withdrawReceivingFunds = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapRequest {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      amount: isSet(object.amount) ? SwapAmount.fromJSON(object.amount) : undefined,
      priceChangeTolerance: isSet(object.priceChangeTolerance)
        ? DecimalString.fromJSON(object.priceChangeTolerance)
        : undefined,
      withdrawSendingFunds: isSet(object.withdrawSendingFunds)
        ? globalThis.Boolean(object.withdrawSendingFunds)
        : false,
      withdrawReceivingFunds: isSet(object.withdrawReceivingFunds)
        ? globalThis.Boolean(object.withdrawReceivingFunds)
        : false,
    };
  },

  toJSON(message: SimpleSwapRequest): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.amount !== undefined) {
      obj.amount = SwapAmount.toJSON(message.amount);
    }
    if (message.priceChangeTolerance !== undefined) {
      obj.priceChangeTolerance = DecimalString.toJSON(message.priceChangeTolerance);
    }
    if (message.withdrawSendingFunds !== false) {
      obj.withdrawSendingFunds = message.withdrawSendingFunds;
    }
    if (message.withdrawReceivingFunds !== false) {
      obj.withdrawReceivingFunds = message.withdrawReceivingFunds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapRequest>, I>>(base?: I): SimpleSwapRequest {
    return SimpleSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapRequest>, I>>(object: I): SimpleSwapRequest {
    const message = createBaseSimpleSwapRequest();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SwapAmount.fromPartial(object.amount)
      : undefined;
    message.priceChangeTolerance = (object.priceChangeTolerance !== undefined && object.priceChangeTolerance !== null)
      ? DecimalString.fromPartial(object.priceChangeTolerance)
      : undefined;
    message.withdrawSendingFunds = object.withdrawSendingFunds ?? false;
    message.withdrawReceivingFunds = object.withdrawReceivingFunds ?? false;
    return message;
  },
};

function createBaseSimpleSwapResponse(): SimpleSwapResponse {
  return { output: undefined };
}

export const SimpleSwapResponse: MessageFns<SimpleSwapResponse> = {
  encode(message: SimpleSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== undefined) {
      SimpleSwapOutput.encode(message.output, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = SimpleSwapOutput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapResponse {
    return { output: isSet(object.output) ? SimpleSwapOutput.fromJSON(object.output) : undefined };
  },

  toJSON(message: SimpleSwapResponse): unknown {
    const obj: any = {};
    if (message.output !== undefined) {
      obj.output = SimpleSwapOutput.toJSON(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapResponse>, I>>(base?: I): SimpleSwapResponse {
    return SimpleSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapResponse>, I>>(object: I): SimpleSwapResponse {
    const message = createBaseSimpleSwapResponse();
    message.output = (object.output !== undefined && object.output !== null)
      ? SimpleSwapOutput.fromPartial(object.output)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate(): SimpleSwapUpdate {
  return {
    timestamp: undefined,
    simpleSwapId: "",
    fundingSendingChannel: undefined,
    rentingReceivingChannel: undefined,
    dualFundingChannel: undefined,
    sendingChannelReady: undefined,
    receivingChannelReady: undefined,
    dualFundChannelReady: undefined,
    waitingForBalances: undefined,
    balancesReady: undefined,
    orderCreated: undefined,
    orderCompleted: undefined,
    withdrawingSendingFunds: undefined,
    withdrawingReceivingFunds: undefined,
    withdrawingDualFundedFunds: undefined,
    sendingFundsWithdrawn: undefined,
    receivingFundsWithdrawn: undefined,
    dualFundedFundsWithdrawn: undefined,
    simpleSwapCompleted: undefined,
    simpleSwapError: undefined,
  };
}

export const SimpleSwapUpdate: MessageFns<SimpleSwapUpdate> = {
  encode(message: SimpleSwapUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.simpleSwapId !== "") {
      writer.uint32(18).string(message.simpleSwapId);
    }
    if (message.fundingSendingChannel !== undefined) {
      SimpleSwapUpdate_FundingSendingChannel.encode(message.fundingSendingChannel, writer.uint32(26).fork()).join();
    }
    if (message.rentingReceivingChannel !== undefined) {
      SimpleSwapUpdate_RentingReceivingChannel.encode(message.rentingReceivingChannel, writer.uint32(34).fork()).join();
    }
    if (message.dualFundingChannel !== undefined) {
      SimpleSwapUpdate_DualFundingChannel.encode(message.dualFundingChannel, writer.uint32(42).fork()).join();
    }
    if (message.sendingChannelReady !== undefined) {
      SimpleSwapUpdate_SendingChannelReady.encode(message.sendingChannelReady, writer.uint32(50).fork()).join();
    }
    if (message.receivingChannelReady !== undefined) {
      SimpleSwapUpdate_ReceivingChannelReady.encode(message.receivingChannelReady, writer.uint32(58).fork()).join();
    }
    if (message.dualFundChannelReady !== undefined) {
      SimpleSwapUpdate_DualFundChannelReady.encode(message.dualFundChannelReady, writer.uint32(66).fork()).join();
    }
    if (message.waitingForBalances !== undefined) {
      SimpleSwapUpdate_WaitingForBalances.encode(message.waitingForBalances, writer.uint32(74).fork()).join();
    }
    if (message.balancesReady !== undefined) {
      SimpleSwapUpdate_BalancesReady.encode(message.balancesReady, writer.uint32(82).fork()).join();
    }
    if (message.orderCreated !== undefined) {
      SimpleSwapUpdate_OrderCreated.encode(message.orderCreated, writer.uint32(90).fork()).join();
    }
    if (message.orderCompleted !== undefined) {
      SimpleSwapUpdate_OrderCompleted.encode(message.orderCompleted, writer.uint32(98).fork()).join();
    }
    if (message.withdrawingSendingFunds !== undefined) {
      SimpleSwapUpdate_WithdrawingSendingFunds.encode(message.withdrawingSendingFunds, writer.uint32(106).fork())
        .join();
    }
    if (message.withdrawingReceivingFunds !== undefined) {
      SimpleSwapUpdate_WithdrawingReceivingFunds.encode(message.withdrawingReceivingFunds, writer.uint32(114).fork())
        .join();
    }
    if (message.withdrawingDualFundedFunds !== undefined) {
      SimpleSwapUpdate_WithdrawingDualFundedFunds.encode(message.withdrawingDualFundedFunds, writer.uint32(122).fork())
        .join();
    }
    if (message.sendingFundsWithdrawn !== undefined) {
      SimpleSwapUpdate_SendingFundsWithdrawn.encode(message.sendingFundsWithdrawn, writer.uint32(130).fork()).join();
    }
    if (message.receivingFundsWithdrawn !== undefined) {
      SimpleSwapUpdate_ReceivingFundsWithdrawn.encode(message.receivingFundsWithdrawn, writer.uint32(138).fork())
        .join();
    }
    if (message.dualFundedFundsWithdrawn !== undefined) {
      SimpleSwapUpdate_DualFundedFundsWithdrawn.encode(message.dualFundedFundsWithdrawn, writer.uint32(146).fork())
        .join();
    }
    if (message.simpleSwapCompleted !== undefined) {
      SimpleSwapUpdate_SimpleSwapCompleted.encode(message.simpleSwapCompleted, writer.uint32(154).fork()).join();
    }
    if (message.simpleSwapError !== undefined) {
      SimpleSwapUpdate_SimpleSwapError.encode(message.simpleSwapError, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.simpleSwapId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fundingSendingChannel = SimpleSwapUpdate_FundingSendingChannel.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rentingReceivingChannel = SimpleSwapUpdate_RentingReceivingChannel.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dualFundingChannel = SimpleSwapUpdate_DualFundingChannel.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sendingChannelReady = SimpleSwapUpdate_SendingChannelReady.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.receivingChannelReady = SimpleSwapUpdate_ReceivingChannelReady.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dualFundChannelReady = SimpleSwapUpdate_DualFundChannelReady.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.waitingForBalances = SimpleSwapUpdate_WaitingForBalances.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.balancesReady = SimpleSwapUpdate_BalancesReady.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.orderCreated = SimpleSwapUpdate_OrderCreated.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.orderCompleted = SimpleSwapUpdate_OrderCompleted.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.withdrawingSendingFunds = SimpleSwapUpdate_WithdrawingSendingFunds.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.withdrawingReceivingFunds = SimpleSwapUpdate_WithdrawingReceivingFunds.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.withdrawingDualFundedFunds = SimpleSwapUpdate_WithdrawingDualFundedFunds.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sendingFundsWithdrawn = SimpleSwapUpdate_SendingFundsWithdrawn.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.receivingFundsWithdrawn = SimpleSwapUpdate_ReceivingFundsWithdrawn.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.dualFundedFundsWithdrawn = SimpleSwapUpdate_DualFundedFundsWithdrawn.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.simpleSwapCompleted = SimpleSwapUpdate_SimpleSwapCompleted.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.simpleSwapError = SimpleSwapUpdate_SimpleSwapError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      simpleSwapId: isSet(object.simpleSwapId) ? globalThis.String(object.simpleSwapId) : "",
      fundingSendingChannel: isSet(object.fundingSendingChannel)
        ? SimpleSwapUpdate_FundingSendingChannel.fromJSON(object.fundingSendingChannel)
        : undefined,
      rentingReceivingChannel: isSet(object.rentingReceivingChannel)
        ? SimpleSwapUpdate_RentingReceivingChannel.fromJSON(object.rentingReceivingChannel)
        : undefined,
      dualFundingChannel: isSet(object.dualFundingChannel)
        ? SimpleSwapUpdate_DualFundingChannel.fromJSON(object.dualFundingChannel)
        : undefined,
      sendingChannelReady: isSet(object.sendingChannelReady)
        ? SimpleSwapUpdate_SendingChannelReady.fromJSON(object.sendingChannelReady)
        : undefined,
      receivingChannelReady: isSet(object.receivingChannelReady)
        ? SimpleSwapUpdate_ReceivingChannelReady.fromJSON(object.receivingChannelReady)
        : undefined,
      dualFundChannelReady: isSet(object.dualFundChannelReady)
        ? SimpleSwapUpdate_DualFundChannelReady.fromJSON(object.dualFundChannelReady)
        : undefined,
      waitingForBalances: isSet(object.waitingForBalances)
        ? SimpleSwapUpdate_WaitingForBalances.fromJSON(object.waitingForBalances)
        : undefined,
      balancesReady: isSet(object.balancesReady)
        ? SimpleSwapUpdate_BalancesReady.fromJSON(object.balancesReady)
        : undefined,
      orderCreated: isSet(object.orderCreated)
        ? SimpleSwapUpdate_OrderCreated.fromJSON(object.orderCreated)
        : undefined,
      orderCompleted: isSet(object.orderCompleted)
        ? SimpleSwapUpdate_OrderCompleted.fromJSON(object.orderCompleted)
        : undefined,
      withdrawingSendingFunds: isSet(object.withdrawingSendingFunds)
        ? SimpleSwapUpdate_WithdrawingSendingFunds.fromJSON(object.withdrawingSendingFunds)
        : undefined,
      withdrawingReceivingFunds: isSet(object.withdrawingReceivingFunds)
        ? SimpleSwapUpdate_WithdrawingReceivingFunds.fromJSON(object.withdrawingReceivingFunds)
        : undefined,
      withdrawingDualFundedFunds: isSet(object.withdrawingDualFundedFunds)
        ? SimpleSwapUpdate_WithdrawingDualFundedFunds.fromJSON(object.withdrawingDualFundedFunds)
        : undefined,
      sendingFundsWithdrawn: isSet(object.sendingFundsWithdrawn)
        ? SimpleSwapUpdate_SendingFundsWithdrawn.fromJSON(object.sendingFundsWithdrawn)
        : undefined,
      receivingFundsWithdrawn: isSet(object.receivingFundsWithdrawn)
        ? SimpleSwapUpdate_ReceivingFundsWithdrawn.fromJSON(object.receivingFundsWithdrawn)
        : undefined,
      dualFundedFundsWithdrawn: isSet(object.dualFundedFundsWithdrawn)
        ? SimpleSwapUpdate_DualFundedFundsWithdrawn.fromJSON(object.dualFundedFundsWithdrawn)
        : undefined,
      simpleSwapCompleted: isSet(object.simpleSwapCompleted)
        ? SimpleSwapUpdate_SimpleSwapCompleted.fromJSON(object.simpleSwapCompleted)
        : undefined,
      simpleSwapError: isSet(object.simpleSwapError)
        ? SimpleSwapUpdate_SimpleSwapError.fromJSON(object.simpleSwapError)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.simpleSwapId !== "") {
      obj.simpleSwapId = message.simpleSwapId;
    }
    if (message.fundingSendingChannel !== undefined) {
      obj.fundingSendingChannel = SimpleSwapUpdate_FundingSendingChannel.toJSON(message.fundingSendingChannel);
    }
    if (message.rentingReceivingChannel !== undefined) {
      obj.rentingReceivingChannel = SimpleSwapUpdate_RentingReceivingChannel.toJSON(message.rentingReceivingChannel);
    }
    if (message.dualFundingChannel !== undefined) {
      obj.dualFundingChannel = SimpleSwapUpdate_DualFundingChannel.toJSON(message.dualFundingChannel);
    }
    if (message.sendingChannelReady !== undefined) {
      obj.sendingChannelReady = SimpleSwapUpdate_SendingChannelReady.toJSON(message.sendingChannelReady);
    }
    if (message.receivingChannelReady !== undefined) {
      obj.receivingChannelReady = SimpleSwapUpdate_ReceivingChannelReady.toJSON(message.receivingChannelReady);
    }
    if (message.dualFundChannelReady !== undefined) {
      obj.dualFundChannelReady = SimpleSwapUpdate_DualFundChannelReady.toJSON(message.dualFundChannelReady);
    }
    if (message.waitingForBalances !== undefined) {
      obj.waitingForBalances = SimpleSwapUpdate_WaitingForBalances.toJSON(message.waitingForBalances);
    }
    if (message.balancesReady !== undefined) {
      obj.balancesReady = SimpleSwapUpdate_BalancesReady.toJSON(message.balancesReady);
    }
    if (message.orderCreated !== undefined) {
      obj.orderCreated = SimpleSwapUpdate_OrderCreated.toJSON(message.orderCreated);
    }
    if (message.orderCompleted !== undefined) {
      obj.orderCompleted = SimpleSwapUpdate_OrderCompleted.toJSON(message.orderCompleted);
    }
    if (message.withdrawingSendingFunds !== undefined) {
      obj.withdrawingSendingFunds = SimpleSwapUpdate_WithdrawingSendingFunds.toJSON(message.withdrawingSendingFunds);
    }
    if (message.withdrawingReceivingFunds !== undefined) {
      obj.withdrawingReceivingFunds = SimpleSwapUpdate_WithdrawingReceivingFunds.toJSON(
        message.withdrawingReceivingFunds,
      );
    }
    if (message.withdrawingDualFundedFunds !== undefined) {
      obj.withdrawingDualFundedFunds = SimpleSwapUpdate_WithdrawingDualFundedFunds.toJSON(
        message.withdrawingDualFundedFunds,
      );
    }
    if (message.sendingFundsWithdrawn !== undefined) {
      obj.sendingFundsWithdrawn = SimpleSwapUpdate_SendingFundsWithdrawn.toJSON(message.sendingFundsWithdrawn);
    }
    if (message.receivingFundsWithdrawn !== undefined) {
      obj.receivingFundsWithdrawn = SimpleSwapUpdate_ReceivingFundsWithdrawn.toJSON(message.receivingFundsWithdrawn);
    }
    if (message.dualFundedFundsWithdrawn !== undefined) {
      obj.dualFundedFundsWithdrawn = SimpleSwapUpdate_DualFundedFundsWithdrawn.toJSON(message.dualFundedFundsWithdrawn);
    }
    if (message.simpleSwapCompleted !== undefined) {
      obj.simpleSwapCompleted = SimpleSwapUpdate_SimpleSwapCompleted.toJSON(message.simpleSwapCompleted);
    }
    if (message.simpleSwapError !== undefined) {
      obj.simpleSwapError = SimpleSwapUpdate_SimpleSwapError.toJSON(message.simpleSwapError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate>, I>>(base?: I): SimpleSwapUpdate {
    return SimpleSwapUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate>, I>>(object: I): SimpleSwapUpdate {
    const message = createBaseSimpleSwapUpdate();
    message.timestamp = object.timestamp ?? undefined;
    message.simpleSwapId = object.simpleSwapId ?? "";
    message.fundingSendingChannel =
      (object.fundingSendingChannel !== undefined && object.fundingSendingChannel !== null)
        ? SimpleSwapUpdate_FundingSendingChannel.fromPartial(object.fundingSendingChannel)
        : undefined;
    message.rentingReceivingChannel =
      (object.rentingReceivingChannel !== undefined && object.rentingReceivingChannel !== null)
        ? SimpleSwapUpdate_RentingReceivingChannel.fromPartial(object.rentingReceivingChannel)
        : undefined;
    message.dualFundingChannel = (object.dualFundingChannel !== undefined && object.dualFundingChannel !== null)
      ? SimpleSwapUpdate_DualFundingChannel.fromPartial(object.dualFundingChannel)
      : undefined;
    message.sendingChannelReady = (object.sendingChannelReady !== undefined && object.sendingChannelReady !== null)
      ? SimpleSwapUpdate_SendingChannelReady.fromPartial(object.sendingChannelReady)
      : undefined;
    message.receivingChannelReady =
      (object.receivingChannelReady !== undefined && object.receivingChannelReady !== null)
        ? SimpleSwapUpdate_ReceivingChannelReady.fromPartial(object.receivingChannelReady)
        : undefined;
    message.dualFundChannelReady = (object.dualFundChannelReady !== undefined && object.dualFundChannelReady !== null)
      ? SimpleSwapUpdate_DualFundChannelReady.fromPartial(object.dualFundChannelReady)
      : undefined;
    message.waitingForBalances = (object.waitingForBalances !== undefined && object.waitingForBalances !== null)
      ? SimpleSwapUpdate_WaitingForBalances.fromPartial(object.waitingForBalances)
      : undefined;
    message.balancesReady = (object.balancesReady !== undefined && object.balancesReady !== null)
      ? SimpleSwapUpdate_BalancesReady.fromPartial(object.balancesReady)
      : undefined;
    message.orderCreated = (object.orderCreated !== undefined && object.orderCreated !== null)
      ? SimpleSwapUpdate_OrderCreated.fromPartial(object.orderCreated)
      : undefined;
    message.orderCompleted = (object.orderCompleted !== undefined && object.orderCompleted !== null)
      ? SimpleSwapUpdate_OrderCompleted.fromPartial(object.orderCompleted)
      : undefined;
    message.withdrawingSendingFunds =
      (object.withdrawingSendingFunds !== undefined && object.withdrawingSendingFunds !== null)
        ? SimpleSwapUpdate_WithdrawingSendingFunds.fromPartial(object.withdrawingSendingFunds)
        : undefined;
    message.withdrawingReceivingFunds =
      (object.withdrawingReceivingFunds !== undefined && object.withdrawingReceivingFunds !== null)
        ? SimpleSwapUpdate_WithdrawingReceivingFunds.fromPartial(object.withdrawingReceivingFunds)
        : undefined;
    message.withdrawingDualFundedFunds =
      (object.withdrawingDualFundedFunds !== undefined && object.withdrawingDualFundedFunds !== null)
        ? SimpleSwapUpdate_WithdrawingDualFundedFunds.fromPartial(object.withdrawingDualFundedFunds)
        : undefined;
    message.sendingFundsWithdrawn =
      (object.sendingFundsWithdrawn !== undefined && object.sendingFundsWithdrawn !== null)
        ? SimpleSwapUpdate_SendingFundsWithdrawn.fromPartial(object.sendingFundsWithdrawn)
        : undefined;
    message.receivingFundsWithdrawn =
      (object.receivingFundsWithdrawn !== undefined && object.receivingFundsWithdrawn !== null)
        ? SimpleSwapUpdate_ReceivingFundsWithdrawn.fromPartial(object.receivingFundsWithdrawn)
        : undefined;
    message.dualFundedFundsWithdrawn =
      (object.dualFundedFundsWithdrawn !== undefined && object.dualFundedFundsWithdrawn !== null)
        ? SimpleSwapUpdate_DualFundedFundsWithdrawn.fromPartial(object.dualFundedFundsWithdrawn)
        : undefined;
    message.simpleSwapCompleted = (object.simpleSwapCompleted !== undefined && object.simpleSwapCompleted !== null)
      ? SimpleSwapUpdate_SimpleSwapCompleted.fromPartial(object.simpleSwapCompleted)
      : undefined;
    message.simpleSwapError = (object.simpleSwapError !== undefined && object.simpleSwapError !== null)
      ? SimpleSwapUpdate_SimpleSwapError.fromPartial(object.simpleSwapError)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_FundingSendingChannel(): SimpleSwapUpdate_FundingSendingChannel {
  return { txid: "", channelId: "", amount: undefined, isOpening: false };
}

export const SimpleSwapUpdate_FundingSendingChannel: MessageFns<SimpleSwapUpdate_FundingSendingChannel> = {
  encode(message: SimpleSwapUpdate_FundingSendingChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.isOpening !== false) {
      writer.uint32(32).bool(message.isOpening);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_FundingSendingChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_FundingSendingChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isOpening = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_FundingSendingChannel {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      isOpening: isSet(object.isOpening) ? globalThis.Boolean(object.isOpening) : false,
    };
  },

  toJSON(message: SimpleSwapUpdate_FundingSendingChannel): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.isOpening !== false) {
      obj.isOpening = message.isOpening;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_FundingSendingChannel>, I>>(
    base?: I,
  ): SimpleSwapUpdate_FundingSendingChannel {
    return SimpleSwapUpdate_FundingSendingChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_FundingSendingChannel>, I>>(
    object: I,
  ): SimpleSwapUpdate_FundingSendingChannel {
    const message = createBaseSimpleSwapUpdate_FundingSendingChannel();
    message.txid = object.txid ?? "";
    message.channelId = object.channelId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.isOpening = object.isOpening ?? false;
    return message;
  },
};

function createBaseSimpleSwapUpdate_RentingReceivingChannel(): SimpleSwapUpdate_RentingReceivingChannel {
  return { txid: "", channelId: "", amount: undefined };
}

export const SimpleSwapUpdate_RentingReceivingChannel: MessageFns<SimpleSwapUpdate_RentingReceivingChannel> = {
  encode(message: SimpleSwapUpdate_RentingReceivingChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_RentingReceivingChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_RentingReceivingChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_RentingReceivingChannel {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_RentingReceivingChannel): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_RentingReceivingChannel>, I>>(
    base?: I,
  ): SimpleSwapUpdate_RentingReceivingChannel {
    return SimpleSwapUpdate_RentingReceivingChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_RentingReceivingChannel>, I>>(
    object: I,
  ): SimpleSwapUpdate_RentingReceivingChannel {
    const message = createBaseSimpleSwapUpdate_RentingReceivingChannel();
    message.txid = object.txid ?? "";
    message.channelId = object.channelId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_DualFundingChannel(): SimpleSwapUpdate_DualFundingChannel {
  return { txid: "", channelId: "", selfAmount: undefined, counterpartyAmount: undefined, isOpening: false };
}

export const SimpleSwapUpdate_DualFundingChannel: MessageFns<SimpleSwapUpdate_DualFundingChannel> = {
  encode(message: SimpleSwapUpdate_DualFundingChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.selfAmount !== undefined) {
      DecimalString.encode(message.selfAmount, writer.uint32(26).fork()).join();
    }
    if (message.counterpartyAmount !== undefined) {
      DecimalString.encode(message.counterpartyAmount, writer.uint32(34).fork()).join();
    }
    if (message.isOpening !== false) {
      writer.uint32(40).bool(message.isOpening);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_DualFundingChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_DualFundingChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.counterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isOpening = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_DualFundingChannel {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      selfAmount: isSet(object.selfAmount) ? DecimalString.fromJSON(object.selfAmount) : undefined,
      counterpartyAmount: isSet(object.counterpartyAmount)
        ? DecimalString.fromJSON(object.counterpartyAmount)
        : undefined,
      isOpening: isSet(object.isOpening) ? globalThis.Boolean(object.isOpening) : false,
    };
  },

  toJSON(message: SimpleSwapUpdate_DualFundingChannel): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.selfAmount !== undefined) {
      obj.selfAmount = DecimalString.toJSON(message.selfAmount);
    }
    if (message.counterpartyAmount !== undefined) {
      obj.counterpartyAmount = DecimalString.toJSON(message.counterpartyAmount);
    }
    if (message.isOpening !== false) {
      obj.isOpening = message.isOpening;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundingChannel>, I>>(
    base?: I,
  ): SimpleSwapUpdate_DualFundingChannel {
    return SimpleSwapUpdate_DualFundingChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundingChannel>, I>>(
    object: I,
  ): SimpleSwapUpdate_DualFundingChannel {
    const message = createBaseSimpleSwapUpdate_DualFundingChannel();
    message.txid = object.txid ?? "";
    message.channelId = object.channelId ?? "";
    message.selfAmount = (object.selfAmount !== undefined && object.selfAmount !== null)
      ? DecimalString.fromPartial(object.selfAmount)
      : undefined;
    message.counterpartyAmount = (object.counterpartyAmount !== undefined && object.counterpartyAmount !== null)
      ? DecimalString.fromPartial(object.counterpartyAmount)
      : undefined;
    message.isOpening = object.isOpening ?? false;
    return message;
  },
};

function createBaseSimpleSwapUpdate_SendingChannelReady(): SimpleSwapUpdate_SendingChannelReady {
  return { channelId: "" };
}

export const SimpleSwapUpdate_SendingChannelReady: MessageFns<SimpleSwapUpdate_SendingChannelReady> = {
  encode(message: SimpleSwapUpdate_SendingChannelReady, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_SendingChannelReady {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_SendingChannelReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_SendingChannelReady {
    return { channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "" };
  },

  toJSON(message: SimpleSwapUpdate_SendingChannelReady): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_SendingChannelReady>, I>>(
    base?: I,
  ): SimpleSwapUpdate_SendingChannelReady {
    return SimpleSwapUpdate_SendingChannelReady.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_SendingChannelReady>, I>>(
    object: I,
  ): SimpleSwapUpdate_SendingChannelReady {
    const message = createBaseSimpleSwapUpdate_SendingChannelReady();
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseSimpleSwapUpdate_ReceivingChannelReady(): SimpleSwapUpdate_ReceivingChannelReady {
  return { channelId: "" };
}

export const SimpleSwapUpdate_ReceivingChannelReady: MessageFns<SimpleSwapUpdate_ReceivingChannelReady> = {
  encode(message: SimpleSwapUpdate_ReceivingChannelReady, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_ReceivingChannelReady {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_ReceivingChannelReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_ReceivingChannelReady {
    return { channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "" };
  },

  toJSON(message: SimpleSwapUpdate_ReceivingChannelReady): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_ReceivingChannelReady>, I>>(
    base?: I,
  ): SimpleSwapUpdate_ReceivingChannelReady {
    return SimpleSwapUpdate_ReceivingChannelReady.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_ReceivingChannelReady>, I>>(
    object: I,
  ): SimpleSwapUpdate_ReceivingChannelReady {
    const message = createBaseSimpleSwapUpdate_ReceivingChannelReady();
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseSimpleSwapUpdate_DualFundChannelReady(): SimpleSwapUpdate_DualFundChannelReady {
  return { channelId: "" };
}

export const SimpleSwapUpdate_DualFundChannelReady: MessageFns<SimpleSwapUpdate_DualFundChannelReady> = {
  encode(message: SimpleSwapUpdate_DualFundChannelReady, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_DualFundChannelReady {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_DualFundChannelReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_DualFundChannelReady {
    return { channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "" };
  },

  toJSON(message: SimpleSwapUpdate_DualFundChannelReady): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundChannelReady>, I>>(
    base?: I,
  ): SimpleSwapUpdate_DualFundChannelReady {
    return SimpleSwapUpdate_DualFundChannelReady.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundChannelReady>, I>>(
    object: I,
  ): SimpleSwapUpdate_DualFundChannelReady {
    const message = createBaseSimpleSwapUpdate_DualFundChannelReady();
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseSimpleSwapUpdate_WaitingForBalances(): SimpleSwapUpdate_WaitingForBalances {
  return { neededSending: undefined, neededReceiving: undefined };
}

export const SimpleSwapUpdate_WaitingForBalances: MessageFns<SimpleSwapUpdate_WaitingForBalances> = {
  encode(message: SimpleSwapUpdate_WaitingForBalances, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.neededSending !== undefined) {
      DecimalString.encode(message.neededSending, writer.uint32(10).fork()).join();
    }
    if (message.neededReceiving !== undefined) {
      DecimalString.encode(message.neededReceiving, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_WaitingForBalances {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_WaitingForBalances();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.neededSending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.neededReceiving = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_WaitingForBalances {
    return {
      neededSending: isSet(object.neededSending) ? DecimalString.fromJSON(object.neededSending) : undefined,
      neededReceiving: isSet(object.neededReceiving) ? DecimalString.fromJSON(object.neededReceiving) : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_WaitingForBalances): unknown {
    const obj: any = {};
    if (message.neededSending !== undefined) {
      obj.neededSending = DecimalString.toJSON(message.neededSending);
    }
    if (message.neededReceiving !== undefined) {
      obj.neededReceiving = DecimalString.toJSON(message.neededReceiving);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_WaitingForBalances>, I>>(
    base?: I,
  ): SimpleSwapUpdate_WaitingForBalances {
    return SimpleSwapUpdate_WaitingForBalances.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_WaitingForBalances>, I>>(
    object: I,
  ): SimpleSwapUpdate_WaitingForBalances {
    const message = createBaseSimpleSwapUpdate_WaitingForBalances();
    message.neededSending = (object.neededSending !== undefined && object.neededSending !== null)
      ? DecimalString.fromPartial(object.neededSending)
      : undefined;
    message.neededReceiving = (object.neededReceiving !== undefined && object.neededReceiving !== null)
      ? DecimalString.fromPartial(object.neededReceiving)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_BalancesReady(): SimpleSwapUpdate_BalancesReady {
  return {};
}

export const SimpleSwapUpdate_BalancesReady: MessageFns<SimpleSwapUpdate_BalancesReady> = {
  encode(_: SimpleSwapUpdate_BalancesReady, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_BalancesReady {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_BalancesReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapUpdate_BalancesReady {
    return {};
  },

  toJSON(_: SimpleSwapUpdate_BalancesReady): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_BalancesReady>, I>>(base?: I): SimpleSwapUpdate_BalancesReady {
    return SimpleSwapUpdate_BalancesReady.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_BalancesReady>, I>>(_: I): SimpleSwapUpdate_BalancesReady {
    const message = createBaseSimpleSwapUpdate_BalancesReady();
    return message;
  },
};

function createBaseSimpleSwapUpdate_OrderCreated(): SimpleSwapUpdate_OrderCreated {
  return { orderId: "" };
}

export const SimpleSwapUpdate_OrderCreated: MessageFns<SimpleSwapUpdate_OrderCreated> = {
  encode(message: SimpleSwapUpdate_OrderCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_OrderCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_OrderCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_OrderCreated {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: SimpleSwapUpdate_OrderCreated): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_OrderCreated>, I>>(base?: I): SimpleSwapUpdate_OrderCreated {
    return SimpleSwapUpdate_OrderCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_OrderCreated>, I>>(
    object: I,
  ): SimpleSwapUpdate_OrderCreated {
    const message = createBaseSimpleSwapUpdate_OrderCreated();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseSimpleSwapUpdate_OrderCompleted(): SimpleSwapUpdate_OrderCompleted {
  return { orderId: "", sentAmount: undefined, receivedAmount: undefined };
}

export const SimpleSwapUpdate_OrderCompleted: MessageFns<SimpleSwapUpdate_OrderCompleted> = {
  encode(message: SimpleSwapUpdate_OrderCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.sentAmount !== undefined) {
      DecimalString.encode(message.sentAmount, writer.uint32(18).fork()).join();
    }
    if (message.receivedAmount !== undefined) {
      DecimalString.encode(message.receivedAmount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_OrderCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_OrderCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sentAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receivedAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_OrderCompleted {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      sentAmount: isSet(object.sentAmount) ? DecimalString.fromJSON(object.sentAmount) : undefined,
      receivedAmount: isSet(object.receivedAmount) ? DecimalString.fromJSON(object.receivedAmount) : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_OrderCompleted): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.sentAmount !== undefined) {
      obj.sentAmount = DecimalString.toJSON(message.sentAmount);
    }
    if (message.receivedAmount !== undefined) {
      obj.receivedAmount = DecimalString.toJSON(message.receivedAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_OrderCompleted>, I>>(base?: I): SimpleSwapUpdate_OrderCompleted {
    return SimpleSwapUpdate_OrderCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_OrderCompleted>, I>>(
    object: I,
  ): SimpleSwapUpdate_OrderCompleted {
    const message = createBaseSimpleSwapUpdate_OrderCompleted();
    message.orderId = object.orderId ?? "";
    message.sentAmount = (object.sentAmount !== undefined && object.sentAmount !== null)
      ? DecimalString.fromPartial(object.sentAmount)
      : undefined;
    message.receivedAmount = (object.receivedAmount !== undefined && object.receivedAmount !== null)
      ? DecimalString.fromPartial(object.receivedAmount)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_WithdrawingSendingFunds(): SimpleSwapUpdate_WithdrawingSendingFunds {
  return { txids: [], selfAmount: undefined, counterpartyAmount: undefined };
}

export const SimpleSwapUpdate_WithdrawingSendingFunds: MessageFns<SimpleSwapUpdate_WithdrawingSendingFunds> = {
  encode(message: SimpleSwapUpdate_WithdrawingSendingFunds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txids) {
      writer.uint32(10).string(v!);
    }
    if (message.selfAmount !== undefined) {
      DecimalString.encode(message.selfAmount, writer.uint32(18).fork()).join();
    }
    if (message.counterpartyAmount !== undefined) {
      DecimalString.encode(message.counterpartyAmount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_WithdrawingSendingFunds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_WithdrawingSendingFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txids.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.counterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_WithdrawingSendingFunds {
    return {
      txids: globalThis.Array.isArray(object?.txids) ? object.txids.map((e: any) => globalThis.String(e)) : [],
      selfAmount: isSet(object.selfAmount) ? DecimalString.fromJSON(object.selfAmount) : undefined,
      counterpartyAmount: isSet(object.counterpartyAmount)
        ? DecimalString.fromJSON(object.counterpartyAmount)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_WithdrawingSendingFunds): unknown {
    const obj: any = {};
    if (message.txids?.length) {
      obj.txids = message.txids;
    }
    if (message.selfAmount !== undefined) {
      obj.selfAmount = DecimalString.toJSON(message.selfAmount);
    }
    if (message.counterpartyAmount !== undefined) {
      obj.counterpartyAmount = DecimalString.toJSON(message.counterpartyAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingSendingFunds>, I>>(
    base?: I,
  ): SimpleSwapUpdate_WithdrawingSendingFunds {
    return SimpleSwapUpdate_WithdrawingSendingFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingSendingFunds>, I>>(
    object: I,
  ): SimpleSwapUpdate_WithdrawingSendingFunds {
    const message = createBaseSimpleSwapUpdate_WithdrawingSendingFunds();
    message.txids = object.txids?.map((e) => e) || [];
    message.selfAmount = (object.selfAmount !== undefined && object.selfAmount !== null)
      ? DecimalString.fromPartial(object.selfAmount)
      : undefined;
    message.counterpartyAmount = (object.counterpartyAmount !== undefined && object.counterpartyAmount !== null)
      ? DecimalString.fromPartial(object.counterpartyAmount)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_WithdrawingReceivingFunds(): SimpleSwapUpdate_WithdrawingReceivingFunds {
  return { txids: [], selfAmount: undefined, counterpartyAmount: undefined };
}

export const SimpleSwapUpdate_WithdrawingReceivingFunds: MessageFns<SimpleSwapUpdate_WithdrawingReceivingFunds> = {
  encode(message: SimpleSwapUpdate_WithdrawingReceivingFunds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txids) {
      writer.uint32(10).string(v!);
    }
    if (message.selfAmount !== undefined) {
      DecimalString.encode(message.selfAmount, writer.uint32(18).fork()).join();
    }
    if (message.counterpartyAmount !== undefined) {
      DecimalString.encode(message.counterpartyAmount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_WithdrawingReceivingFunds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_WithdrawingReceivingFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txids.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.counterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_WithdrawingReceivingFunds {
    return {
      txids: globalThis.Array.isArray(object?.txids) ? object.txids.map((e: any) => globalThis.String(e)) : [],
      selfAmount: isSet(object.selfAmount) ? DecimalString.fromJSON(object.selfAmount) : undefined,
      counterpartyAmount: isSet(object.counterpartyAmount)
        ? DecimalString.fromJSON(object.counterpartyAmount)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_WithdrawingReceivingFunds): unknown {
    const obj: any = {};
    if (message.txids?.length) {
      obj.txids = message.txids;
    }
    if (message.selfAmount !== undefined) {
      obj.selfAmount = DecimalString.toJSON(message.selfAmount);
    }
    if (message.counterpartyAmount !== undefined) {
      obj.counterpartyAmount = DecimalString.toJSON(message.counterpartyAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingReceivingFunds>, I>>(
    base?: I,
  ): SimpleSwapUpdate_WithdrawingReceivingFunds {
    return SimpleSwapUpdate_WithdrawingReceivingFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingReceivingFunds>, I>>(
    object: I,
  ): SimpleSwapUpdate_WithdrawingReceivingFunds {
    const message = createBaseSimpleSwapUpdate_WithdrawingReceivingFunds();
    message.txids = object.txids?.map((e) => e) || [];
    message.selfAmount = (object.selfAmount !== undefined && object.selfAmount !== null)
      ? DecimalString.fromPartial(object.selfAmount)
      : undefined;
    message.counterpartyAmount = (object.counterpartyAmount !== undefined && object.counterpartyAmount !== null)
      ? DecimalString.fromPartial(object.counterpartyAmount)
      : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_WithdrawingDualFundedFunds(): SimpleSwapUpdate_WithdrawingDualFundedFunds {
  return {
    txids: [],
    sendingSelfAmount: undefined,
    sendingCounterpartyAmount: undefined,
    receivingSelfAmount: undefined,
    receivingCounterpartyAmount: undefined,
  };
}

export const SimpleSwapUpdate_WithdrawingDualFundedFunds: MessageFns<SimpleSwapUpdate_WithdrawingDualFundedFunds> = {
  encode(
    message: SimpleSwapUpdate_WithdrawingDualFundedFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.txids) {
      writer.uint32(10).string(v!);
    }
    if (message.sendingSelfAmount !== undefined) {
      DecimalString.encode(message.sendingSelfAmount, writer.uint32(18).fork()).join();
    }
    if (message.sendingCounterpartyAmount !== undefined) {
      DecimalString.encode(message.sendingCounterpartyAmount, writer.uint32(26).fork()).join();
    }
    if (message.receivingSelfAmount !== undefined) {
      DecimalString.encode(message.receivingSelfAmount, writer.uint32(34).fork()).join();
    }
    if (message.receivingCounterpartyAmount !== undefined) {
      DecimalString.encode(message.receivingCounterpartyAmount, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_WithdrawingDualFundedFunds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_WithdrawingDualFundedFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txids.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendingSelfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendingCounterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receivingSelfAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receivingCounterpartyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_WithdrawingDualFundedFunds {
    return {
      txids: globalThis.Array.isArray(object?.txids) ? object.txids.map((e: any) => globalThis.String(e)) : [],
      sendingSelfAmount: isSet(object.sendingSelfAmount) ? DecimalString.fromJSON(object.sendingSelfAmount) : undefined,
      sendingCounterpartyAmount: isSet(object.sendingCounterpartyAmount)
        ? DecimalString.fromJSON(object.sendingCounterpartyAmount)
        : undefined,
      receivingSelfAmount: isSet(object.receivingSelfAmount)
        ? DecimalString.fromJSON(object.receivingSelfAmount)
        : undefined,
      receivingCounterpartyAmount: isSet(object.receivingCounterpartyAmount)
        ? DecimalString.fromJSON(object.receivingCounterpartyAmount)
        : undefined,
    };
  },

  toJSON(message: SimpleSwapUpdate_WithdrawingDualFundedFunds): unknown {
    const obj: any = {};
    if (message.txids?.length) {
      obj.txids = message.txids;
    }
    if (message.sendingSelfAmount !== undefined) {
      obj.sendingSelfAmount = DecimalString.toJSON(message.sendingSelfAmount);
    }
    if (message.sendingCounterpartyAmount !== undefined) {
      obj.sendingCounterpartyAmount = DecimalString.toJSON(message.sendingCounterpartyAmount);
    }
    if (message.receivingSelfAmount !== undefined) {
      obj.receivingSelfAmount = DecimalString.toJSON(message.receivingSelfAmount);
    }
    if (message.receivingCounterpartyAmount !== undefined) {
      obj.receivingCounterpartyAmount = DecimalString.toJSON(message.receivingCounterpartyAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingDualFundedFunds>, I>>(
    base?: I,
  ): SimpleSwapUpdate_WithdrawingDualFundedFunds {
    return SimpleSwapUpdate_WithdrawingDualFundedFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_WithdrawingDualFundedFunds>, I>>(
    object: I,
  ): SimpleSwapUpdate_WithdrawingDualFundedFunds {
    const message = createBaseSimpleSwapUpdate_WithdrawingDualFundedFunds();
    message.txids = object.txids?.map((e) => e) || [];
    message.sendingSelfAmount = (object.sendingSelfAmount !== undefined && object.sendingSelfAmount !== null)
      ? DecimalString.fromPartial(object.sendingSelfAmount)
      : undefined;
    message.sendingCounterpartyAmount =
      (object.sendingCounterpartyAmount !== undefined && object.sendingCounterpartyAmount !== null)
        ? DecimalString.fromPartial(object.sendingCounterpartyAmount)
        : undefined;
    message.receivingSelfAmount = (object.receivingSelfAmount !== undefined && object.receivingSelfAmount !== null)
      ? DecimalString.fromPartial(object.receivingSelfAmount)
      : undefined;
    message.receivingCounterpartyAmount =
      (object.receivingCounterpartyAmount !== undefined && object.receivingCounterpartyAmount !== null)
        ? DecimalString.fromPartial(object.receivingCounterpartyAmount)
        : undefined;
    return message;
  },
};

function createBaseSimpleSwapUpdate_SendingFundsWithdrawn(): SimpleSwapUpdate_SendingFundsWithdrawn {
  return {};
}

export const SimpleSwapUpdate_SendingFundsWithdrawn: MessageFns<SimpleSwapUpdate_SendingFundsWithdrawn> = {
  encode(_: SimpleSwapUpdate_SendingFundsWithdrawn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_SendingFundsWithdrawn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_SendingFundsWithdrawn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapUpdate_SendingFundsWithdrawn {
    return {};
  },

  toJSON(_: SimpleSwapUpdate_SendingFundsWithdrawn): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_SendingFundsWithdrawn>, I>>(
    base?: I,
  ): SimpleSwapUpdate_SendingFundsWithdrawn {
    return SimpleSwapUpdate_SendingFundsWithdrawn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_SendingFundsWithdrawn>, I>>(
    _: I,
  ): SimpleSwapUpdate_SendingFundsWithdrawn {
    const message = createBaseSimpleSwapUpdate_SendingFundsWithdrawn();
    return message;
  },
};

function createBaseSimpleSwapUpdate_ReceivingFundsWithdrawn(): SimpleSwapUpdate_ReceivingFundsWithdrawn {
  return {};
}

export const SimpleSwapUpdate_ReceivingFundsWithdrawn: MessageFns<SimpleSwapUpdate_ReceivingFundsWithdrawn> = {
  encode(_: SimpleSwapUpdate_ReceivingFundsWithdrawn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_ReceivingFundsWithdrawn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_ReceivingFundsWithdrawn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapUpdate_ReceivingFundsWithdrawn {
    return {};
  },

  toJSON(_: SimpleSwapUpdate_ReceivingFundsWithdrawn): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_ReceivingFundsWithdrawn>, I>>(
    base?: I,
  ): SimpleSwapUpdate_ReceivingFundsWithdrawn {
    return SimpleSwapUpdate_ReceivingFundsWithdrawn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_ReceivingFundsWithdrawn>, I>>(
    _: I,
  ): SimpleSwapUpdate_ReceivingFundsWithdrawn {
    const message = createBaseSimpleSwapUpdate_ReceivingFundsWithdrawn();
    return message;
  },
};

function createBaseSimpleSwapUpdate_DualFundedFundsWithdrawn(): SimpleSwapUpdate_DualFundedFundsWithdrawn {
  return {};
}

export const SimpleSwapUpdate_DualFundedFundsWithdrawn: MessageFns<SimpleSwapUpdate_DualFundedFundsWithdrawn> = {
  encode(_: SimpleSwapUpdate_DualFundedFundsWithdrawn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_DualFundedFundsWithdrawn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_DualFundedFundsWithdrawn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapUpdate_DualFundedFundsWithdrawn {
    return {};
  },

  toJSON(_: SimpleSwapUpdate_DualFundedFundsWithdrawn): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundedFundsWithdrawn>, I>>(
    base?: I,
  ): SimpleSwapUpdate_DualFundedFundsWithdrawn {
    return SimpleSwapUpdate_DualFundedFundsWithdrawn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_DualFundedFundsWithdrawn>, I>>(
    _: I,
  ): SimpleSwapUpdate_DualFundedFundsWithdrawn {
    const message = createBaseSimpleSwapUpdate_DualFundedFundsWithdrawn();
    return message;
  },
};

function createBaseSimpleSwapUpdate_SimpleSwapCompleted(): SimpleSwapUpdate_SimpleSwapCompleted {
  return {};
}

export const SimpleSwapUpdate_SimpleSwapCompleted: MessageFns<SimpleSwapUpdate_SimpleSwapCompleted> = {
  encode(_: SimpleSwapUpdate_SimpleSwapCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_SimpleSwapCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_SimpleSwapCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SimpleSwapUpdate_SimpleSwapCompleted {
    return {};
  },

  toJSON(_: SimpleSwapUpdate_SimpleSwapCompleted): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_SimpleSwapCompleted>, I>>(
    base?: I,
  ): SimpleSwapUpdate_SimpleSwapCompleted {
    return SimpleSwapUpdate_SimpleSwapCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_SimpleSwapCompleted>, I>>(
    _: I,
  ): SimpleSwapUpdate_SimpleSwapCompleted {
    const message = createBaseSimpleSwapUpdate_SimpleSwapCompleted();
    return message;
  },
};

function createBaseSimpleSwapUpdate_SimpleSwapError(): SimpleSwapUpdate_SimpleSwapError {
  return { error: "" };
}

export const SimpleSwapUpdate_SimpleSwapError: MessageFns<SimpleSwapUpdate_SimpleSwapError> = {
  encode(message: SimpleSwapUpdate_SimpleSwapError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleSwapUpdate_SimpleSwapError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleSwapUpdate_SimpleSwapError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleSwapUpdate_SimpleSwapError {
    return { error: isSet(object.error) ? globalThis.String(object.error) : "" };
  },

  toJSON(message: SimpleSwapUpdate_SimpleSwapError): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleSwapUpdate_SimpleSwapError>, I>>(
    base?: I,
  ): SimpleSwapUpdate_SimpleSwapError {
    return SimpleSwapUpdate_SimpleSwapError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleSwapUpdate_SimpleSwapError>, I>>(
    object: I,
  ): SimpleSwapUpdate_SimpleSwapError {
    const message = createBaseSimpleSwapUpdate_SimpleSwapError();
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSubscribeSimpleSwapsRequest(): SubscribeSimpleSwapsRequest {
  return {};
}

export const SubscribeSimpleSwapsRequest: MessageFns<SubscribeSimpleSwapsRequest> = {
  encode(_: SubscribeSimpleSwapsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeSimpleSwapsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeSimpleSwapsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubscribeSimpleSwapsRequest {
    return {};
  },

  toJSON(_: SubscribeSimpleSwapsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeSimpleSwapsRequest>, I>>(base?: I): SubscribeSimpleSwapsRequest {
    return SubscribeSimpleSwapsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeSimpleSwapsRequest>, I>>(_: I): SubscribeSimpleSwapsRequest {
    const message = createBaseSubscribeSimpleSwapsRequest();
    return message;
  },
};

/** Swap service definition for performing swap operations. */
export interface SwapService {
  /**
   * Estimate the order matching for a swap operation between two currencies for
   * a certain amount. For a market swap to be performed, the user must have
   * enough offchain balance for both the sending and receiving currencies.
   */
  EstimateSwap(request: EstimateSwapRequest): Promise<EstimateSwapResponse>;
  /**
   * Perform a swap operation between two currencies for a certain amount. The
   * user must have enough offchain balance for both the sending and receiving
   * currencies.
   */
  Swap(request: SwapRequest): Promise<SwapResponse>;
  /**
   * Estimate the fees for setting up channels (via openings, deposits and/or
   * rentals) to then be able to perform a swap operation between two currencies
   * for a certain amount. This also returns the estimate of the order matching
   * in the current orderbook state.
   */
  EstimateSimpleSwap(request: EstimateSimpleSwapRequest): Promise<EstimateSimpleSwapResponse>;
  /**
   * This method is used to automatically set up channels (via openings,
   * deposits and/or rentals) to then be able to perform a swap operation
   * between two currencies for a certain amount. The user does not need to have
   * enough offchain balance for both the sending and receiving currencies as
   * the channels will be automatically set up. The user will be charged for the
   * onchain fees needed to set up the channels. The swap operation will be
   * performed after the channels are ready.
   */
  SimpleSwap(request: SimpleSwapRequest): Promise<SimpleSwapResponse>;
  /**
   * This method is used to subscribe to the updates of simple swaps.
   * The user will receive updates about the swap operation, including the
   * status of the channels being set up, the order matching, and the final
   * result of the swap.
   */
  SubscribeSimpleSwaps(request: SubscribeSimpleSwapsRequest): Observable<SimpleSwapUpdate>;
}

export const SwapServiceServiceName = "hydra_app.SwapService";
export class SwapServiceClientImpl implements SwapService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SwapServiceServiceName;
    this.rpc = rpc;
    this.EstimateSwap = this.EstimateSwap.bind(this);
    this.Swap = this.Swap.bind(this);
    this.EstimateSimpleSwap = this.EstimateSimpleSwap.bind(this);
    this.SimpleSwap = this.SimpleSwap.bind(this);
    this.SubscribeSimpleSwaps = this.SubscribeSimpleSwaps.bind(this);
  }
  EstimateSwap(request: EstimateSwapRequest): Promise<EstimateSwapResponse> {
    const data = EstimateSwapRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateSwap", data);
    return promise.then((data) => EstimateSwapResponse.decode(new BinaryReader(data)));
  }

  Swap(request: SwapRequest): Promise<SwapResponse> {
    const data = SwapRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Swap", data);
    return promise.then((data) => SwapResponse.decode(new BinaryReader(data)));
  }

  EstimateSimpleSwap(request: EstimateSimpleSwapRequest): Promise<EstimateSimpleSwapResponse> {
    const data = EstimateSimpleSwapRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateSimpleSwap", data);
    return promise.then((data) => EstimateSimpleSwapResponse.decode(new BinaryReader(data)));
  }

  SimpleSwap(request: SimpleSwapRequest): Promise<SimpleSwapResponse> {
    const data = SimpleSwapRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SimpleSwap", data);
    return promise.then((data) => SimpleSwapResponse.decode(new BinaryReader(data)));
  }

  SubscribeSimpleSwaps(request: SubscribeSimpleSwapsRequest): Observable<SimpleSwapUpdate> {
    const data = SubscribeSimpleSwapsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SubscribeSimpleSwaps", data);
    return result.pipe(map((data) => SimpleSwapUpdate.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
