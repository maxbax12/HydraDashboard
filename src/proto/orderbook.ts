// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: orderbook.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Timestamp } from "./google/protobuf/timestamp";
import {
  DecimalString,
  OrderbookCurrency,
  OrderMatch,
  Protocol,
  protocolFromJSON,
  protocolToJSON,
  SwapAmount,
} from "./models";

export const protobufPackage = "hydra_app";

export enum OrderSide {
  BUY = 0,
  SELL = 1,
  UNRECOGNIZED = -1,
}

export function orderSideFromJSON(object: any): OrderSide {
  switch (object) {
    case 0:
    case "BUY":
      return OrderSide.BUY;
    case 1:
    case "SELL":
      return OrderSide.SELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderSide.UNRECOGNIZED;
  }
}

export function orderSideToJSON(object: OrderSide): string {
  switch (object) {
    case OrderSide.BUY:
      return "BUY";
    case OrderSide.SELL:
      return "SELL";
    case OrderSide.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderType {
  LIMIT = 0,
  LIQUIDITY = 1,
  MARKET = 2,
  SWAP = 3,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "LIMIT":
      return OrderType.LIMIT;
    case 1:
    case "LIQUIDITY":
      return OrderType.LIQUIDITY;
    case 2:
    case "MARKET":
      return OrderType.MARKET;
    case 3:
    case "SWAP":
      return OrderType.SWAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.LIMIT:
      return "LIMIT";
    case OrderType.LIQUIDITY:
      return "LIQUIDITY";
    case OrderType.MARKET:
      return "MARKET";
    case OrderType.SWAP:
      return "SWAP";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AmountSide {
  BASE = 0,
  QUOTE = 1,
  UNRECOGNIZED = -1,
}

export function amountSideFromJSON(object: any): AmountSide {
  switch (object) {
    case 0:
    case "BASE":
      return AmountSide.BASE;
    case 1:
    case "QUOTE":
      return AmountSide.QUOTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AmountSide.UNRECOGNIZED;
  }
}

export function amountSideToJSON(object: AmountSide): string {
  switch (object) {
    case AmountSide.BASE:
      return "BASE";
    case AmountSide.QUOTE:
      return "QUOTE";
    case AmountSide.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CandlestickInterval {
  ONE_MINUTE = 0,
  THREE_MINUTES = 1,
  FIVE_MINUTES = 2,
  FIFTEEN_MINUTES = 3,
  THIRTY_MINUTES = 4,
  ONE_HOUR = 5,
  TWO_HOURS = 6,
  FOUR_HOURS = 7,
  SIX_HOURS = 8,
  EIGHT_HOURS = 9,
  TWELVE_HOURS = 10,
  ONE_DAY = 11,
  THREE_DAYS = 12,
  ONE_WEEK = 13,
  ONE_MONTH = 14,
  UNRECOGNIZED = -1,
}

export function candlestickIntervalFromJSON(object: any): CandlestickInterval {
  switch (object) {
    case 0:
    case "ONE_MINUTE":
      return CandlestickInterval.ONE_MINUTE;
    case 1:
    case "THREE_MINUTES":
      return CandlestickInterval.THREE_MINUTES;
    case 2:
    case "FIVE_MINUTES":
      return CandlestickInterval.FIVE_MINUTES;
    case 3:
    case "FIFTEEN_MINUTES":
      return CandlestickInterval.FIFTEEN_MINUTES;
    case 4:
    case "THIRTY_MINUTES":
      return CandlestickInterval.THIRTY_MINUTES;
    case 5:
    case "ONE_HOUR":
      return CandlestickInterval.ONE_HOUR;
    case 6:
    case "TWO_HOURS":
      return CandlestickInterval.TWO_HOURS;
    case 7:
    case "FOUR_HOURS":
      return CandlestickInterval.FOUR_HOURS;
    case 8:
    case "SIX_HOURS":
      return CandlestickInterval.SIX_HOURS;
    case 9:
    case "EIGHT_HOURS":
      return CandlestickInterval.EIGHT_HOURS;
    case 10:
    case "TWELVE_HOURS":
      return CandlestickInterval.TWELVE_HOURS;
    case 11:
    case "ONE_DAY":
      return CandlestickInterval.ONE_DAY;
    case 12:
    case "THREE_DAYS":
      return CandlestickInterval.THREE_DAYS;
    case 13:
    case "ONE_WEEK":
      return CandlestickInterval.ONE_WEEK;
    case 14:
    case "ONE_MONTH":
      return CandlestickInterval.ONE_MONTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CandlestickInterval.UNRECOGNIZED;
  }
}

export function candlestickIntervalToJSON(object: CandlestickInterval): string {
  switch (object) {
    case CandlestickInterval.ONE_MINUTE:
      return "ONE_MINUTE";
    case CandlestickInterval.THREE_MINUTES:
      return "THREE_MINUTES";
    case CandlestickInterval.FIVE_MINUTES:
      return "FIVE_MINUTES";
    case CandlestickInterval.FIFTEEN_MINUTES:
      return "FIFTEEN_MINUTES";
    case CandlestickInterval.THIRTY_MINUTES:
      return "THIRTY_MINUTES";
    case CandlestickInterval.ONE_HOUR:
      return "ONE_HOUR";
    case CandlestickInterval.TWO_HOURS:
      return "TWO_HOURS";
    case CandlestickInterval.FOUR_HOURS:
      return "FOUR_HOURS";
    case CandlestickInterval.SIX_HOURS:
      return "SIX_HOURS";
    case CandlestickInterval.EIGHT_HOURS:
      return "EIGHT_HOURS";
    case CandlestickInterval.TWELVE_HOURS:
      return "TWELVE_HOURS";
    case CandlestickInterval.ONE_DAY:
      return "ONE_DAY";
    case CandlestickInterval.THREE_DAYS:
      return "THREE_DAYS";
    case CandlestickInterval.ONE_WEEK:
      return "ONE_WEEK";
    case CandlestickInterval.ONE_MONTH:
      return "ONE_MONTH";
    case CandlestickInterval.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SwapStatus {
  ORDER_MATCHED = 0,
  RECEIVING_INVOICE_CREATED = 1,
  PAYING_INVOICE_RECEIVED = 2,
  PAYMENT_SENT = 3,
  PAYMENT_RECEIVED = 4,
  PAYMENT_CLAIMED = 5,
  PAYMENT_CLAIMED_BY_COUNTERPARTY = 6,
  SWAP_COMPLETED = 7,
  SWAP_FAILED = 8,
  UNRECOGNIZED = -1,
}

export function swapStatusFromJSON(object: any): SwapStatus {
  switch (object) {
    case 0:
    case "ORDER_MATCHED":
      return SwapStatus.ORDER_MATCHED;
    case 1:
    case "RECEIVING_INVOICE_CREATED":
      return SwapStatus.RECEIVING_INVOICE_CREATED;
    case 2:
    case "PAYING_INVOICE_RECEIVED":
      return SwapStatus.PAYING_INVOICE_RECEIVED;
    case 3:
    case "PAYMENT_SENT":
      return SwapStatus.PAYMENT_SENT;
    case 4:
    case "PAYMENT_RECEIVED":
      return SwapStatus.PAYMENT_RECEIVED;
    case 5:
    case "PAYMENT_CLAIMED":
      return SwapStatus.PAYMENT_CLAIMED;
    case 6:
    case "PAYMENT_CLAIMED_BY_COUNTERPARTY":
      return SwapStatus.PAYMENT_CLAIMED_BY_COUNTERPARTY;
    case 7:
    case "SWAP_COMPLETED":
      return SwapStatus.SWAP_COMPLETED;
    case 8:
    case "SWAP_FAILED":
      return SwapStatus.SWAP_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SwapStatus.UNRECOGNIZED;
  }
}

export function swapStatusToJSON(object: SwapStatus): string {
  switch (object) {
    case SwapStatus.ORDER_MATCHED:
      return "ORDER_MATCHED";
    case SwapStatus.RECEIVING_INVOICE_CREATED:
      return "RECEIVING_INVOICE_CREATED";
    case SwapStatus.PAYING_INVOICE_RECEIVED:
      return "PAYING_INVOICE_RECEIVED";
    case SwapStatus.PAYMENT_SENT:
      return "PAYMENT_SENT";
    case SwapStatus.PAYMENT_RECEIVED:
      return "PAYMENT_RECEIVED";
    case SwapStatus.PAYMENT_CLAIMED:
      return "PAYMENT_CLAIMED";
    case SwapStatus.PAYMENT_CLAIMED_BY_COUNTERPARTY:
      return "PAYMENT_CLAIMED_BY_COUNTERPARTY";
    case SwapStatus.SWAP_COMPLETED:
      return "SWAP_COMPLETED";
    case SwapStatus.SWAP_FAILED:
      return "SWAP_FAILED";
    case SwapStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OrderAmount {
  base?: OrderAmount_Base | undefined;
  quote?: OrderAmount_Quote | undefined;
}

export interface OrderAmount_Base {
  amount?: DecimalString | undefined;
}

export interface OrderAmount_Quote {
  amount?: DecimalString | undefined;
}

export interface CurrencyInfo {
  protocol: Protocol;
  networkId: string;
  assetId: string;
  decimals: number;
}

export interface CurrencyInfoPair {
  base?: CurrencyInfo | undefined;
  quote?: CurrencyInfo | undefined;
}

export interface MarketInfo {
  base?: CurrencyInfo | undefined;
  quote?: CurrencyInfo | undefined;
  takerBaseFee?: DecimalString | undefined;
  takerQuoteFee?: DecimalString | undefined;
  makerBaseFee?: DecimalString | undefined;
  makerQuoteFee?: DecimalString | undefined;
  basePrecision: number;
  quotePrecision: number;
  minBaseAmount?: DecimalString | undefined;
  minQuoteAmount?: DecimalString | undefined;
}

export interface OrderbookBalance {
  currency?: OrderbookCurrency | undefined;
  balance?: CurrencyBalance | undefined;
}

export interface CurrencyBalance {
  sending?: DecimalString | undefined;
  receiving?: DecimalString | undefined;
  pendingSending?: DecimalString | undefined;
  pendingReceiving?: DecimalString | undefined;
  unavailableSending?: DecimalString | undefined;
  unavailableReceiving?: DecimalString | undefined;
  inUseSending?: DecimalString | undefined;
  inUseReceiving?: DecimalString | undefined;
}

export interface LiquidityPosition {
  clientPubkey: Uint8Array;
  minBuyPrice?: DecimalString | undefined;
  quoteAmount?: DecimalString | undefined;
  maxBuyPrice?: DecimalString | undefined;
  inactiveQuoteAmount?: DecimalString | undefined;
  highestBuyPrice?: DecimalString | undefined;
  lowestSellPrice?: DecimalString | undefined;
  inactiveBaseAmount?: DecimalString | undefined;
  minSellPrice?: DecimalString | undefined;
  baseAmount?: DecimalString | undefined;
  maxSellPrice?: DecimalString | undefined;
  removeOnFill: boolean;
}

export interface Orderbook {
  info?: MarketInfo | undefined;
  orders: { [key: string]: LiquidityPosition };
}

export interface Orderbook_OrdersEntry {
  key: string;
  value?: LiquidityPosition | undefined;
}

export interface OrderVariant {
  addLiquidity?: OrderVariant_AddLiquidity | undefined;
  marketOrder?: OrderVariant_MarketOrder | undefined;
  swapOrder?: OrderVariant_SwapOrder | undefined;
}

export interface OrderVariant_AddLiquidity {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  minBuyPrice?: DecimalString | undefined;
  midPrice?: DecimalString | undefined;
  maxSellPrice?: DecimalString | undefined;
  amount?:
    | OrderAmount
    | undefined;
  /** remove the liquidity as soon as some part is filled */
  removeOnFill: boolean;
}

export interface OrderVariant_MarketOrder {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  amount?: OrderAmount | undefined;
  side: OrderSide;
}

export interface OrderVariant_SwapOrder {
  fromCurrency?: OrderbookCurrency | undefined;
  currencyPath: OrderbookCurrency[];
  toCurrency?: OrderbookCurrency | undefined;
  amount?: SwapAmount | undefined;
}

/**
 * Represents an order that adds liquidity to a pair of currencies in the
 * orderbook.
 */
export interface LiquidityOrder {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  createdAt?: Date | undefined;
  minBuyPrice?: DecimalString | undefined;
  maxBuyPrice?: DecimalString | undefined;
  minSellPrice?: DecimalString | undefined;
  maxSellPrice?: DecimalString | undefined;
  remainingBaseAmount?: DecimalString | undefined;
  remainingQuoteAmount?: DecimalString | undefined;
  soldBaseAmount?: DecimalString | undefined;
  boughtBaseAmount?: DecimalString | undefined;
  soldQuoteAmount?: DecimalString | undefined;
  boughtQuoteAmount?: DecimalString | undefined;
  paidBaseFee?: DecimalString | undefined;
  paidQuoteFee?: DecimalString | undefined;
  removeOnFill: boolean;
}

/**
 * Represents a market order for a pair of currencies in the orderbook.
 * A market order is an order to buy or sell a currency at the best available
 * price in the orderbook.
 */
export interface MarketOrder {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  createdAt?: Date | undefined;
  remainingAmount?: OrderAmount | undefined;
  unmatchedAmount?: OrderAmount | undefined;
  failedAmount?: OrderAmount | undefined;
  buy?: MarketOrder_Buy | undefined;
  sell?: MarketOrder_Sell | undefined;
}

export interface MarketOrder_Buy {
  boughtBaseAmount?: DecimalString | undefined;
  soldQuoteAmount?: DecimalString | undefined;
  paidBaseFee?: DecimalString | undefined;
}

export interface MarketOrder_Sell {
  soldBaseAmount?: DecimalString | undefined;
  boughtQuoteAmount?: DecimalString | undefined;
  paidQuoteFee?: DecimalString | undefined;
}

/**
 * Represents an order for a pair of currencies in the orderbook.
 * It can either be a liquidity order or a market order.
 * Liquidity orders are used to add liquidity to the orderbook, while market
 * orders are used to buy or sell currencies at the best available price.
 */
export interface PairOrder {
  liquidityOrder?: LiquidityOrder | undefined;
  marketOrder?: MarketOrder | undefined;
}

/**
 * Represents an order for swapping one currency for another.
 * It can involve multiple pair orders in a path to achieve the swap.
 * The swap order contains information about the currencies involved, the
 * created timestamp, the remaining amount to be swapped, and the amounts
 * sold and bought in the swap, including any fees paid.
 */
export interface SwapOrder {
  fromCurrency?: OrderbookCurrency | undefined;
  currencyPath: OrderbookCurrency[];
  toCurrency?: OrderbookCurrency | undefined;
  createdAt?: Date | undefined;
  remainingAmount?: SwapAmount | undefined;
  unmatchedAmount?: SwapAmount | undefined;
  failedAmount?: SwapAmount | undefined;
  soldFromCurrencyAmount?: DecimalString | undefined;
  boughtToCurrencyAmount?: DecimalString | undefined;
  paidToCurrencyFee?: DecimalString | undefined;
}

/** Represents an order that can be either a pair order or a swap order. */
export interface Order {
  pairOrder?: PairOrder | undefined;
  swapOrder?: SwapOrder | undefined;
}

export interface Trade {
  takerOrderId: string;
  baseAmount?: DecimalString | undefined;
  quoteAmount?: DecimalString | undefined;
  price?: DecimalString | undefined;
  finalPrice?: DecimalString | undefined;
  timestamp?: Date | undefined;
  makerOrderSide: OrderSide;
}

export interface ClientMarketTrade {
  swapId: string;
  orderId: string;
  baseAmount?: DecimalString | undefined;
  quoteAmount?: DecimalString | undefined;
  baseFee?: DecimalString | undefined;
  quoteFee?: DecimalString | undefined;
  price?: DecimalString | undefined;
  finalPrice?: DecimalString | undefined;
  timestamp?: Date | undefined;
  orderSide: OrderSide;
  orderType: OrderType;
}

export interface ClientSwapTrade {
  swapId: string;
  orderId: string;
  fromCurrencyAmount?: DecimalString | undefined;
  toCurrencyAmount?: DecimalString | undefined;
  toCurrencyFee?: DecimalString | undefined;
  timestamp?: Date | undefined;
}

export interface InitMarketRequest {
  firstCurrency?: OrderbookCurrency | undefined;
  otherCurrency?: OrderbookCurrency | undefined;
}

export interface InitMarketResponse {
  marketInfo?: MarketInfo | undefined;
}

export interface GetInitializedMarketsRequest {
}

export interface GetInitializedMarketsResponse {
  markets: CurrencyInfoPair[];
}

export interface GetMarketsInfoRequest {
}

export interface GetMarketsInfoResponse {
  markets: MarketInfo[];
}

export interface GetMarketInfoRequest {
  firstCurrency?: OrderbookCurrency | undefined;
  otherCurrency?: OrderbookCurrency | undefined;
}

export interface GetMarketInfoResponse {
  marketInfo?: MarketInfo | undefined;
}

export interface GetOrderbookBalancesRequest {
}

export interface GetOrderbookBalancesResponse {
  balances: OrderbookBalance[];
}

export interface GetOrderbookRequest {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
}

export interface GetOrderbookResponse {
  orderbook?: Orderbook | undefined;
}

export interface EstimateOrderRequest {
  orderVariant?: OrderVariant | undefined;
}

export interface EstimateOrderResponse {
  orderMatch?: OrderMatch | undefined;
}

export interface CreateOrderRequest {
  orderVariant?: OrderVariant | undefined;
}

export interface CreateOrderResponse {
  orderId: string;
}

export interface CancelOrderRequest {
  orderId: string;
}

export interface CancelOrderResponse {
  removed: boolean;
}

export interface CancelAllOrdersRequest {
}

export interface CancelAllOrdersResponse {
}

export interface GetOwnOrdersRequest {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
}

export interface GetOwnOrdersResponse {
  /** key: order_id */
  orders: { [key: string]: Order };
}

export interface GetOwnOrdersResponse_OrdersEntry {
  key: string;
  value?: Order | undefined;
}

export interface GetAllOwnOrdersRequest {
}

export interface GetAllOwnOrdersResponse {
  /** key: order_id */
  orders: { [key: string]: Order };
}

export interface GetAllOwnOrdersResponse_OrdersEntry {
  key: string;
  value?: Order | undefined;
}

export interface GetOrderRequest {
  orderId: string;
}

export interface GetOrderResponse {
  order?: Order | undefined;
}

export interface GetTradeHistoryRequest {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
}

export interface GetTradeHistoryResponse {
  /**
   * The trade history for the specified market.
   * Sorted by timestamp in descending order.
   * The most recent trades are at the beginning of the list.
   */
  tradeHistory: Trade[];
}

export interface GetAllMarketTradesRequest {
}

export interface GetAllMarketTradesResponse {
  pairMarketTrades: GetAllMarketTradesResponse_PairMarketTrades[];
}

export interface GetAllMarketTradesResponse_PairMarketTrades {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  trades: ClientMarketTrade[];
}

export interface GetPairMarketTradesRequest {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
}

export interface GetPairMarketTradesResponse {
  /**
   * The trades performed by the user in the specified market.
   * Sorted by timestamp in descending order.
   * The most recent trades are at the beginning of the list.
   */
  trades: ClientMarketTrade[];
}

export interface GetAllSwapTradesRequest {
}

export interface GetAllSwapTradesResponse {
  pairSwapTrades: GetAllSwapTradesResponse_PairSwapTrades[];
}

export interface GetAllSwapTradesResponse_PairSwapTrades {
  fromCurrency?: OrderbookCurrency | undefined;
  toCurrency?: OrderbookCurrency | undefined;
  trades: ClientSwapTrade[];
}

export interface GetPairSwapTradesRequest {
  fromCurrency?: OrderbookCurrency | undefined;
  toCurrency?: OrderbookCurrency | undefined;
}

export interface GetPairSwapTradesResponse {
  /**
   * The swap trades performed by the user for the specified pair of currencies.
   * Sorted by timestamp in descending order.
   * The most recent trades are at the beginning of the list.
   */
  trades: ClientSwapTrade[];
}

export interface OrderbookUpdate {
  /** order_id -> update */
  updatedOrders: { [key: string]: LiquidityPosition };
  /** order_ids */
  removedOrders: string[];
}

export interface OrderbookUpdate_UpdatedOrdersEntry {
  key: string;
  value?: LiquidityPosition | undefined;
}

export interface MarketVolatility {
  firstPrice?: DecimalString | undefined;
  lastPrice?: DecimalString | undefined;
  highPrice?: DecimalString | undefined;
  lowPrice?: DecimalString | undefined;
  baseVolume?: DecimalString | undefined;
  quoteVolume?: DecimalString | undefined;
}

export interface MarketDailyStats {
  volatility?: MarketVolatility | undefined;
}

export interface Candlestick {
  timestamp?: Date | undefined;
  open?: DecimalString | undefined;
  close?: DecimalString | undefined;
  high?: DecimalString | undefined;
  low?: DecimalString | undefined;
  baseVolume?: DecimalString | undefined;
  quoteVolume?: DecimalString | undefined;
}

export interface CandlestickUpdate {
  interval: CandlestickInterval;
  candlestick?: Candlestick | undefined;
}

export interface MarketEvent {
  isSynced?: boolean | undefined;
  orderbookUpdate?: OrderbookUpdate | undefined;
  tradeUpdate?: Trade | undefined;
  dailyStatsUpdate?: MarketDailyStats | undefined;
  candlestickUpdate?: CandlestickUpdate | undefined;
}

export interface BalanceUpdate {
  currency?: OrderbookCurrency | undefined;
  balance?: CurrencyBalance | undefined;
}

export interface OrderUpdate {
  orderCreated?: OrderUpdate_OrderCreated | undefined;
  orderUpdated?: OrderUpdate_OrderUpdated | undefined;
  orderCompleted?: OrderUpdate_OrderCompleted | undefined;
  orderCanceled?: OrderUpdate_OrderCanceled | undefined;
}

export interface OrderUpdate_OrderCreated {
  orderId: string;
  order?: Order | undefined;
}

export interface OrderUpdate_OrderUpdated {
  orderId: string;
  order?: Order | undefined;
}

export interface OrderUpdate_OrderCompleted {
  orderId: string;
}

export interface OrderUpdate_OrderCanceled {
  orderId: string;
}

export interface SwapHop {
  sendingCurrency?: OrderbookCurrency | undefined;
  receivingCurrency?: OrderbookCurrency | undefined;
  sendingAmount?: DecimalString | undefined;
  receivingAmount?: DecimalString | undefined;
  receivingFee?: DecimalString | undefined;
}

export interface SwapPath {
  swapId: string;
  firstHop?: SwapHop | undefined;
  nextHops: SwapHop[];
}

export interface MatchedOrder {
  ownOrderId: string;
  swapRoute: SwapPath[];
  isTaker: boolean;
}

export interface SwapUpdate {
  orderId: string;
  swapId: string;
  progress?: SwapProgress | undefined;
}

export interface SwapProgress {
  receivingAmount?: DecimalString | undefined;
  payingAmount?: DecimalString | undefined;
  status: SwapStatus;
  error?: string | undefined;
}

export interface MarketTradeUpdate {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
  trade?: ClientMarketTrade | undefined;
}

export interface SwapTradeUpdate {
  fromCurrency?: OrderbookCurrency | undefined;
  toCurrency?: OrderbookCurrency | undefined;
  trade?: ClientSwapTrade | undefined;
}

export interface DexEvent {
  timestamp?: Date | undefined;
  isSynced?: boolean | undefined;
  balanceUpdate?: BalanceUpdate | undefined;
  orderUpdate?: OrderUpdate | undefined;
  orderMatched?: MatchedOrder | undefined;
  swapUpdate?: SwapUpdate | undefined;
  marketTradeUpdate?: MarketTradeUpdate | undefined;
  swapTradeUpdate?: SwapTradeUpdate | undefined;
}

export interface SubscribeMarketEventsRequest {
  base?: OrderbookCurrency | undefined;
  quote?: OrderbookCurrency | undefined;
}

export interface SubscribeDexEventsRequest {
}

function createBaseOrderAmount(): OrderAmount {
  return { base: undefined, quote: undefined };
}

export const OrderAmount: MessageFns<OrderAmount> = {
  encode(message: OrderAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderAmount_Base.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderAmount_Quote.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderAmount_Base.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderAmount_Quote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderAmount {
    return {
      base: isSet(object.base) ? OrderAmount_Base.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderAmount_Quote.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: OrderAmount): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderAmount_Base.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderAmount_Quote.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderAmount>, I>>(base?: I): OrderAmount {
    return OrderAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderAmount>, I>>(object: I): OrderAmount {
    const message = createBaseOrderAmount();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderAmount_Base.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderAmount_Quote.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseOrderAmount_Base(): OrderAmount_Base {
  return { amount: undefined };
}

export const OrderAmount_Base: MessageFns<OrderAmount_Base> = {
  encode(message: OrderAmount_Base, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderAmount_Base {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderAmount_Base();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderAmount_Base {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: OrderAmount_Base): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderAmount_Base>, I>>(base?: I): OrderAmount_Base {
    return OrderAmount_Base.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderAmount_Base>, I>>(object: I): OrderAmount_Base {
    const message = createBaseOrderAmount_Base();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseOrderAmount_Quote(): OrderAmount_Quote {
  return { amount: undefined };
}

export const OrderAmount_Quote: MessageFns<OrderAmount_Quote> = {
  encode(message: OrderAmount_Quote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderAmount_Quote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderAmount_Quote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderAmount_Quote {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: OrderAmount_Quote): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderAmount_Quote>, I>>(base?: I): OrderAmount_Quote {
    return OrderAmount_Quote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderAmount_Quote>, I>>(object: I): OrderAmount_Quote {
    const message = createBaseOrderAmount_Quote();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseCurrencyInfo(): CurrencyInfo {
  return { protocol: 0, networkId: "", assetId: "", decimals: 0 };
}

export const CurrencyInfo: MessageFns<CurrencyInfo> = {
  encode(message: CurrencyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.networkId !== "") {
      writer.uint32(18).string(message.networkId);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint32(message.decimals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.networkId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyInfo {
    return {
      protocol: isSet(object.protocol) ? protocolFromJSON(object.protocol) : 0,
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
    };
  },

  toJSON(message: CurrencyInfo): unknown {
    const obj: any = {};
    if (message.protocol !== 0) {
      obj.protocol = protocolToJSON(message.protocol);
    }
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyInfo>, I>>(base?: I): CurrencyInfo {
    return CurrencyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyInfo>, I>>(object: I): CurrencyInfo {
    const message = createBaseCurrencyInfo();
    message.protocol = object.protocol ?? 0;
    message.networkId = object.networkId ?? "";
    message.assetId = object.assetId ?? "";
    message.decimals = object.decimals ?? 0;
    return message;
  },
};

function createBaseCurrencyInfoPair(): CurrencyInfoPair {
  return { base: undefined, quote: undefined };
}

export const CurrencyInfoPair: MessageFns<CurrencyInfoPair> = {
  encode(message: CurrencyInfoPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      CurrencyInfo.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      CurrencyInfo.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyInfoPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyInfoPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = CurrencyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = CurrencyInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyInfoPair {
    return {
      base: isSet(object.base) ? CurrencyInfo.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? CurrencyInfo.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: CurrencyInfoPair): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CurrencyInfo.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = CurrencyInfo.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyInfoPair>, I>>(base?: I): CurrencyInfoPair {
    return CurrencyInfoPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyInfoPair>, I>>(object: I): CurrencyInfoPair {
    const message = createBaseCurrencyInfoPair();
    message.base = (object.base !== undefined && object.base !== null)
      ? CurrencyInfo.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? CurrencyInfo.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseMarketInfo(): MarketInfo {
  return {
    base: undefined,
    quote: undefined,
    takerBaseFee: undefined,
    takerQuoteFee: undefined,
    makerBaseFee: undefined,
    makerQuoteFee: undefined,
    basePrecision: 0,
    quotePrecision: 0,
    minBaseAmount: undefined,
    minQuoteAmount: undefined,
  };
}

export const MarketInfo: MessageFns<MarketInfo> = {
  encode(message: MarketInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      CurrencyInfo.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      CurrencyInfo.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.takerBaseFee !== undefined) {
      DecimalString.encode(message.takerBaseFee, writer.uint32(26).fork()).join();
    }
    if (message.takerQuoteFee !== undefined) {
      DecimalString.encode(message.takerQuoteFee, writer.uint32(34).fork()).join();
    }
    if (message.makerBaseFee !== undefined) {
      DecimalString.encode(message.makerBaseFee, writer.uint32(42).fork()).join();
    }
    if (message.makerQuoteFee !== undefined) {
      DecimalString.encode(message.makerQuoteFee, writer.uint32(50).fork()).join();
    }
    if (message.basePrecision !== 0) {
      writer.uint32(56).uint32(message.basePrecision);
    }
    if (message.quotePrecision !== 0) {
      writer.uint32(64).uint32(message.quotePrecision);
    }
    if (message.minBaseAmount !== undefined) {
      DecimalString.encode(message.minBaseAmount, writer.uint32(74).fork()).join();
    }
    if (message.minQuoteAmount !== undefined) {
      DecimalString.encode(message.minQuoteAmount, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = CurrencyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = CurrencyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.takerBaseFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.takerQuoteFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.makerBaseFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.makerQuoteFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.basePrecision = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quotePrecision = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.minBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.minQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketInfo {
    return {
      base: isSet(object.base) ? CurrencyInfo.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? CurrencyInfo.fromJSON(object.quote) : undefined,
      takerBaseFee: isSet(object.takerBaseFee) ? DecimalString.fromJSON(object.takerBaseFee) : undefined,
      takerQuoteFee: isSet(object.takerQuoteFee) ? DecimalString.fromJSON(object.takerQuoteFee) : undefined,
      makerBaseFee: isSet(object.makerBaseFee) ? DecimalString.fromJSON(object.makerBaseFee) : undefined,
      makerQuoteFee: isSet(object.makerQuoteFee) ? DecimalString.fromJSON(object.makerQuoteFee) : undefined,
      basePrecision: isSet(object.basePrecision) ? globalThis.Number(object.basePrecision) : 0,
      quotePrecision: isSet(object.quotePrecision) ? globalThis.Number(object.quotePrecision) : 0,
      minBaseAmount: isSet(object.minBaseAmount) ? DecimalString.fromJSON(object.minBaseAmount) : undefined,
      minQuoteAmount: isSet(object.minQuoteAmount) ? DecimalString.fromJSON(object.minQuoteAmount) : undefined,
    };
  },

  toJSON(message: MarketInfo): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CurrencyInfo.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = CurrencyInfo.toJSON(message.quote);
    }
    if (message.takerBaseFee !== undefined) {
      obj.takerBaseFee = DecimalString.toJSON(message.takerBaseFee);
    }
    if (message.takerQuoteFee !== undefined) {
      obj.takerQuoteFee = DecimalString.toJSON(message.takerQuoteFee);
    }
    if (message.makerBaseFee !== undefined) {
      obj.makerBaseFee = DecimalString.toJSON(message.makerBaseFee);
    }
    if (message.makerQuoteFee !== undefined) {
      obj.makerQuoteFee = DecimalString.toJSON(message.makerQuoteFee);
    }
    if (message.basePrecision !== 0) {
      obj.basePrecision = Math.round(message.basePrecision);
    }
    if (message.quotePrecision !== 0) {
      obj.quotePrecision = Math.round(message.quotePrecision);
    }
    if (message.minBaseAmount !== undefined) {
      obj.minBaseAmount = DecimalString.toJSON(message.minBaseAmount);
    }
    if (message.minQuoteAmount !== undefined) {
      obj.minQuoteAmount = DecimalString.toJSON(message.minQuoteAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketInfo>, I>>(base?: I): MarketInfo {
    return MarketInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketInfo>, I>>(object: I): MarketInfo {
    const message = createBaseMarketInfo();
    message.base = (object.base !== undefined && object.base !== null)
      ? CurrencyInfo.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? CurrencyInfo.fromPartial(object.quote)
      : undefined;
    message.takerBaseFee = (object.takerBaseFee !== undefined && object.takerBaseFee !== null)
      ? DecimalString.fromPartial(object.takerBaseFee)
      : undefined;
    message.takerQuoteFee = (object.takerQuoteFee !== undefined && object.takerQuoteFee !== null)
      ? DecimalString.fromPartial(object.takerQuoteFee)
      : undefined;
    message.makerBaseFee = (object.makerBaseFee !== undefined && object.makerBaseFee !== null)
      ? DecimalString.fromPartial(object.makerBaseFee)
      : undefined;
    message.makerQuoteFee = (object.makerQuoteFee !== undefined && object.makerQuoteFee !== null)
      ? DecimalString.fromPartial(object.makerQuoteFee)
      : undefined;
    message.basePrecision = object.basePrecision ?? 0;
    message.quotePrecision = object.quotePrecision ?? 0;
    message.minBaseAmount = (object.minBaseAmount !== undefined && object.minBaseAmount !== null)
      ? DecimalString.fromPartial(object.minBaseAmount)
      : undefined;
    message.minQuoteAmount = (object.minQuoteAmount !== undefined && object.minQuoteAmount !== null)
      ? DecimalString.fromPartial(object.minQuoteAmount)
      : undefined;
    return message;
  },
};

function createBaseOrderbookBalance(): OrderbookBalance {
  return { currency: undefined, balance: undefined };
}

export const OrderbookBalance: MessageFns<OrderbookBalance> = {
  encode(message: OrderbookBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== undefined) {
      OrderbookCurrency.encode(message.currency, writer.uint32(10).fork()).join();
    }
    if (message.balance !== undefined) {
      CurrencyBalance.encode(message.balance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderbookBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = CurrencyBalance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookBalance {
    return {
      currency: isSet(object.currency) ? OrderbookCurrency.fromJSON(object.currency) : undefined,
      balance: isSet(object.balance) ? CurrencyBalance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: OrderbookBalance): unknown {
    const obj: any = {};
    if (message.currency !== undefined) {
      obj.currency = OrderbookCurrency.toJSON(message.currency);
    }
    if (message.balance !== undefined) {
      obj.balance = CurrencyBalance.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookBalance>, I>>(base?: I): OrderbookBalance {
    return OrderbookBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookBalance>, I>>(object: I): OrderbookBalance {
    const message = createBaseOrderbookBalance();
    message.currency = (object.currency !== undefined && object.currency !== null)
      ? OrderbookCurrency.fromPartial(object.currency)
      : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? CurrencyBalance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseCurrencyBalance(): CurrencyBalance {
  return {
    sending: undefined,
    receiving: undefined,
    pendingSending: undefined,
    pendingReceiving: undefined,
    unavailableSending: undefined,
    unavailableReceiving: undefined,
    inUseSending: undefined,
    inUseReceiving: undefined,
  };
}

export const CurrencyBalance: MessageFns<CurrencyBalance> = {
  encode(message: CurrencyBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sending !== undefined) {
      DecimalString.encode(message.sending, writer.uint32(10).fork()).join();
    }
    if (message.receiving !== undefined) {
      DecimalString.encode(message.receiving, writer.uint32(18).fork()).join();
    }
    if (message.pendingSending !== undefined) {
      DecimalString.encode(message.pendingSending, writer.uint32(26).fork()).join();
    }
    if (message.pendingReceiving !== undefined) {
      DecimalString.encode(message.pendingReceiving, writer.uint32(34).fork()).join();
    }
    if (message.unavailableSending !== undefined) {
      DecimalString.encode(message.unavailableSending, writer.uint32(42).fork()).join();
    }
    if (message.unavailableReceiving !== undefined) {
      DecimalString.encode(message.unavailableReceiving, writer.uint32(50).fork()).join();
    }
    if (message.inUseSending !== undefined) {
      DecimalString.encode(message.inUseSending, writer.uint32(58).fork()).join();
    }
    if (message.inUseReceiving !== undefined) {
      DecimalString.encode(message.inUseReceiving, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receiving = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pendingSending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pendingReceiving = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unavailableSending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unavailableReceiving = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inUseSending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inUseReceiving = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyBalance {
    return {
      sending: isSet(object.sending) ? DecimalString.fromJSON(object.sending) : undefined,
      receiving: isSet(object.receiving) ? DecimalString.fromJSON(object.receiving) : undefined,
      pendingSending: isSet(object.pendingSending) ? DecimalString.fromJSON(object.pendingSending) : undefined,
      pendingReceiving: isSet(object.pendingReceiving) ? DecimalString.fromJSON(object.pendingReceiving) : undefined,
      unavailableSending: isSet(object.unavailableSending)
        ? DecimalString.fromJSON(object.unavailableSending)
        : undefined,
      unavailableReceiving: isSet(object.unavailableReceiving)
        ? DecimalString.fromJSON(object.unavailableReceiving)
        : undefined,
      inUseSending: isSet(object.inUseSending) ? DecimalString.fromJSON(object.inUseSending) : undefined,
      inUseReceiving: isSet(object.inUseReceiving) ? DecimalString.fromJSON(object.inUseReceiving) : undefined,
    };
  },

  toJSON(message: CurrencyBalance): unknown {
    const obj: any = {};
    if (message.sending !== undefined) {
      obj.sending = DecimalString.toJSON(message.sending);
    }
    if (message.receiving !== undefined) {
      obj.receiving = DecimalString.toJSON(message.receiving);
    }
    if (message.pendingSending !== undefined) {
      obj.pendingSending = DecimalString.toJSON(message.pendingSending);
    }
    if (message.pendingReceiving !== undefined) {
      obj.pendingReceiving = DecimalString.toJSON(message.pendingReceiving);
    }
    if (message.unavailableSending !== undefined) {
      obj.unavailableSending = DecimalString.toJSON(message.unavailableSending);
    }
    if (message.unavailableReceiving !== undefined) {
      obj.unavailableReceiving = DecimalString.toJSON(message.unavailableReceiving);
    }
    if (message.inUseSending !== undefined) {
      obj.inUseSending = DecimalString.toJSON(message.inUseSending);
    }
    if (message.inUseReceiving !== undefined) {
      obj.inUseReceiving = DecimalString.toJSON(message.inUseReceiving);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyBalance>, I>>(base?: I): CurrencyBalance {
    return CurrencyBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyBalance>, I>>(object: I): CurrencyBalance {
    const message = createBaseCurrencyBalance();
    message.sending = (object.sending !== undefined && object.sending !== null)
      ? DecimalString.fromPartial(object.sending)
      : undefined;
    message.receiving = (object.receiving !== undefined && object.receiving !== null)
      ? DecimalString.fromPartial(object.receiving)
      : undefined;
    message.pendingSending = (object.pendingSending !== undefined && object.pendingSending !== null)
      ? DecimalString.fromPartial(object.pendingSending)
      : undefined;
    message.pendingReceiving = (object.pendingReceiving !== undefined && object.pendingReceiving !== null)
      ? DecimalString.fromPartial(object.pendingReceiving)
      : undefined;
    message.unavailableSending = (object.unavailableSending !== undefined && object.unavailableSending !== null)
      ? DecimalString.fromPartial(object.unavailableSending)
      : undefined;
    message.unavailableReceiving = (object.unavailableReceiving !== undefined && object.unavailableReceiving !== null)
      ? DecimalString.fromPartial(object.unavailableReceiving)
      : undefined;
    message.inUseSending = (object.inUseSending !== undefined && object.inUseSending !== null)
      ? DecimalString.fromPartial(object.inUseSending)
      : undefined;
    message.inUseReceiving = (object.inUseReceiving !== undefined && object.inUseReceiving !== null)
      ? DecimalString.fromPartial(object.inUseReceiving)
      : undefined;
    return message;
  },
};

function createBaseLiquidityPosition(): LiquidityPosition {
  return {
    clientPubkey: new Uint8Array(0),
    minBuyPrice: undefined,
    quoteAmount: undefined,
    maxBuyPrice: undefined,
    inactiveQuoteAmount: undefined,
    highestBuyPrice: undefined,
    lowestSellPrice: undefined,
    inactiveBaseAmount: undefined,
    minSellPrice: undefined,
    baseAmount: undefined,
    maxSellPrice: undefined,
    removeOnFill: false,
  };
}

export const LiquidityPosition: MessageFns<LiquidityPosition> = {
  encode(message: LiquidityPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientPubkey.length !== 0) {
      writer.uint32(10).bytes(message.clientPubkey);
    }
    if (message.minBuyPrice !== undefined) {
      DecimalString.encode(message.minBuyPrice, writer.uint32(18).fork()).join();
    }
    if (message.quoteAmount !== undefined) {
      DecimalString.encode(message.quoteAmount, writer.uint32(26).fork()).join();
    }
    if (message.maxBuyPrice !== undefined) {
      DecimalString.encode(message.maxBuyPrice, writer.uint32(34).fork()).join();
    }
    if (message.inactiveQuoteAmount !== undefined) {
      DecimalString.encode(message.inactiveQuoteAmount, writer.uint32(42).fork()).join();
    }
    if (message.highestBuyPrice !== undefined) {
      DecimalString.encode(message.highestBuyPrice, writer.uint32(50).fork()).join();
    }
    if (message.lowestSellPrice !== undefined) {
      DecimalString.encode(message.lowestSellPrice, writer.uint32(58).fork()).join();
    }
    if (message.inactiveBaseAmount !== undefined) {
      DecimalString.encode(message.inactiveBaseAmount, writer.uint32(66).fork()).join();
    }
    if (message.minSellPrice !== undefined) {
      DecimalString.encode(message.minSellPrice, writer.uint32(74).fork()).join();
    }
    if (message.baseAmount !== undefined) {
      DecimalString.encode(message.baseAmount, writer.uint32(82).fork()).join();
    }
    if (message.maxSellPrice !== undefined) {
      DecimalString.encode(message.maxSellPrice, writer.uint32(90).fork()).join();
    }
    if (message.removeOnFill !== false) {
      writer.uint32(96).bool(message.removeOnFill);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiquidityPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiquidityPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientPubkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.minBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inactiveQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.highestBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lowestSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inactiveBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.minSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.baseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.maxSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.removeOnFill = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiquidityPosition {
    return {
      clientPubkey: isSet(object.clientPubkey) ? bytesFromBase64(object.clientPubkey) : new Uint8Array(0),
      minBuyPrice: isSet(object.minBuyPrice) ? DecimalString.fromJSON(object.minBuyPrice) : undefined,
      quoteAmount: isSet(object.quoteAmount) ? DecimalString.fromJSON(object.quoteAmount) : undefined,
      maxBuyPrice: isSet(object.maxBuyPrice) ? DecimalString.fromJSON(object.maxBuyPrice) : undefined,
      inactiveQuoteAmount: isSet(object.inactiveQuoteAmount)
        ? DecimalString.fromJSON(object.inactiveQuoteAmount)
        : undefined,
      highestBuyPrice: isSet(object.highestBuyPrice) ? DecimalString.fromJSON(object.highestBuyPrice) : undefined,
      lowestSellPrice: isSet(object.lowestSellPrice) ? DecimalString.fromJSON(object.lowestSellPrice) : undefined,
      inactiveBaseAmount: isSet(object.inactiveBaseAmount)
        ? DecimalString.fromJSON(object.inactiveBaseAmount)
        : undefined,
      minSellPrice: isSet(object.minSellPrice) ? DecimalString.fromJSON(object.minSellPrice) : undefined,
      baseAmount: isSet(object.baseAmount) ? DecimalString.fromJSON(object.baseAmount) : undefined,
      maxSellPrice: isSet(object.maxSellPrice) ? DecimalString.fromJSON(object.maxSellPrice) : undefined,
      removeOnFill: isSet(object.removeOnFill) ? globalThis.Boolean(object.removeOnFill) : false,
    };
  },

  toJSON(message: LiquidityPosition): unknown {
    const obj: any = {};
    if (message.clientPubkey.length !== 0) {
      obj.clientPubkey = base64FromBytes(message.clientPubkey);
    }
    if (message.minBuyPrice !== undefined) {
      obj.minBuyPrice = DecimalString.toJSON(message.minBuyPrice);
    }
    if (message.quoteAmount !== undefined) {
      obj.quoteAmount = DecimalString.toJSON(message.quoteAmount);
    }
    if (message.maxBuyPrice !== undefined) {
      obj.maxBuyPrice = DecimalString.toJSON(message.maxBuyPrice);
    }
    if (message.inactiveQuoteAmount !== undefined) {
      obj.inactiveQuoteAmount = DecimalString.toJSON(message.inactiveQuoteAmount);
    }
    if (message.highestBuyPrice !== undefined) {
      obj.highestBuyPrice = DecimalString.toJSON(message.highestBuyPrice);
    }
    if (message.lowestSellPrice !== undefined) {
      obj.lowestSellPrice = DecimalString.toJSON(message.lowestSellPrice);
    }
    if (message.inactiveBaseAmount !== undefined) {
      obj.inactiveBaseAmount = DecimalString.toJSON(message.inactiveBaseAmount);
    }
    if (message.minSellPrice !== undefined) {
      obj.minSellPrice = DecimalString.toJSON(message.minSellPrice);
    }
    if (message.baseAmount !== undefined) {
      obj.baseAmount = DecimalString.toJSON(message.baseAmount);
    }
    if (message.maxSellPrice !== undefined) {
      obj.maxSellPrice = DecimalString.toJSON(message.maxSellPrice);
    }
    if (message.removeOnFill !== false) {
      obj.removeOnFill = message.removeOnFill;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiquidityPosition>, I>>(base?: I): LiquidityPosition {
    return LiquidityPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiquidityPosition>, I>>(object: I): LiquidityPosition {
    const message = createBaseLiquidityPosition();
    message.clientPubkey = object.clientPubkey ?? new Uint8Array(0);
    message.minBuyPrice = (object.minBuyPrice !== undefined && object.minBuyPrice !== null)
      ? DecimalString.fromPartial(object.minBuyPrice)
      : undefined;
    message.quoteAmount = (object.quoteAmount !== undefined && object.quoteAmount !== null)
      ? DecimalString.fromPartial(object.quoteAmount)
      : undefined;
    message.maxBuyPrice = (object.maxBuyPrice !== undefined && object.maxBuyPrice !== null)
      ? DecimalString.fromPartial(object.maxBuyPrice)
      : undefined;
    message.inactiveQuoteAmount = (object.inactiveQuoteAmount !== undefined && object.inactiveQuoteAmount !== null)
      ? DecimalString.fromPartial(object.inactiveQuoteAmount)
      : undefined;
    message.highestBuyPrice = (object.highestBuyPrice !== undefined && object.highestBuyPrice !== null)
      ? DecimalString.fromPartial(object.highestBuyPrice)
      : undefined;
    message.lowestSellPrice = (object.lowestSellPrice !== undefined && object.lowestSellPrice !== null)
      ? DecimalString.fromPartial(object.lowestSellPrice)
      : undefined;
    message.inactiveBaseAmount = (object.inactiveBaseAmount !== undefined && object.inactiveBaseAmount !== null)
      ? DecimalString.fromPartial(object.inactiveBaseAmount)
      : undefined;
    message.minSellPrice = (object.minSellPrice !== undefined && object.minSellPrice !== null)
      ? DecimalString.fromPartial(object.minSellPrice)
      : undefined;
    message.baseAmount = (object.baseAmount !== undefined && object.baseAmount !== null)
      ? DecimalString.fromPartial(object.baseAmount)
      : undefined;
    message.maxSellPrice = (object.maxSellPrice !== undefined && object.maxSellPrice !== null)
      ? DecimalString.fromPartial(object.maxSellPrice)
      : undefined;
    message.removeOnFill = object.removeOnFill ?? false;
    return message;
  },
};

function createBaseOrderbook(): Orderbook {
  return { info: undefined, orders: {} };
}

export const Orderbook: MessageFns<Orderbook> = {
  encode(message: Orderbook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      MarketInfo.encode(message.info, writer.uint32(10).fork()).join();
    }
    Object.entries(message.orders).forEach(([key, value]) => {
      Orderbook_OrdersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Orderbook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = MarketInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Orderbook_OrdersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.orders[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Orderbook {
    return {
      info: isSet(object.info) ? MarketInfo.fromJSON(object.info) : undefined,
      orders: isObject(object.orders)
        ? Object.entries(object.orders).reduce<{ [key: string]: LiquidityPosition }>((acc, [key, value]) => {
          acc[key] = LiquidityPosition.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Orderbook): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = MarketInfo.toJSON(message.info);
    }
    if (message.orders) {
      const entries = Object.entries(message.orders);
      if (entries.length > 0) {
        obj.orders = {};
        entries.forEach(([k, v]) => {
          obj.orders[k] = LiquidityPosition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Orderbook>, I>>(base?: I): Orderbook {
    return Orderbook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Orderbook>, I>>(object: I): Orderbook {
    const message = createBaseOrderbook();
    message.info = (object.info !== undefined && object.info !== null)
      ? MarketInfo.fromPartial(object.info)
      : undefined;
    message.orders = Object.entries(object.orders ?? {}).reduce<{ [key: string]: LiquidityPosition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = LiquidityPosition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseOrderbook_OrdersEntry(): Orderbook_OrdersEntry {
  return { key: "", value: undefined };
}

export const Orderbook_OrdersEntry: MessageFns<Orderbook_OrdersEntry> = {
  encode(message: Orderbook_OrdersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LiquidityPosition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Orderbook_OrdersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbook_OrdersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LiquidityPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Orderbook_OrdersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LiquidityPosition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Orderbook_OrdersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LiquidityPosition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Orderbook_OrdersEntry>, I>>(base?: I): Orderbook_OrdersEntry {
    return Orderbook_OrdersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Orderbook_OrdersEntry>, I>>(object: I): Orderbook_OrdersEntry {
    const message = createBaseOrderbook_OrdersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LiquidityPosition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOrderVariant(): OrderVariant {
  return { addLiquidity: undefined, marketOrder: undefined, swapOrder: undefined };
}

export const OrderVariant: MessageFns<OrderVariant> = {
  encode(message: OrderVariant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addLiquidity !== undefined) {
      OrderVariant_AddLiquidity.encode(message.addLiquidity, writer.uint32(10).fork()).join();
    }
    if (message.marketOrder !== undefined) {
      OrderVariant_MarketOrder.encode(message.marketOrder, writer.uint32(18).fork()).join();
    }
    if (message.swapOrder !== undefined) {
      OrderVariant_SwapOrder.encode(message.swapOrder, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderVariant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addLiquidity = OrderVariant_AddLiquidity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.marketOrder = OrderVariant_MarketOrder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.swapOrder = OrderVariant_SwapOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderVariant {
    return {
      addLiquidity: isSet(object.addLiquidity) ? OrderVariant_AddLiquidity.fromJSON(object.addLiquidity) : undefined,
      marketOrder: isSet(object.marketOrder) ? OrderVariant_MarketOrder.fromJSON(object.marketOrder) : undefined,
      swapOrder: isSet(object.swapOrder) ? OrderVariant_SwapOrder.fromJSON(object.swapOrder) : undefined,
    };
  },

  toJSON(message: OrderVariant): unknown {
    const obj: any = {};
    if (message.addLiquidity !== undefined) {
      obj.addLiquidity = OrderVariant_AddLiquidity.toJSON(message.addLiquidity);
    }
    if (message.marketOrder !== undefined) {
      obj.marketOrder = OrderVariant_MarketOrder.toJSON(message.marketOrder);
    }
    if (message.swapOrder !== undefined) {
      obj.swapOrder = OrderVariant_SwapOrder.toJSON(message.swapOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderVariant>, I>>(base?: I): OrderVariant {
    return OrderVariant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderVariant>, I>>(object: I): OrderVariant {
    const message = createBaseOrderVariant();
    message.addLiquidity = (object.addLiquidity !== undefined && object.addLiquidity !== null)
      ? OrderVariant_AddLiquidity.fromPartial(object.addLiquidity)
      : undefined;
    message.marketOrder = (object.marketOrder !== undefined && object.marketOrder !== null)
      ? OrderVariant_MarketOrder.fromPartial(object.marketOrder)
      : undefined;
    message.swapOrder = (object.swapOrder !== undefined && object.swapOrder !== null)
      ? OrderVariant_SwapOrder.fromPartial(object.swapOrder)
      : undefined;
    return message;
  },
};

function createBaseOrderVariant_AddLiquidity(): OrderVariant_AddLiquidity {
  return {
    base: undefined,
    quote: undefined,
    minBuyPrice: undefined,
    midPrice: undefined,
    maxSellPrice: undefined,
    amount: undefined,
    removeOnFill: false,
  };
}

export const OrderVariant_AddLiquidity: MessageFns<OrderVariant_AddLiquidity> = {
  encode(message: OrderVariant_AddLiquidity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.minBuyPrice !== undefined) {
      DecimalString.encode(message.minBuyPrice, writer.uint32(26).fork()).join();
    }
    if (message.midPrice !== undefined) {
      DecimalString.encode(message.midPrice, writer.uint32(34).fork()).join();
    }
    if (message.maxSellPrice !== undefined) {
      DecimalString.encode(message.maxSellPrice, writer.uint32(42).fork()).join();
    }
    if (message.amount !== undefined) {
      OrderAmount.encode(message.amount, writer.uint32(50).fork()).join();
    }
    if (message.removeOnFill !== false) {
      writer.uint32(56).bool(message.removeOnFill);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderVariant_AddLiquidity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderVariant_AddLiquidity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.midPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = OrderAmount.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.removeOnFill = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderVariant_AddLiquidity {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      minBuyPrice: isSet(object.minBuyPrice) ? DecimalString.fromJSON(object.minBuyPrice) : undefined,
      midPrice: isSet(object.midPrice) ? DecimalString.fromJSON(object.midPrice) : undefined,
      maxSellPrice: isSet(object.maxSellPrice) ? DecimalString.fromJSON(object.maxSellPrice) : undefined,
      amount: isSet(object.amount) ? OrderAmount.fromJSON(object.amount) : undefined,
      removeOnFill: isSet(object.removeOnFill) ? globalThis.Boolean(object.removeOnFill) : false,
    };
  },

  toJSON(message: OrderVariant_AddLiquidity): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.minBuyPrice !== undefined) {
      obj.minBuyPrice = DecimalString.toJSON(message.minBuyPrice);
    }
    if (message.midPrice !== undefined) {
      obj.midPrice = DecimalString.toJSON(message.midPrice);
    }
    if (message.maxSellPrice !== undefined) {
      obj.maxSellPrice = DecimalString.toJSON(message.maxSellPrice);
    }
    if (message.amount !== undefined) {
      obj.amount = OrderAmount.toJSON(message.amount);
    }
    if (message.removeOnFill !== false) {
      obj.removeOnFill = message.removeOnFill;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderVariant_AddLiquidity>, I>>(base?: I): OrderVariant_AddLiquidity {
    return OrderVariant_AddLiquidity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderVariant_AddLiquidity>, I>>(object: I): OrderVariant_AddLiquidity {
    const message = createBaseOrderVariant_AddLiquidity();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.minBuyPrice = (object.minBuyPrice !== undefined && object.minBuyPrice !== null)
      ? DecimalString.fromPartial(object.minBuyPrice)
      : undefined;
    message.midPrice = (object.midPrice !== undefined && object.midPrice !== null)
      ? DecimalString.fromPartial(object.midPrice)
      : undefined;
    message.maxSellPrice = (object.maxSellPrice !== undefined && object.maxSellPrice !== null)
      ? DecimalString.fromPartial(object.maxSellPrice)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? OrderAmount.fromPartial(object.amount)
      : undefined;
    message.removeOnFill = object.removeOnFill ?? false;
    return message;
  },
};

function createBaseOrderVariant_MarketOrder(): OrderVariant_MarketOrder {
  return { base: undefined, quote: undefined, amount: undefined, side: 0 };
}

export const OrderVariant_MarketOrder: MessageFns<OrderVariant_MarketOrder> = {
  encode(message: OrderVariant_MarketOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.amount !== undefined) {
      OrderAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.side !== 0) {
      writer.uint32(32).int32(message.side);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderVariant_MarketOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderVariant_MarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = OrderAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderVariant_MarketOrder {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      amount: isSet(object.amount) ? OrderAmount.fromJSON(object.amount) : undefined,
      side: isSet(object.side) ? orderSideFromJSON(object.side) : 0,
    };
  },

  toJSON(message: OrderVariant_MarketOrder): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.amount !== undefined) {
      obj.amount = OrderAmount.toJSON(message.amount);
    }
    if (message.side !== 0) {
      obj.side = orderSideToJSON(message.side);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderVariant_MarketOrder>, I>>(base?: I): OrderVariant_MarketOrder {
    return OrderVariant_MarketOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderVariant_MarketOrder>, I>>(object: I): OrderVariant_MarketOrder {
    const message = createBaseOrderVariant_MarketOrder();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? OrderAmount.fromPartial(object.amount)
      : undefined;
    message.side = object.side ?? 0;
    return message;
  },
};

function createBaseOrderVariant_SwapOrder(): OrderVariant_SwapOrder {
  return { fromCurrency: undefined, currencyPath: [], toCurrency: undefined, amount: undefined };
}

export const OrderVariant_SwapOrder: MessageFns<OrderVariant_SwapOrder> = {
  encode(message: OrderVariant_SwapOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== undefined) {
      OrderbookCurrency.encode(message.fromCurrency, writer.uint32(10).fork()).join();
    }
    for (const v of message.currencyPath) {
      OrderbookCurrency.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.toCurrency !== undefined) {
      OrderbookCurrency.encode(message.toCurrency, writer.uint32(26).fork()).join();
    }
    if (message.amount !== undefined) {
      SwapAmount.encode(message.amount, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderVariant_SwapOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderVariant_SwapOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currencyPath.push(OrderbookCurrency.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderVariant_SwapOrder {
    return {
      fromCurrency: isSet(object.fromCurrency) ? OrderbookCurrency.fromJSON(object.fromCurrency) : undefined,
      currencyPath: globalThis.Array.isArray(object?.currencyPath)
        ? object.currencyPath.map((e: any) => OrderbookCurrency.fromJSON(e))
        : [],
      toCurrency: isSet(object.toCurrency) ? OrderbookCurrency.fromJSON(object.toCurrency) : undefined,
      amount: isSet(object.amount) ? SwapAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: OrderVariant_SwapOrder): unknown {
    const obj: any = {};
    if (message.fromCurrency !== undefined) {
      obj.fromCurrency = OrderbookCurrency.toJSON(message.fromCurrency);
    }
    if (message.currencyPath?.length) {
      obj.currencyPath = message.currencyPath.map((e) => OrderbookCurrency.toJSON(e));
    }
    if (message.toCurrency !== undefined) {
      obj.toCurrency = OrderbookCurrency.toJSON(message.toCurrency);
    }
    if (message.amount !== undefined) {
      obj.amount = SwapAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderVariant_SwapOrder>, I>>(base?: I): OrderVariant_SwapOrder {
    return OrderVariant_SwapOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderVariant_SwapOrder>, I>>(object: I): OrderVariant_SwapOrder {
    const message = createBaseOrderVariant_SwapOrder();
    message.fromCurrency = (object.fromCurrency !== undefined && object.fromCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.fromCurrency)
      : undefined;
    message.currencyPath = object.currencyPath?.map((e) => OrderbookCurrency.fromPartial(e)) || [];
    message.toCurrency = (object.toCurrency !== undefined && object.toCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.toCurrency)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? SwapAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseLiquidityOrder(): LiquidityOrder {
  return {
    base: undefined,
    quote: undefined,
    createdAt: undefined,
    minBuyPrice: undefined,
    maxBuyPrice: undefined,
    minSellPrice: undefined,
    maxSellPrice: undefined,
    remainingBaseAmount: undefined,
    remainingQuoteAmount: undefined,
    soldBaseAmount: undefined,
    boughtBaseAmount: undefined,
    soldQuoteAmount: undefined,
    boughtQuoteAmount: undefined,
    paidBaseFee: undefined,
    paidQuoteFee: undefined,
    removeOnFill: false,
  };
}

export const LiquidityOrder: MessageFns<LiquidityOrder> = {
  encode(message: LiquidityOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.minBuyPrice !== undefined) {
      DecimalString.encode(message.minBuyPrice, writer.uint32(34).fork()).join();
    }
    if (message.maxBuyPrice !== undefined) {
      DecimalString.encode(message.maxBuyPrice, writer.uint32(42).fork()).join();
    }
    if (message.minSellPrice !== undefined) {
      DecimalString.encode(message.minSellPrice, writer.uint32(50).fork()).join();
    }
    if (message.maxSellPrice !== undefined) {
      DecimalString.encode(message.maxSellPrice, writer.uint32(58).fork()).join();
    }
    if (message.remainingBaseAmount !== undefined) {
      DecimalString.encode(message.remainingBaseAmount, writer.uint32(66).fork()).join();
    }
    if (message.remainingQuoteAmount !== undefined) {
      DecimalString.encode(message.remainingQuoteAmount, writer.uint32(74).fork()).join();
    }
    if (message.soldBaseAmount !== undefined) {
      DecimalString.encode(message.soldBaseAmount, writer.uint32(82).fork()).join();
    }
    if (message.boughtBaseAmount !== undefined) {
      DecimalString.encode(message.boughtBaseAmount, writer.uint32(90).fork()).join();
    }
    if (message.soldQuoteAmount !== undefined) {
      DecimalString.encode(message.soldQuoteAmount, writer.uint32(98).fork()).join();
    }
    if (message.boughtQuoteAmount !== undefined) {
      DecimalString.encode(message.boughtQuoteAmount, writer.uint32(106).fork()).join();
    }
    if (message.paidBaseFee !== undefined) {
      DecimalString.encode(message.paidBaseFee, writer.uint32(114).fork()).join();
    }
    if (message.paidQuoteFee !== undefined) {
      DecimalString.encode(message.paidQuoteFee, writer.uint32(122).fork()).join();
    }
    if (message.removeOnFill !== false) {
      writer.uint32(128).bool(message.removeOnFill);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiquidityOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiquidityOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxBuyPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.minSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxSellPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.remainingBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.remainingQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.soldBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.boughtBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.soldQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.boughtQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.paidBaseFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.paidQuoteFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.removeOnFill = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiquidityOrder {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      minBuyPrice: isSet(object.minBuyPrice) ? DecimalString.fromJSON(object.minBuyPrice) : undefined,
      maxBuyPrice: isSet(object.maxBuyPrice) ? DecimalString.fromJSON(object.maxBuyPrice) : undefined,
      minSellPrice: isSet(object.minSellPrice) ? DecimalString.fromJSON(object.minSellPrice) : undefined,
      maxSellPrice: isSet(object.maxSellPrice) ? DecimalString.fromJSON(object.maxSellPrice) : undefined,
      remainingBaseAmount: isSet(object.remainingBaseAmount)
        ? DecimalString.fromJSON(object.remainingBaseAmount)
        : undefined,
      remainingQuoteAmount: isSet(object.remainingQuoteAmount)
        ? DecimalString.fromJSON(object.remainingQuoteAmount)
        : undefined,
      soldBaseAmount: isSet(object.soldBaseAmount) ? DecimalString.fromJSON(object.soldBaseAmount) : undefined,
      boughtBaseAmount: isSet(object.boughtBaseAmount) ? DecimalString.fromJSON(object.boughtBaseAmount) : undefined,
      soldQuoteAmount: isSet(object.soldQuoteAmount) ? DecimalString.fromJSON(object.soldQuoteAmount) : undefined,
      boughtQuoteAmount: isSet(object.boughtQuoteAmount) ? DecimalString.fromJSON(object.boughtQuoteAmount) : undefined,
      paidBaseFee: isSet(object.paidBaseFee) ? DecimalString.fromJSON(object.paidBaseFee) : undefined,
      paidQuoteFee: isSet(object.paidQuoteFee) ? DecimalString.fromJSON(object.paidQuoteFee) : undefined,
      removeOnFill: isSet(object.removeOnFill) ? globalThis.Boolean(object.removeOnFill) : false,
    };
  },

  toJSON(message: LiquidityOrder): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.minBuyPrice !== undefined) {
      obj.minBuyPrice = DecimalString.toJSON(message.minBuyPrice);
    }
    if (message.maxBuyPrice !== undefined) {
      obj.maxBuyPrice = DecimalString.toJSON(message.maxBuyPrice);
    }
    if (message.minSellPrice !== undefined) {
      obj.minSellPrice = DecimalString.toJSON(message.minSellPrice);
    }
    if (message.maxSellPrice !== undefined) {
      obj.maxSellPrice = DecimalString.toJSON(message.maxSellPrice);
    }
    if (message.remainingBaseAmount !== undefined) {
      obj.remainingBaseAmount = DecimalString.toJSON(message.remainingBaseAmount);
    }
    if (message.remainingQuoteAmount !== undefined) {
      obj.remainingQuoteAmount = DecimalString.toJSON(message.remainingQuoteAmount);
    }
    if (message.soldBaseAmount !== undefined) {
      obj.soldBaseAmount = DecimalString.toJSON(message.soldBaseAmount);
    }
    if (message.boughtBaseAmount !== undefined) {
      obj.boughtBaseAmount = DecimalString.toJSON(message.boughtBaseAmount);
    }
    if (message.soldQuoteAmount !== undefined) {
      obj.soldQuoteAmount = DecimalString.toJSON(message.soldQuoteAmount);
    }
    if (message.boughtQuoteAmount !== undefined) {
      obj.boughtQuoteAmount = DecimalString.toJSON(message.boughtQuoteAmount);
    }
    if (message.paidBaseFee !== undefined) {
      obj.paidBaseFee = DecimalString.toJSON(message.paidBaseFee);
    }
    if (message.paidQuoteFee !== undefined) {
      obj.paidQuoteFee = DecimalString.toJSON(message.paidQuoteFee);
    }
    if (message.removeOnFill !== false) {
      obj.removeOnFill = message.removeOnFill;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiquidityOrder>, I>>(base?: I): LiquidityOrder {
    return LiquidityOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiquidityOrder>, I>>(object: I): LiquidityOrder {
    const message = createBaseLiquidityOrder();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.minBuyPrice = (object.minBuyPrice !== undefined && object.minBuyPrice !== null)
      ? DecimalString.fromPartial(object.minBuyPrice)
      : undefined;
    message.maxBuyPrice = (object.maxBuyPrice !== undefined && object.maxBuyPrice !== null)
      ? DecimalString.fromPartial(object.maxBuyPrice)
      : undefined;
    message.minSellPrice = (object.minSellPrice !== undefined && object.minSellPrice !== null)
      ? DecimalString.fromPartial(object.minSellPrice)
      : undefined;
    message.maxSellPrice = (object.maxSellPrice !== undefined && object.maxSellPrice !== null)
      ? DecimalString.fromPartial(object.maxSellPrice)
      : undefined;
    message.remainingBaseAmount = (object.remainingBaseAmount !== undefined && object.remainingBaseAmount !== null)
      ? DecimalString.fromPartial(object.remainingBaseAmount)
      : undefined;
    message.remainingQuoteAmount = (object.remainingQuoteAmount !== undefined && object.remainingQuoteAmount !== null)
      ? DecimalString.fromPartial(object.remainingQuoteAmount)
      : undefined;
    message.soldBaseAmount = (object.soldBaseAmount !== undefined && object.soldBaseAmount !== null)
      ? DecimalString.fromPartial(object.soldBaseAmount)
      : undefined;
    message.boughtBaseAmount = (object.boughtBaseAmount !== undefined && object.boughtBaseAmount !== null)
      ? DecimalString.fromPartial(object.boughtBaseAmount)
      : undefined;
    message.soldQuoteAmount = (object.soldQuoteAmount !== undefined && object.soldQuoteAmount !== null)
      ? DecimalString.fromPartial(object.soldQuoteAmount)
      : undefined;
    message.boughtQuoteAmount = (object.boughtQuoteAmount !== undefined && object.boughtQuoteAmount !== null)
      ? DecimalString.fromPartial(object.boughtQuoteAmount)
      : undefined;
    message.paidBaseFee = (object.paidBaseFee !== undefined && object.paidBaseFee !== null)
      ? DecimalString.fromPartial(object.paidBaseFee)
      : undefined;
    message.paidQuoteFee = (object.paidQuoteFee !== undefined && object.paidQuoteFee !== null)
      ? DecimalString.fromPartial(object.paidQuoteFee)
      : undefined;
    message.removeOnFill = object.removeOnFill ?? false;
    return message;
  },
};

function createBaseMarketOrder(): MarketOrder {
  return {
    base: undefined,
    quote: undefined,
    createdAt: undefined,
    remainingAmount: undefined,
    unmatchedAmount: undefined,
    failedAmount: undefined,
    buy: undefined,
    sell: undefined,
  };
}

export const MarketOrder: MessageFns<MarketOrder> = {
  encode(message: MarketOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.remainingAmount !== undefined) {
      OrderAmount.encode(message.remainingAmount, writer.uint32(34).fork()).join();
    }
    if (message.unmatchedAmount !== undefined) {
      OrderAmount.encode(message.unmatchedAmount, writer.uint32(42).fork()).join();
    }
    if (message.failedAmount !== undefined) {
      OrderAmount.encode(message.failedAmount, writer.uint32(50).fork()).join();
    }
    if (message.buy !== undefined) {
      MarketOrder_Buy.encode(message.buy, writer.uint32(58).fork()).join();
    }
    if (message.sell !== undefined) {
      MarketOrder_Sell.encode(message.sell, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remainingAmount = OrderAmount.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unmatchedAmount = OrderAmount.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.failedAmount = OrderAmount.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.buy = MarketOrder_Buy.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sell = MarketOrder_Sell.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketOrder {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      remainingAmount: isSet(object.remainingAmount) ? OrderAmount.fromJSON(object.remainingAmount) : undefined,
      unmatchedAmount: isSet(object.unmatchedAmount) ? OrderAmount.fromJSON(object.unmatchedAmount) : undefined,
      failedAmount: isSet(object.failedAmount) ? OrderAmount.fromJSON(object.failedAmount) : undefined,
      buy: isSet(object.buy) ? MarketOrder_Buy.fromJSON(object.buy) : undefined,
      sell: isSet(object.sell) ? MarketOrder_Sell.fromJSON(object.sell) : undefined,
    };
  },

  toJSON(message: MarketOrder): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.remainingAmount !== undefined) {
      obj.remainingAmount = OrderAmount.toJSON(message.remainingAmount);
    }
    if (message.unmatchedAmount !== undefined) {
      obj.unmatchedAmount = OrderAmount.toJSON(message.unmatchedAmount);
    }
    if (message.failedAmount !== undefined) {
      obj.failedAmount = OrderAmount.toJSON(message.failedAmount);
    }
    if (message.buy !== undefined) {
      obj.buy = MarketOrder_Buy.toJSON(message.buy);
    }
    if (message.sell !== undefined) {
      obj.sell = MarketOrder_Sell.toJSON(message.sell);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrder>, I>>(base?: I): MarketOrder {
    return MarketOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrder>, I>>(object: I): MarketOrder {
    const message = createBaseMarketOrder();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.remainingAmount = (object.remainingAmount !== undefined && object.remainingAmount !== null)
      ? OrderAmount.fromPartial(object.remainingAmount)
      : undefined;
    message.unmatchedAmount = (object.unmatchedAmount !== undefined && object.unmatchedAmount !== null)
      ? OrderAmount.fromPartial(object.unmatchedAmount)
      : undefined;
    message.failedAmount = (object.failedAmount !== undefined && object.failedAmount !== null)
      ? OrderAmount.fromPartial(object.failedAmount)
      : undefined;
    message.buy = (object.buy !== undefined && object.buy !== null)
      ? MarketOrder_Buy.fromPartial(object.buy)
      : undefined;
    message.sell = (object.sell !== undefined && object.sell !== null)
      ? MarketOrder_Sell.fromPartial(object.sell)
      : undefined;
    return message;
  },
};

function createBaseMarketOrder_Buy(): MarketOrder_Buy {
  return { boughtBaseAmount: undefined, soldQuoteAmount: undefined, paidBaseFee: undefined };
}

export const MarketOrder_Buy: MessageFns<MarketOrder_Buy> = {
  encode(message: MarketOrder_Buy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boughtBaseAmount !== undefined) {
      DecimalString.encode(message.boughtBaseAmount, writer.uint32(10).fork()).join();
    }
    if (message.soldQuoteAmount !== undefined) {
      DecimalString.encode(message.soldQuoteAmount, writer.uint32(18).fork()).join();
    }
    if (message.paidBaseFee !== undefined) {
      DecimalString.encode(message.paidBaseFee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketOrder_Buy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrder_Buy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.boughtBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.soldQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paidBaseFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketOrder_Buy {
    return {
      boughtBaseAmount: isSet(object.boughtBaseAmount) ? DecimalString.fromJSON(object.boughtBaseAmount) : undefined,
      soldQuoteAmount: isSet(object.soldQuoteAmount) ? DecimalString.fromJSON(object.soldQuoteAmount) : undefined,
      paidBaseFee: isSet(object.paidBaseFee) ? DecimalString.fromJSON(object.paidBaseFee) : undefined,
    };
  },

  toJSON(message: MarketOrder_Buy): unknown {
    const obj: any = {};
    if (message.boughtBaseAmount !== undefined) {
      obj.boughtBaseAmount = DecimalString.toJSON(message.boughtBaseAmount);
    }
    if (message.soldQuoteAmount !== undefined) {
      obj.soldQuoteAmount = DecimalString.toJSON(message.soldQuoteAmount);
    }
    if (message.paidBaseFee !== undefined) {
      obj.paidBaseFee = DecimalString.toJSON(message.paidBaseFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrder_Buy>, I>>(base?: I): MarketOrder_Buy {
    return MarketOrder_Buy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrder_Buy>, I>>(object: I): MarketOrder_Buy {
    const message = createBaseMarketOrder_Buy();
    message.boughtBaseAmount = (object.boughtBaseAmount !== undefined && object.boughtBaseAmount !== null)
      ? DecimalString.fromPartial(object.boughtBaseAmount)
      : undefined;
    message.soldQuoteAmount = (object.soldQuoteAmount !== undefined && object.soldQuoteAmount !== null)
      ? DecimalString.fromPartial(object.soldQuoteAmount)
      : undefined;
    message.paidBaseFee = (object.paidBaseFee !== undefined && object.paidBaseFee !== null)
      ? DecimalString.fromPartial(object.paidBaseFee)
      : undefined;
    return message;
  },
};

function createBaseMarketOrder_Sell(): MarketOrder_Sell {
  return { soldBaseAmount: undefined, boughtQuoteAmount: undefined, paidQuoteFee: undefined };
}

export const MarketOrder_Sell: MessageFns<MarketOrder_Sell> = {
  encode(message: MarketOrder_Sell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soldBaseAmount !== undefined) {
      DecimalString.encode(message.soldBaseAmount, writer.uint32(10).fork()).join();
    }
    if (message.boughtQuoteAmount !== undefined) {
      DecimalString.encode(message.boughtQuoteAmount, writer.uint32(18).fork()).join();
    }
    if (message.paidQuoteFee !== undefined) {
      DecimalString.encode(message.paidQuoteFee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketOrder_Sell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrder_Sell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.soldBaseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.boughtQuoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paidQuoteFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketOrder_Sell {
    return {
      soldBaseAmount: isSet(object.soldBaseAmount) ? DecimalString.fromJSON(object.soldBaseAmount) : undefined,
      boughtQuoteAmount: isSet(object.boughtQuoteAmount) ? DecimalString.fromJSON(object.boughtQuoteAmount) : undefined,
      paidQuoteFee: isSet(object.paidQuoteFee) ? DecimalString.fromJSON(object.paidQuoteFee) : undefined,
    };
  },

  toJSON(message: MarketOrder_Sell): unknown {
    const obj: any = {};
    if (message.soldBaseAmount !== undefined) {
      obj.soldBaseAmount = DecimalString.toJSON(message.soldBaseAmount);
    }
    if (message.boughtQuoteAmount !== undefined) {
      obj.boughtQuoteAmount = DecimalString.toJSON(message.boughtQuoteAmount);
    }
    if (message.paidQuoteFee !== undefined) {
      obj.paidQuoteFee = DecimalString.toJSON(message.paidQuoteFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrder_Sell>, I>>(base?: I): MarketOrder_Sell {
    return MarketOrder_Sell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrder_Sell>, I>>(object: I): MarketOrder_Sell {
    const message = createBaseMarketOrder_Sell();
    message.soldBaseAmount = (object.soldBaseAmount !== undefined && object.soldBaseAmount !== null)
      ? DecimalString.fromPartial(object.soldBaseAmount)
      : undefined;
    message.boughtQuoteAmount = (object.boughtQuoteAmount !== undefined && object.boughtQuoteAmount !== null)
      ? DecimalString.fromPartial(object.boughtQuoteAmount)
      : undefined;
    message.paidQuoteFee = (object.paidQuoteFee !== undefined && object.paidQuoteFee !== null)
      ? DecimalString.fromPartial(object.paidQuoteFee)
      : undefined;
    return message;
  },
};

function createBasePairOrder(): PairOrder {
  return { liquidityOrder: undefined, marketOrder: undefined };
}

export const PairOrder: MessageFns<PairOrder> = {
  encode(message: PairOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liquidityOrder !== undefined) {
      LiquidityOrder.encode(message.liquidityOrder, writer.uint32(10).fork()).join();
    }
    if (message.marketOrder !== undefined) {
      MarketOrder.encode(message.marketOrder, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.liquidityOrder = LiquidityOrder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.marketOrder = MarketOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairOrder {
    return {
      liquidityOrder: isSet(object.liquidityOrder) ? LiquidityOrder.fromJSON(object.liquidityOrder) : undefined,
      marketOrder: isSet(object.marketOrder) ? MarketOrder.fromJSON(object.marketOrder) : undefined,
    };
  },

  toJSON(message: PairOrder): unknown {
    const obj: any = {};
    if (message.liquidityOrder !== undefined) {
      obj.liquidityOrder = LiquidityOrder.toJSON(message.liquidityOrder);
    }
    if (message.marketOrder !== undefined) {
      obj.marketOrder = MarketOrder.toJSON(message.marketOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PairOrder>, I>>(base?: I): PairOrder {
    return PairOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PairOrder>, I>>(object: I): PairOrder {
    const message = createBasePairOrder();
    message.liquidityOrder = (object.liquidityOrder !== undefined && object.liquidityOrder !== null)
      ? LiquidityOrder.fromPartial(object.liquidityOrder)
      : undefined;
    message.marketOrder = (object.marketOrder !== undefined && object.marketOrder !== null)
      ? MarketOrder.fromPartial(object.marketOrder)
      : undefined;
    return message;
  },
};

function createBaseSwapOrder(): SwapOrder {
  return {
    fromCurrency: undefined,
    currencyPath: [],
    toCurrency: undefined,
    createdAt: undefined,
    remainingAmount: undefined,
    unmatchedAmount: undefined,
    failedAmount: undefined,
    soldFromCurrencyAmount: undefined,
    boughtToCurrencyAmount: undefined,
    paidToCurrencyFee: undefined,
  };
}

export const SwapOrder: MessageFns<SwapOrder> = {
  encode(message: SwapOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== undefined) {
      OrderbookCurrency.encode(message.fromCurrency, writer.uint32(10).fork()).join();
    }
    for (const v of message.currencyPath) {
      OrderbookCurrency.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.toCurrency !== undefined) {
      OrderbookCurrency.encode(message.toCurrency, writer.uint32(26).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.remainingAmount !== undefined) {
      SwapAmount.encode(message.remainingAmount, writer.uint32(42).fork()).join();
    }
    if (message.unmatchedAmount !== undefined) {
      SwapAmount.encode(message.unmatchedAmount, writer.uint32(50).fork()).join();
    }
    if (message.failedAmount !== undefined) {
      SwapAmount.encode(message.failedAmount, writer.uint32(58).fork()).join();
    }
    if (message.soldFromCurrencyAmount !== undefined) {
      DecimalString.encode(message.soldFromCurrencyAmount, writer.uint32(66).fork()).join();
    }
    if (message.boughtToCurrencyAmount !== undefined) {
      DecimalString.encode(message.boughtToCurrencyAmount, writer.uint32(74).fork()).join();
    }
    if (message.paidToCurrencyFee !== undefined) {
      DecimalString.encode(message.paidToCurrencyFee, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currencyPath.push(OrderbookCurrency.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remainingAmount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unmatchedAmount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.failedAmount = SwapAmount.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.soldFromCurrencyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.boughtToCurrencyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.paidToCurrencyFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapOrder {
    return {
      fromCurrency: isSet(object.fromCurrency) ? OrderbookCurrency.fromJSON(object.fromCurrency) : undefined,
      currencyPath: globalThis.Array.isArray(object?.currencyPath)
        ? object.currencyPath.map((e: any) => OrderbookCurrency.fromJSON(e))
        : [],
      toCurrency: isSet(object.toCurrency) ? OrderbookCurrency.fromJSON(object.toCurrency) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      remainingAmount: isSet(object.remainingAmount) ? SwapAmount.fromJSON(object.remainingAmount) : undefined,
      unmatchedAmount: isSet(object.unmatchedAmount) ? SwapAmount.fromJSON(object.unmatchedAmount) : undefined,
      failedAmount: isSet(object.failedAmount) ? SwapAmount.fromJSON(object.failedAmount) : undefined,
      soldFromCurrencyAmount: isSet(object.soldFromCurrencyAmount)
        ? DecimalString.fromJSON(object.soldFromCurrencyAmount)
        : undefined,
      boughtToCurrencyAmount: isSet(object.boughtToCurrencyAmount)
        ? DecimalString.fromJSON(object.boughtToCurrencyAmount)
        : undefined,
      paidToCurrencyFee: isSet(object.paidToCurrencyFee) ? DecimalString.fromJSON(object.paidToCurrencyFee) : undefined,
    };
  },

  toJSON(message: SwapOrder): unknown {
    const obj: any = {};
    if (message.fromCurrency !== undefined) {
      obj.fromCurrency = OrderbookCurrency.toJSON(message.fromCurrency);
    }
    if (message.currencyPath?.length) {
      obj.currencyPath = message.currencyPath.map((e) => OrderbookCurrency.toJSON(e));
    }
    if (message.toCurrency !== undefined) {
      obj.toCurrency = OrderbookCurrency.toJSON(message.toCurrency);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.remainingAmount !== undefined) {
      obj.remainingAmount = SwapAmount.toJSON(message.remainingAmount);
    }
    if (message.unmatchedAmount !== undefined) {
      obj.unmatchedAmount = SwapAmount.toJSON(message.unmatchedAmount);
    }
    if (message.failedAmount !== undefined) {
      obj.failedAmount = SwapAmount.toJSON(message.failedAmount);
    }
    if (message.soldFromCurrencyAmount !== undefined) {
      obj.soldFromCurrencyAmount = DecimalString.toJSON(message.soldFromCurrencyAmount);
    }
    if (message.boughtToCurrencyAmount !== undefined) {
      obj.boughtToCurrencyAmount = DecimalString.toJSON(message.boughtToCurrencyAmount);
    }
    if (message.paidToCurrencyFee !== undefined) {
      obj.paidToCurrencyFee = DecimalString.toJSON(message.paidToCurrencyFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapOrder>, I>>(base?: I): SwapOrder {
    return SwapOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapOrder>, I>>(object: I): SwapOrder {
    const message = createBaseSwapOrder();
    message.fromCurrency = (object.fromCurrency !== undefined && object.fromCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.fromCurrency)
      : undefined;
    message.currencyPath = object.currencyPath?.map((e) => OrderbookCurrency.fromPartial(e)) || [];
    message.toCurrency = (object.toCurrency !== undefined && object.toCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.toCurrency)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.remainingAmount = (object.remainingAmount !== undefined && object.remainingAmount !== null)
      ? SwapAmount.fromPartial(object.remainingAmount)
      : undefined;
    message.unmatchedAmount = (object.unmatchedAmount !== undefined && object.unmatchedAmount !== null)
      ? SwapAmount.fromPartial(object.unmatchedAmount)
      : undefined;
    message.failedAmount = (object.failedAmount !== undefined && object.failedAmount !== null)
      ? SwapAmount.fromPartial(object.failedAmount)
      : undefined;
    message.soldFromCurrencyAmount =
      (object.soldFromCurrencyAmount !== undefined && object.soldFromCurrencyAmount !== null)
        ? DecimalString.fromPartial(object.soldFromCurrencyAmount)
        : undefined;
    message.boughtToCurrencyAmount =
      (object.boughtToCurrencyAmount !== undefined && object.boughtToCurrencyAmount !== null)
        ? DecimalString.fromPartial(object.boughtToCurrencyAmount)
        : undefined;
    message.paidToCurrencyFee = (object.paidToCurrencyFee !== undefined && object.paidToCurrencyFee !== null)
      ? DecimalString.fromPartial(object.paidToCurrencyFee)
      : undefined;
    return message;
  },
};

function createBaseOrder(): Order {
  return { pairOrder: undefined, swapOrder: undefined };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairOrder !== undefined) {
      PairOrder.encode(message.pairOrder, writer.uint32(10).fork()).join();
    }
    if (message.swapOrder !== undefined) {
      SwapOrder.encode(message.swapOrder, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairOrder = PairOrder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapOrder = SwapOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      pairOrder: isSet(object.pairOrder) ? PairOrder.fromJSON(object.pairOrder) : undefined,
      swapOrder: isSet(object.swapOrder) ? SwapOrder.fromJSON(object.swapOrder) : undefined,
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.pairOrder !== undefined) {
      obj.pairOrder = PairOrder.toJSON(message.pairOrder);
    }
    if (message.swapOrder !== undefined) {
      obj.swapOrder = SwapOrder.toJSON(message.swapOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.pairOrder = (object.pairOrder !== undefined && object.pairOrder !== null)
      ? PairOrder.fromPartial(object.pairOrder)
      : undefined;
    message.swapOrder = (object.swapOrder !== undefined && object.swapOrder !== null)
      ? SwapOrder.fromPartial(object.swapOrder)
      : undefined;
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    takerOrderId: "",
    baseAmount: undefined,
    quoteAmount: undefined,
    price: undefined,
    finalPrice: undefined,
    timestamp: undefined,
    makerOrderSide: 0,
  };
}

export const Trade: MessageFns<Trade> = {
  encode(message: Trade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.takerOrderId !== "") {
      writer.uint32(10).string(message.takerOrderId);
    }
    if (message.baseAmount !== undefined) {
      DecimalString.encode(message.baseAmount, writer.uint32(18).fork()).join();
    }
    if (message.quoteAmount !== undefined) {
      DecimalString.encode(message.quoteAmount, writer.uint32(26).fork()).join();
    }
    if (message.price !== undefined) {
      DecimalString.encode(message.price, writer.uint32(34).fork()).join();
    }
    if (message.finalPrice !== undefined) {
      DecimalString.encode(message.finalPrice, writer.uint32(42).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    if (message.makerOrderSide !== 0) {
      writer.uint32(56).int32(message.makerOrderSide);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.takerOrderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.price = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.finalPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.makerOrderSide = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      takerOrderId: isSet(object.takerOrderId) ? globalThis.String(object.takerOrderId) : "",
      baseAmount: isSet(object.baseAmount) ? DecimalString.fromJSON(object.baseAmount) : undefined,
      quoteAmount: isSet(object.quoteAmount) ? DecimalString.fromJSON(object.quoteAmount) : undefined,
      price: isSet(object.price) ? DecimalString.fromJSON(object.price) : undefined,
      finalPrice: isSet(object.finalPrice) ? DecimalString.fromJSON(object.finalPrice) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      makerOrderSide: isSet(object.makerOrderSide) ? orderSideFromJSON(object.makerOrderSide) : 0,
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.takerOrderId !== "") {
      obj.takerOrderId = message.takerOrderId;
    }
    if (message.baseAmount !== undefined) {
      obj.baseAmount = DecimalString.toJSON(message.baseAmount);
    }
    if (message.quoteAmount !== undefined) {
      obj.quoteAmount = DecimalString.toJSON(message.quoteAmount);
    }
    if (message.price !== undefined) {
      obj.price = DecimalString.toJSON(message.price);
    }
    if (message.finalPrice !== undefined) {
      obj.finalPrice = DecimalString.toJSON(message.finalPrice);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.makerOrderSide !== 0) {
      obj.makerOrderSide = orderSideToJSON(message.makerOrderSide);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trade>, I>>(base?: I): Trade {
    return Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trade>, I>>(object: I): Trade {
    const message = createBaseTrade();
    message.takerOrderId = object.takerOrderId ?? "";
    message.baseAmount = (object.baseAmount !== undefined && object.baseAmount !== null)
      ? DecimalString.fromPartial(object.baseAmount)
      : undefined;
    message.quoteAmount = (object.quoteAmount !== undefined && object.quoteAmount !== null)
      ? DecimalString.fromPartial(object.quoteAmount)
      : undefined;
    message.price = (object.price !== undefined && object.price !== null)
      ? DecimalString.fromPartial(object.price)
      : undefined;
    message.finalPrice = (object.finalPrice !== undefined && object.finalPrice !== null)
      ? DecimalString.fromPartial(object.finalPrice)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.makerOrderSide = object.makerOrderSide ?? 0;
    return message;
  },
};

function createBaseClientMarketTrade(): ClientMarketTrade {
  return {
    swapId: "",
    orderId: "",
    baseAmount: undefined,
    quoteAmount: undefined,
    baseFee: undefined,
    quoteFee: undefined,
    price: undefined,
    finalPrice: undefined,
    timestamp: undefined,
    orderSide: 0,
    orderType: 0,
  };
}

export const ClientMarketTrade: MessageFns<ClientMarketTrade> = {
  encode(message: ClientMarketTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.swapId !== "") {
      writer.uint32(10).string(message.swapId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.baseAmount !== undefined) {
      DecimalString.encode(message.baseAmount, writer.uint32(26).fork()).join();
    }
    if (message.quoteAmount !== undefined) {
      DecimalString.encode(message.quoteAmount, writer.uint32(34).fork()).join();
    }
    if (message.baseFee !== undefined) {
      DecimalString.encode(message.baseFee, writer.uint32(42).fork()).join();
    }
    if (message.quoteFee !== undefined) {
      DecimalString.encode(message.quoteFee, writer.uint32(50).fork()).join();
    }
    if (message.price !== undefined) {
      DecimalString.encode(message.price, writer.uint32(58).fork()).join();
    }
    if (message.finalPrice !== undefined) {
      DecimalString.encode(message.finalPrice, writer.uint32(66).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(74).fork()).join();
    }
    if (message.orderSide !== 0) {
      writer.uint32(80).int32(message.orderSide);
    }
    if (message.orderType !== 0) {
      writer.uint32(88).int32(message.orderType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMarketTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMarketTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.quoteAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.baseFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.quoteFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.price = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.finalPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.orderSide = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMarketTrade {
    return {
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      baseAmount: isSet(object.baseAmount) ? DecimalString.fromJSON(object.baseAmount) : undefined,
      quoteAmount: isSet(object.quoteAmount) ? DecimalString.fromJSON(object.quoteAmount) : undefined,
      baseFee: isSet(object.baseFee) ? DecimalString.fromJSON(object.baseFee) : undefined,
      quoteFee: isSet(object.quoteFee) ? DecimalString.fromJSON(object.quoteFee) : undefined,
      price: isSet(object.price) ? DecimalString.fromJSON(object.price) : undefined,
      finalPrice: isSet(object.finalPrice) ? DecimalString.fromJSON(object.finalPrice) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      orderSide: isSet(object.orderSide) ? orderSideFromJSON(object.orderSide) : 0,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
    };
  },

  toJSON(message: ClientMarketTrade): unknown {
    const obj: any = {};
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.baseAmount !== undefined) {
      obj.baseAmount = DecimalString.toJSON(message.baseAmount);
    }
    if (message.quoteAmount !== undefined) {
      obj.quoteAmount = DecimalString.toJSON(message.quoteAmount);
    }
    if (message.baseFee !== undefined) {
      obj.baseFee = DecimalString.toJSON(message.baseFee);
    }
    if (message.quoteFee !== undefined) {
      obj.quoteFee = DecimalString.toJSON(message.quoteFee);
    }
    if (message.price !== undefined) {
      obj.price = DecimalString.toJSON(message.price);
    }
    if (message.finalPrice !== undefined) {
      obj.finalPrice = DecimalString.toJSON(message.finalPrice);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.orderSide !== 0) {
      obj.orderSide = orderSideToJSON(message.orderSide);
    }
    if (message.orderType !== 0) {
      obj.orderType = orderTypeToJSON(message.orderType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMarketTrade>, I>>(base?: I): ClientMarketTrade {
    return ClientMarketTrade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMarketTrade>, I>>(object: I): ClientMarketTrade {
    const message = createBaseClientMarketTrade();
    message.swapId = object.swapId ?? "";
    message.orderId = object.orderId ?? "";
    message.baseAmount = (object.baseAmount !== undefined && object.baseAmount !== null)
      ? DecimalString.fromPartial(object.baseAmount)
      : undefined;
    message.quoteAmount = (object.quoteAmount !== undefined && object.quoteAmount !== null)
      ? DecimalString.fromPartial(object.quoteAmount)
      : undefined;
    message.baseFee = (object.baseFee !== undefined && object.baseFee !== null)
      ? DecimalString.fromPartial(object.baseFee)
      : undefined;
    message.quoteFee = (object.quoteFee !== undefined && object.quoteFee !== null)
      ? DecimalString.fromPartial(object.quoteFee)
      : undefined;
    message.price = (object.price !== undefined && object.price !== null)
      ? DecimalString.fromPartial(object.price)
      : undefined;
    message.finalPrice = (object.finalPrice !== undefined && object.finalPrice !== null)
      ? DecimalString.fromPartial(object.finalPrice)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.orderSide = object.orderSide ?? 0;
    message.orderType = object.orderType ?? 0;
    return message;
  },
};

function createBaseClientSwapTrade(): ClientSwapTrade {
  return {
    swapId: "",
    orderId: "",
    fromCurrencyAmount: undefined,
    toCurrencyAmount: undefined,
    toCurrencyFee: undefined,
    timestamp: undefined,
  };
}

export const ClientSwapTrade: MessageFns<ClientSwapTrade> = {
  encode(message: ClientSwapTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.swapId !== "") {
      writer.uint32(10).string(message.swapId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.fromCurrencyAmount !== undefined) {
      DecimalString.encode(message.fromCurrencyAmount, writer.uint32(26).fork()).join();
    }
    if (message.toCurrencyAmount !== undefined) {
      DecimalString.encode(message.toCurrencyAmount, writer.uint32(34).fork()).join();
    }
    if (message.toCurrencyFee !== undefined) {
      DecimalString.encode(message.toCurrencyFee, writer.uint32(42).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientSwapTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientSwapTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromCurrencyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toCurrencyAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toCurrencyFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientSwapTrade {
    return {
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      fromCurrencyAmount: isSet(object.fromCurrencyAmount)
        ? DecimalString.fromJSON(object.fromCurrencyAmount)
        : undefined,
      toCurrencyAmount: isSet(object.toCurrencyAmount) ? DecimalString.fromJSON(object.toCurrencyAmount) : undefined,
      toCurrencyFee: isSet(object.toCurrencyFee) ? DecimalString.fromJSON(object.toCurrencyFee) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: ClientSwapTrade): unknown {
    const obj: any = {};
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.fromCurrencyAmount !== undefined) {
      obj.fromCurrencyAmount = DecimalString.toJSON(message.fromCurrencyAmount);
    }
    if (message.toCurrencyAmount !== undefined) {
      obj.toCurrencyAmount = DecimalString.toJSON(message.toCurrencyAmount);
    }
    if (message.toCurrencyFee !== undefined) {
      obj.toCurrencyFee = DecimalString.toJSON(message.toCurrencyFee);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientSwapTrade>, I>>(base?: I): ClientSwapTrade {
    return ClientSwapTrade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientSwapTrade>, I>>(object: I): ClientSwapTrade {
    const message = createBaseClientSwapTrade();
    message.swapId = object.swapId ?? "";
    message.orderId = object.orderId ?? "";
    message.fromCurrencyAmount = (object.fromCurrencyAmount !== undefined && object.fromCurrencyAmount !== null)
      ? DecimalString.fromPartial(object.fromCurrencyAmount)
      : undefined;
    message.toCurrencyAmount = (object.toCurrencyAmount !== undefined && object.toCurrencyAmount !== null)
      ? DecimalString.fromPartial(object.toCurrencyAmount)
      : undefined;
    message.toCurrencyFee = (object.toCurrencyFee !== undefined && object.toCurrencyFee !== null)
      ? DecimalString.fromPartial(object.toCurrencyFee)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseInitMarketRequest(): InitMarketRequest {
  return { firstCurrency: undefined, otherCurrency: undefined };
}

export const InitMarketRequest: MessageFns<InitMarketRequest> = {
  encode(message: InitMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstCurrency !== undefined) {
      OrderbookCurrency.encode(message.firstCurrency, writer.uint32(10).fork()).join();
    }
    if (message.otherCurrency !== undefined) {
      OrderbookCurrency.encode(message.otherCurrency, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitMarketRequest {
    return {
      firstCurrency: isSet(object.firstCurrency) ? OrderbookCurrency.fromJSON(object.firstCurrency) : undefined,
      otherCurrency: isSet(object.otherCurrency) ? OrderbookCurrency.fromJSON(object.otherCurrency) : undefined,
    };
  },

  toJSON(message: InitMarketRequest): unknown {
    const obj: any = {};
    if (message.firstCurrency !== undefined) {
      obj.firstCurrency = OrderbookCurrency.toJSON(message.firstCurrency);
    }
    if (message.otherCurrency !== undefined) {
      obj.otherCurrency = OrderbookCurrency.toJSON(message.otherCurrency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitMarketRequest>, I>>(base?: I): InitMarketRequest {
    return InitMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitMarketRequest>, I>>(object: I): InitMarketRequest {
    const message = createBaseInitMarketRequest();
    message.firstCurrency = (object.firstCurrency !== undefined && object.firstCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.firstCurrency)
      : undefined;
    message.otherCurrency = (object.otherCurrency !== undefined && object.otherCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.otherCurrency)
      : undefined;
    return message;
  },
};

function createBaseInitMarketResponse(): InitMarketResponse {
  return { marketInfo: undefined };
}

export const InitMarketResponse: MessageFns<InitMarketResponse> = {
  encode(message: InitMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketInfo !== undefined) {
      MarketInfo.encode(message.marketInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketInfo = MarketInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitMarketResponse {
    return { marketInfo: isSet(object.marketInfo) ? MarketInfo.fromJSON(object.marketInfo) : undefined };
  },

  toJSON(message: InitMarketResponse): unknown {
    const obj: any = {};
    if (message.marketInfo !== undefined) {
      obj.marketInfo = MarketInfo.toJSON(message.marketInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitMarketResponse>, I>>(base?: I): InitMarketResponse {
    return InitMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitMarketResponse>, I>>(object: I): InitMarketResponse {
    const message = createBaseInitMarketResponse();
    message.marketInfo = (object.marketInfo !== undefined && object.marketInfo !== null)
      ? MarketInfo.fromPartial(object.marketInfo)
      : undefined;
    return message;
  },
};

function createBaseGetInitializedMarketsRequest(): GetInitializedMarketsRequest {
  return {};
}

export const GetInitializedMarketsRequest: MessageFns<GetInitializedMarketsRequest> = {
  encode(_: GetInitializedMarketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInitializedMarketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInitializedMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetInitializedMarketsRequest {
    return {};
  },

  toJSON(_: GetInitializedMarketsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInitializedMarketsRequest>, I>>(base?: I): GetInitializedMarketsRequest {
    return GetInitializedMarketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInitializedMarketsRequest>, I>>(_: I): GetInitializedMarketsRequest {
    const message = createBaseGetInitializedMarketsRequest();
    return message;
  },
};

function createBaseGetInitializedMarketsResponse(): GetInitializedMarketsResponse {
  return { markets: [] };
}

export const GetInitializedMarketsResponse: MessageFns<GetInitializedMarketsResponse> = {
  encode(message: GetInitializedMarketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markets) {
      CurrencyInfoPair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInitializedMarketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInitializedMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markets.push(CurrencyInfoPair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInitializedMarketsResponse {
    return {
      markets: globalThis.Array.isArray(object?.markets)
        ? object.markets.map((e: any) => CurrencyInfoPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetInitializedMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets?.length) {
      obj.markets = message.markets.map((e) => CurrencyInfoPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInitializedMarketsResponse>, I>>(base?: I): GetInitializedMarketsResponse {
    return GetInitializedMarketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInitializedMarketsResponse>, I>>(
    object: I,
  ): GetInitializedMarketsResponse {
    const message = createBaseGetInitializedMarketsResponse();
    message.markets = object.markets?.map((e) => CurrencyInfoPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMarketsInfoRequest(): GetMarketsInfoRequest {
  return {};
}

export const GetMarketsInfoRequest: MessageFns<GetMarketsInfoRequest> = {
  encode(_: GetMarketsInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketsInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketsInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMarketsInfoRequest {
    return {};
  },

  toJSON(_: GetMarketsInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketsInfoRequest>, I>>(base?: I): GetMarketsInfoRequest {
    return GetMarketsInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketsInfoRequest>, I>>(_: I): GetMarketsInfoRequest {
    const message = createBaseGetMarketsInfoRequest();
    return message;
  },
};

function createBaseGetMarketsInfoResponse(): GetMarketsInfoResponse {
  return { markets: [] };
}

export const GetMarketsInfoResponse: MessageFns<GetMarketsInfoResponse> = {
  encode(message: GetMarketsInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markets) {
      MarketInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketsInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketsInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markets.push(MarketInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketsInfoResponse {
    return {
      markets: globalThis.Array.isArray(object?.markets) ? object.markets.map((e: any) => MarketInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetMarketsInfoResponse): unknown {
    const obj: any = {};
    if (message.markets?.length) {
      obj.markets = message.markets.map((e) => MarketInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketsInfoResponse>, I>>(base?: I): GetMarketsInfoResponse {
    return GetMarketsInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketsInfoResponse>, I>>(object: I): GetMarketsInfoResponse {
    const message = createBaseGetMarketsInfoResponse();
    message.markets = object.markets?.map((e) => MarketInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMarketInfoRequest(): GetMarketInfoRequest {
  return { firstCurrency: undefined, otherCurrency: undefined };
}

export const GetMarketInfoRequest: MessageFns<GetMarketInfoRequest> = {
  encode(message: GetMarketInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstCurrency !== undefined) {
      OrderbookCurrency.encode(message.firstCurrency, writer.uint32(10).fork()).join();
    }
    if (message.otherCurrency !== undefined) {
      OrderbookCurrency.encode(message.otherCurrency, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketInfoRequest {
    return {
      firstCurrency: isSet(object.firstCurrency) ? OrderbookCurrency.fromJSON(object.firstCurrency) : undefined,
      otherCurrency: isSet(object.otherCurrency) ? OrderbookCurrency.fromJSON(object.otherCurrency) : undefined,
    };
  },

  toJSON(message: GetMarketInfoRequest): unknown {
    const obj: any = {};
    if (message.firstCurrency !== undefined) {
      obj.firstCurrency = OrderbookCurrency.toJSON(message.firstCurrency);
    }
    if (message.otherCurrency !== undefined) {
      obj.otherCurrency = OrderbookCurrency.toJSON(message.otherCurrency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketInfoRequest>, I>>(base?: I): GetMarketInfoRequest {
    return GetMarketInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketInfoRequest>, I>>(object: I): GetMarketInfoRequest {
    const message = createBaseGetMarketInfoRequest();
    message.firstCurrency = (object.firstCurrency !== undefined && object.firstCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.firstCurrency)
      : undefined;
    message.otherCurrency = (object.otherCurrency !== undefined && object.otherCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.otherCurrency)
      : undefined;
    return message;
  },
};

function createBaseGetMarketInfoResponse(): GetMarketInfoResponse {
  return { marketInfo: undefined };
}

export const GetMarketInfoResponse: MessageFns<GetMarketInfoResponse> = {
  encode(message: GetMarketInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketInfo !== undefined) {
      MarketInfo.encode(message.marketInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketInfo = MarketInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketInfoResponse {
    return { marketInfo: isSet(object.marketInfo) ? MarketInfo.fromJSON(object.marketInfo) : undefined };
  },

  toJSON(message: GetMarketInfoResponse): unknown {
    const obj: any = {};
    if (message.marketInfo !== undefined) {
      obj.marketInfo = MarketInfo.toJSON(message.marketInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketInfoResponse>, I>>(base?: I): GetMarketInfoResponse {
    return GetMarketInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketInfoResponse>, I>>(object: I): GetMarketInfoResponse {
    const message = createBaseGetMarketInfoResponse();
    message.marketInfo = (object.marketInfo !== undefined && object.marketInfo !== null)
      ? MarketInfo.fromPartial(object.marketInfo)
      : undefined;
    return message;
  },
};

function createBaseGetOrderbookBalancesRequest(): GetOrderbookBalancesRequest {
  return {};
}

export const GetOrderbookBalancesRequest: MessageFns<GetOrderbookBalancesRequest> = {
  encode(_: GetOrderbookBalancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderbookBalancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderbookBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetOrderbookBalancesRequest {
    return {};
  },

  toJSON(_: GetOrderbookBalancesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderbookBalancesRequest>, I>>(base?: I): GetOrderbookBalancesRequest {
    return GetOrderbookBalancesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderbookBalancesRequest>, I>>(_: I): GetOrderbookBalancesRequest {
    const message = createBaseGetOrderbookBalancesRequest();
    return message;
  },
};

function createBaseGetOrderbookBalancesResponse(): GetOrderbookBalancesResponse {
  return { balances: [] };
}

export const GetOrderbookBalancesResponse: MessageFns<GetOrderbookBalancesResponse> = {
  encode(message: GetOrderbookBalancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.balances) {
      OrderbookBalance.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderbookBalancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderbookBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances.push(OrderbookBalance.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderbookBalancesResponse {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => OrderbookBalance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetOrderbookBalancesResponse): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => OrderbookBalance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderbookBalancesResponse>, I>>(base?: I): GetOrderbookBalancesResponse {
    return GetOrderbookBalancesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderbookBalancesResponse>, I>>(object: I): GetOrderbookBalancesResponse {
    const message = createBaseGetOrderbookBalancesResponse();
    message.balances = object.balances?.map((e) => OrderbookBalance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOrderbookRequest(): GetOrderbookRequest {
  return { base: undefined, quote: undefined };
}

export const GetOrderbookRequest: MessageFns<GetOrderbookRequest> = {
  encode(message: GetOrderbookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderbookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderbookRequest {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: GetOrderbookRequest): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderbookRequest>, I>>(base?: I): GetOrderbookRequest {
    return GetOrderbookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderbookRequest>, I>>(object: I): GetOrderbookRequest {
    const message = createBaseGetOrderbookRequest();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseGetOrderbookResponse(): GetOrderbookResponse {
  return { orderbook: undefined };
}

export const GetOrderbookResponse: MessageFns<GetOrderbookResponse> = {
  encode(message: GetOrderbookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderbook !== undefined) {
      Orderbook.encode(message.orderbook, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderbookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderbook = Orderbook.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderbookResponse {
    return { orderbook: isSet(object.orderbook) ? Orderbook.fromJSON(object.orderbook) : undefined };
  },

  toJSON(message: GetOrderbookResponse): unknown {
    const obj: any = {};
    if (message.orderbook !== undefined) {
      obj.orderbook = Orderbook.toJSON(message.orderbook);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderbookResponse>, I>>(base?: I): GetOrderbookResponse {
    return GetOrderbookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderbookResponse>, I>>(object: I): GetOrderbookResponse {
    const message = createBaseGetOrderbookResponse();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? Orderbook.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseEstimateOrderRequest(): EstimateOrderRequest {
  return { orderVariant: undefined };
}

export const EstimateOrderRequest: MessageFns<EstimateOrderRequest> = {
  encode(message: EstimateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderVariant !== undefined) {
      OrderVariant.encode(message.orderVariant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderVariant = OrderVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateOrderRequest {
    return { orderVariant: isSet(object.orderVariant) ? OrderVariant.fromJSON(object.orderVariant) : undefined };
  },

  toJSON(message: EstimateOrderRequest): unknown {
    const obj: any = {};
    if (message.orderVariant !== undefined) {
      obj.orderVariant = OrderVariant.toJSON(message.orderVariant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateOrderRequest>, I>>(base?: I): EstimateOrderRequest {
    return EstimateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateOrderRequest>, I>>(object: I): EstimateOrderRequest {
    const message = createBaseEstimateOrderRequest();
    message.orderVariant = (object.orderVariant !== undefined && object.orderVariant !== null)
      ? OrderVariant.fromPartial(object.orderVariant)
      : undefined;
    return message;
  },
};

function createBaseEstimateOrderResponse(): EstimateOrderResponse {
  return { orderMatch: undefined };
}

export const EstimateOrderResponse: MessageFns<EstimateOrderResponse> = {
  encode(message: EstimateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderMatch !== undefined) {
      OrderMatch.encode(message.orderMatch, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderMatch = OrderMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateOrderResponse {
    return { orderMatch: isSet(object.orderMatch) ? OrderMatch.fromJSON(object.orderMatch) : undefined };
  },

  toJSON(message: EstimateOrderResponse): unknown {
    const obj: any = {};
    if (message.orderMatch !== undefined) {
      obj.orderMatch = OrderMatch.toJSON(message.orderMatch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateOrderResponse>, I>>(base?: I): EstimateOrderResponse {
    return EstimateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateOrderResponse>, I>>(object: I): EstimateOrderResponse {
    const message = createBaseEstimateOrderResponse();
    message.orderMatch = (object.orderMatch !== undefined && object.orderMatch !== null)
      ? OrderMatch.fromPartial(object.orderMatch)
      : undefined;
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return { orderVariant: undefined };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderVariant !== undefined) {
      OrderVariant.encode(message.orderVariant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderVariant = OrderVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return { orderVariant: isSet(object.orderVariant) ? OrderVariant.fromJSON(object.orderVariant) : undefined };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.orderVariant !== undefined) {
      obj.orderVariant = OrderVariant.toJSON(message.orderVariant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(base?: I): CreateOrderRequest {
    return CreateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(object: I): CreateOrderRequest {
    const message = createBaseCreateOrderRequest();
    message.orderVariant = (object.orderVariant !== undefined && object.orderVariant !== null)
      ? OrderVariant.fromPartial(object.orderVariant)
      : undefined;
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { orderId: "" };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(base?: I): CreateOrderResponse {
    return CreateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(object: I): CreateOrderResponse {
    const message = createBaseCreateOrderResponse();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { orderId: "" };
}

export const CancelOrderRequest: MessageFns<CancelOrderRequest> = {
  encode(message: CancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CancelOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(base?: I): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(object: I): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return { removed: false };
}

export const CancelOrderResponse: MessageFns<CancelOrderResponse> = {
  encode(message: CancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.removed !== false) {
      writer.uint32(8).bool(message.removed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.removed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderResponse {
    return { removed: isSet(object.removed) ? globalThis.Boolean(object.removed) : false };
  },

  toJSON(message: CancelOrderResponse): unknown {
    const obj: any = {};
    if (message.removed !== false) {
      obj.removed = message.removed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(base?: I): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(object: I): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    message.removed = object.removed ?? false;
    return message;
  },
};

function createBaseCancelAllOrdersRequest(): CancelAllOrdersRequest {
  return {};
}

export const CancelAllOrdersRequest: MessageFns<CancelAllOrdersRequest> = {
  encode(_: CancelAllOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelAllOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelAllOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelAllOrdersRequest {
    return {};
  },

  toJSON(_: CancelAllOrdersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelAllOrdersRequest>, I>>(base?: I): CancelAllOrdersRequest {
    return CancelAllOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelAllOrdersRequest>, I>>(_: I): CancelAllOrdersRequest {
    const message = createBaseCancelAllOrdersRequest();
    return message;
  },
};

function createBaseCancelAllOrdersResponse(): CancelAllOrdersResponse {
  return {};
}

export const CancelAllOrdersResponse: MessageFns<CancelAllOrdersResponse> = {
  encode(_: CancelAllOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelAllOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelAllOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelAllOrdersResponse {
    return {};
  },

  toJSON(_: CancelAllOrdersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelAllOrdersResponse>, I>>(base?: I): CancelAllOrdersResponse {
    return CancelAllOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelAllOrdersResponse>, I>>(_: I): CancelAllOrdersResponse {
    const message = createBaseCancelAllOrdersResponse();
    return message;
  },
};

function createBaseGetOwnOrdersRequest(): GetOwnOrdersRequest {
  return { base: undefined, quote: undefined };
}

export const GetOwnOrdersRequest: MessageFns<GetOwnOrdersRequest> = {
  encode(message: GetOwnOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOwnOrdersRequest {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: GetOwnOrdersRequest): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOwnOrdersRequest>, I>>(base?: I): GetOwnOrdersRequest {
    return GetOwnOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOwnOrdersRequest>, I>>(object: I): GetOwnOrdersRequest {
    const message = createBaseGetOwnOrdersRequest();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseGetOwnOrdersResponse(): GetOwnOrdersResponse {
  return { orders: {} };
}

export const GetOwnOrdersResponse: MessageFns<GetOwnOrdersResponse> = {
  encode(message: GetOwnOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.orders).forEach(([key, value]) => {
      GetOwnOrdersResponse_OrdersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetOwnOrdersResponse_OrdersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.orders[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOwnOrdersResponse {
    return {
      orders: isObject(object.orders)
        ? Object.entries(object.orders).reduce<{ [key: string]: Order }>((acc, [key, value]) => {
          acc[key] = Order.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetOwnOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      const entries = Object.entries(message.orders);
      if (entries.length > 0) {
        obj.orders = {};
        entries.forEach(([k, v]) => {
          obj.orders[k] = Order.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOwnOrdersResponse>, I>>(base?: I): GetOwnOrdersResponse {
    return GetOwnOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOwnOrdersResponse>, I>>(object: I): GetOwnOrdersResponse {
    const message = createBaseGetOwnOrdersResponse();
    message.orders = Object.entries(object.orders ?? {}).reduce<{ [key: string]: Order }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Order.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetOwnOrdersResponse_OrdersEntry(): GetOwnOrdersResponse_OrdersEntry {
  return { key: "", value: undefined };
}

export const GetOwnOrdersResponse_OrdersEntry: MessageFns<GetOwnOrdersResponse_OrdersEntry> = {
  encode(message: GetOwnOrdersResponse_OrdersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Order.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnOrdersResponse_OrdersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnOrdersResponse_OrdersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOwnOrdersResponse_OrdersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Order.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetOwnOrdersResponse_OrdersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Order.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOwnOrdersResponse_OrdersEntry>, I>>(
    base?: I,
  ): GetOwnOrdersResponse_OrdersEntry {
    return GetOwnOrdersResponse_OrdersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOwnOrdersResponse_OrdersEntry>, I>>(
    object: I,
  ): GetOwnOrdersResponse_OrdersEntry {
    const message = createBaseGetOwnOrdersResponse_OrdersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Order.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetAllOwnOrdersRequest(): GetAllOwnOrdersRequest {
  return {};
}

export const GetAllOwnOrdersRequest: MessageFns<GetAllOwnOrdersRequest> = {
  encode(_: GetAllOwnOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllOwnOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllOwnOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllOwnOrdersRequest {
    return {};
  },

  toJSON(_: GetAllOwnOrdersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllOwnOrdersRequest>, I>>(base?: I): GetAllOwnOrdersRequest {
    return GetAllOwnOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllOwnOrdersRequest>, I>>(_: I): GetAllOwnOrdersRequest {
    const message = createBaseGetAllOwnOrdersRequest();
    return message;
  },
};

function createBaseGetAllOwnOrdersResponse(): GetAllOwnOrdersResponse {
  return { orders: {} };
}

export const GetAllOwnOrdersResponse: MessageFns<GetAllOwnOrdersResponse> = {
  encode(message: GetAllOwnOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.orders).forEach(([key, value]) => {
      GetAllOwnOrdersResponse_OrdersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllOwnOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllOwnOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetAllOwnOrdersResponse_OrdersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.orders[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllOwnOrdersResponse {
    return {
      orders: isObject(object.orders)
        ? Object.entries(object.orders).reduce<{ [key: string]: Order }>((acc, [key, value]) => {
          acc[key] = Order.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetAllOwnOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      const entries = Object.entries(message.orders);
      if (entries.length > 0) {
        obj.orders = {};
        entries.forEach(([k, v]) => {
          obj.orders[k] = Order.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllOwnOrdersResponse>, I>>(base?: I): GetAllOwnOrdersResponse {
    return GetAllOwnOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllOwnOrdersResponse>, I>>(object: I): GetAllOwnOrdersResponse {
    const message = createBaseGetAllOwnOrdersResponse();
    message.orders = Object.entries(object.orders ?? {}).reduce<{ [key: string]: Order }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Order.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetAllOwnOrdersResponse_OrdersEntry(): GetAllOwnOrdersResponse_OrdersEntry {
  return { key: "", value: undefined };
}

export const GetAllOwnOrdersResponse_OrdersEntry: MessageFns<GetAllOwnOrdersResponse_OrdersEntry> = {
  encode(message: GetAllOwnOrdersResponse_OrdersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Order.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllOwnOrdersResponse_OrdersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllOwnOrdersResponse_OrdersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllOwnOrdersResponse_OrdersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Order.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetAllOwnOrdersResponse_OrdersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Order.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllOwnOrdersResponse_OrdersEntry>, I>>(
    base?: I,
  ): GetAllOwnOrdersResponse_OrdersEntry {
    return GetAllOwnOrdersResponse_OrdersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllOwnOrdersResponse_OrdersEntry>, I>>(
    object: I,
  ): GetAllOwnOrdersResponse_OrdersEntry {
    const message = createBaseGetAllOwnOrdersResponse_OrdersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Order.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetOrderRequest(): GetOrderRequest {
  return { orderId: "" };
}

export const GetOrderRequest: MessageFns<GetOrderRequest> = {
  encode(message: GetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderRequest>, I>>(base?: I): GetOrderRequest {
    return GetOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderRequest>, I>>(object: I): GetOrderRequest {
    const message = createBaseGetOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseGetOrderResponse(): GetOrderResponse {
  return { order: undefined };
}

export const GetOrderResponse: MessageFns<GetOrderResponse> = {
  encode(message: GetOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: GetOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderResponse>, I>>(base?: I): GetOrderResponse {
    return GetOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderResponse>, I>>(object: I): GetOrderResponse {
    const message = createBaseGetOrderResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseGetTradeHistoryRequest(): GetTradeHistoryRequest {
  return { base: undefined, quote: undefined };
}

export const GetTradeHistoryRequest: MessageFns<GetTradeHistoryRequest> = {
  encode(message: GetTradeHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradeHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradeHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradeHistoryRequest {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: GetTradeHistoryRequest): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradeHistoryRequest>, I>>(base?: I): GetTradeHistoryRequest {
    return GetTradeHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradeHistoryRequest>, I>>(object: I): GetTradeHistoryRequest {
    const message = createBaseGetTradeHistoryRequest();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseGetTradeHistoryResponse(): GetTradeHistoryResponse {
  return { tradeHistory: [] };
}

export const GetTradeHistoryResponse: MessageFns<GetTradeHistoryResponse> = {
  encode(message: GetTradeHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tradeHistory) {
      Trade.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradeHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradeHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeHistory.push(Trade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradeHistoryResponse {
    return {
      tradeHistory: globalThis.Array.isArray(object?.tradeHistory)
        ? object.tradeHistory.map((e: any) => Trade.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTradeHistoryResponse): unknown {
    const obj: any = {};
    if (message.tradeHistory?.length) {
      obj.tradeHistory = message.tradeHistory.map((e) => Trade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradeHistoryResponse>, I>>(base?: I): GetTradeHistoryResponse {
    return GetTradeHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradeHistoryResponse>, I>>(object: I): GetTradeHistoryResponse {
    const message = createBaseGetTradeHistoryResponse();
    message.tradeHistory = object.tradeHistory?.map((e) => Trade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllMarketTradesRequest(): GetAllMarketTradesRequest {
  return {};
}

export const GetAllMarketTradesRequest: MessageFns<GetAllMarketTradesRequest> = {
  encode(_: GetAllMarketTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllMarketTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllMarketTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllMarketTradesRequest {
    return {};
  },

  toJSON(_: GetAllMarketTradesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllMarketTradesRequest>, I>>(base?: I): GetAllMarketTradesRequest {
    return GetAllMarketTradesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllMarketTradesRequest>, I>>(_: I): GetAllMarketTradesRequest {
    const message = createBaseGetAllMarketTradesRequest();
    return message;
  },
};

function createBaseGetAllMarketTradesResponse(): GetAllMarketTradesResponse {
  return { pairMarketTrades: [] };
}

export const GetAllMarketTradesResponse: MessageFns<GetAllMarketTradesResponse> = {
  encode(message: GetAllMarketTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pairMarketTrades) {
      GetAllMarketTradesResponse_PairMarketTrades.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllMarketTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllMarketTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairMarketTrades.push(GetAllMarketTradesResponse_PairMarketTrades.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllMarketTradesResponse {
    return {
      pairMarketTrades: globalThis.Array.isArray(object?.pairMarketTrades)
        ? object.pairMarketTrades.map((e: any) => GetAllMarketTradesResponse_PairMarketTrades.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllMarketTradesResponse): unknown {
    const obj: any = {};
    if (message.pairMarketTrades?.length) {
      obj.pairMarketTrades = message.pairMarketTrades.map((e) => GetAllMarketTradesResponse_PairMarketTrades.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllMarketTradesResponse>, I>>(base?: I): GetAllMarketTradesResponse {
    return GetAllMarketTradesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllMarketTradesResponse>, I>>(object: I): GetAllMarketTradesResponse {
    const message = createBaseGetAllMarketTradesResponse();
    message.pairMarketTrades =
      object.pairMarketTrades?.map((e) => GetAllMarketTradesResponse_PairMarketTrades.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllMarketTradesResponse_PairMarketTrades(): GetAllMarketTradesResponse_PairMarketTrades {
  return { base: undefined, quote: undefined, trades: [] };
}

export const GetAllMarketTradesResponse_PairMarketTrades: MessageFns<GetAllMarketTradesResponse_PairMarketTrades> = {
  encode(
    message: GetAllMarketTradesResponse_PairMarketTrades,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    for (const v of message.trades) {
      ClientMarketTrade.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllMarketTradesResponse_PairMarketTrades {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllMarketTradesResponse_PairMarketTrades();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trades.push(ClientMarketTrade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllMarketTradesResponse_PairMarketTrades {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      trades: globalThis.Array.isArray(object?.trades)
        ? object.trades.map((e: any) => ClientMarketTrade.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllMarketTradesResponse_PairMarketTrades): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => ClientMarketTrade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllMarketTradesResponse_PairMarketTrades>, I>>(
    base?: I,
  ): GetAllMarketTradesResponse_PairMarketTrades {
    return GetAllMarketTradesResponse_PairMarketTrades.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllMarketTradesResponse_PairMarketTrades>, I>>(
    object: I,
  ): GetAllMarketTradesResponse_PairMarketTrades {
    const message = createBaseGetAllMarketTradesResponse_PairMarketTrades();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.trades = object.trades?.map((e) => ClientMarketTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPairMarketTradesRequest(): GetPairMarketTradesRequest {
  return { base: undefined, quote: undefined };
}

export const GetPairMarketTradesRequest: MessageFns<GetPairMarketTradesRequest> = {
  encode(message: GetPairMarketTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPairMarketTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPairMarketTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPairMarketTradesRequest {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: GetPairMarketTradesRequest): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPairMarketTradesRequest>, I>>(base?: I): GetPairMarketTradesRequest {
    return GetPairMarketTradesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPairMarketTradesRequest>, I>>(object: I): GetPairMarketTradesRequest {
    const message = createBaseGetPairMarketTradesRequest();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseGetPairMarketTradesResponse(): GetPairMarketTradesResponse {
  return { trades: [] };
}

export const GetPairMarketTradesResponse: MessageFns<GetPairMarketTradesResponse> = {
  encode(message: GetPairMarketTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trades) {
      ClientMarketTrade.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPairMarketTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPairMarketTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trades.push(ClientMarketTrade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPairMarketTradesResponse {
    return {
      trades: globalThis.Array.isArray(object?.trades)
        ? object.trades.map((e: any) => ClientMarketTrade.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPairMarketTradesResponse): unknown {
    const obj: any = {};
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => ClientMarketTrade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPairMarketTradesResponse>, I>>(base?: I): GetPairMarketTradesResponse {
    return GetPairMarketTradesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPairMarketTradesResponse>, I>>(object: I): GetPairMarketTradesResponse {
    const message = createBaseGetPairMarketTradesResponse();
    message.trades = object.trades?.map((e) => ClientMarketTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllSwapTradesRequest(): GetAllSwapTradesRequest {
  return {};
}

export const GetAllSwapTradesRequest: MessageFns<GetAllSwapTradesRequest> = {
  encode(_: GetAllSwapTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllSwapTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllSwapTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllSwapTradesRequest {
    return {};
  },

  toJSON(_: GetAllSwapTradesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllSwapTradesRequest>, I>>(base?: I): GetAllSwapTradesRequest {
    return GetAllSwapTradesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllSwapTradesRequest>, I>>(_: I): GetAllSwapTradesRequest {
    const message = createBaseGetAllSwapTradesRequest();
    return message;
  },
};

function createBaseGetAllSwapTradesResponse(): GetAllSwapTradesResponse {
  return { pairSwapTrades: [] };
}

export const GetAllSwapTradesResponse: MessageFns<GetAllSwapTradesResponse> = {
  encode(message: GetAllSwapTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pairSwapTrades) {
      GetAllSwapTradesResponse_PairSwapTrades.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllSwapTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllSwapTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairSwapTrades.push(GetAllSwapTradesResponse_PairSwapTrades.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllSwapTradesResponse {
    return {
      pairSwapTrades: globalThis.Array.isArray(object?.pairSwapTrades)
        ? object.pairSwapTrades.map((e: any) => GetAllSwapTradesResponse_PairSwapTrades.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllSwapTradesResponse): unknown {
    const obj: any = {};
    if (message.pairSwapTrades?.length) {
      obj.pairSwapTrades = message.pairSwapTrades.map((e) => GetAllSwapTradesResponse_PairSwapTrades.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllSwapTradesResponse>, I>>(base?: I): GetAllSwapTradesResponse {
    return GetAllSwapTradesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllSwapTradesResponse>, I>>(object: I): GetAllSwapTradesResponse {
    const message = createBaseGetAllSwapTradesResponse();
    message.pairSwapTrades =
      object.pairSwapTrades?.map((e) => GetAllSwapTradesResponse_PairSwapTrades.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllSwapTradesResponse_PairSwapTrades(): GetAllSwapTradesResponse_PairSwapTrades {
  return { fromCurrency: undefined, toCurrency: undefined, trades: [] };
}

export const GetAllSwapTradesResponse_PairSwapTrades: MessageFns<GetAllSwapTradesResponse_PairSwapTrades> = {
  encode(message: GetAllSwapTradesResponse_PairSwapTrades, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== undefined) {
      OrderbookCurrency.encode(message.fromCurrency, writer.uint32(10).fork()).join();
    }
    if (message.toCurrency !== undefined) {
      OrderbookCurrency.encode(message.toCurrency, writer.uint32(18).fork()).join();
    }
    for (const v of message.trades) {
      ClientSwapTrade.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllSwapTradesResponse_PairSwapTrades {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllSwapTradesResponse_PairSwapTrades();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trades.push(ClientSwapTrade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllSwapTradesResponse_PairSwapTrades {
    return {
      fromCurrency: isSet(object.fromCurrency) ? OrderbookCurrency.fromJSON(object.fromCurrency) : undefined,
      toCurrency: isSet(object.toCurrency) ? OrderbookCurrency.fromJSON(object.toCurrency) : undefined,
      trades: globalThis.Array.isArray(object?.trades)
        ? object.trades.map((e: any) => ClientSwapTrade.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllSwapTradesResponse_PairSwapTrades): unknown {
    const obj: any = {};
    if (message.fromCurrency !== undefined) {
      obj.fromCurrency = OrderbookCurrency.toJSON(message.fromCurrency);
    }
    if (message.toCurrency !== undefined) {
      obj.toCurrency = OrderbookCurrency.toJSON(message.toCurrency);
    }
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => ClientSwapTrade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllSwapTradesResponse_PairSwapTrades>, I>>(
    base?: I,
  ): GetAllSwapTradesResponse_PairSwapTrades {
    return GetAllSwapTradesResponse_PairSwapTrades.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllSwapTradesResponse_PairSwapTrades>, I>>(
    object: I,
  ): GetAllSwapTradesResponse_PairSwapTrades {
    const message = createBaseGetAllSwapTradesResponse_PairSwapTrades();
    message.fromCurrency = (object.fromCurrency !== undefined && object.fromCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.fromCurrency)
      : undefined;
    message.toCurrency = (object.toCurrency !== undefined && object.toCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.toCurrency)
      : undefined;
    message.trades = object.trades?.map((e) => ClientSwapTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPairSwapTradesRequest(): GetPairSwapTradesRequest {
  return { fromCurrency: undefined, toCurrency: undefined };
}

export const GetPairSwapTradesRequest: MessageFns<GetPairSwapTradesRequest> = {
  encode(message: GetPairSwapTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== undefined) {
      OrderbookCurrency.encode(message.fromCurrency, writer.uint32(10).fork()).join();
    }
    if (message.toCurrency !== undefined) {
      OrderbookCurrency.encode(message.toCurrency, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPairSwapTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPairSwapTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPairSwapTradesRequest {
    return {
      fromCurrency: isSet(object.fromCurrency) ? OrderbookCurrency.fromJSON(object.fromCurrency) : undefined,
      toCurrency: isSet(object.toCurrency) ? OrderbookCurrency.fromJSON(object.toCurrency) : undefined,
    };
  },

  toJSON(message: GetPairSwapTradesRequest): unknown {
    const obj: any = {};
    if (message.fromCurrency !== undefined) {
      obj.fromCurrency = OrderbookCurrency.toJSON(message.fromCurrency);
    }
    if (message.toCurrency !== undefined) {
      obj.toCurrency = OrderbookCurrency.toJSON(message.toCurrency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPairSwapTradesRequest>, I>>(base?: I): GetPairSwapTradesRequest {
    return GetPairSwapTradesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPairSwapTradesRequest>, I>>(object: I): GetPairSwapTradesRequest {
    const message = createBaseGetPairSwapTradesRequest();
    message.fromCurrency = (object.fromCurrency !== undefined && object.fromCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.fromCurrency)
      : undefined;
    message.toCurrency = (object.toCurrency !== undefined && object.toCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.toCurrency)
      : undefined;
    return message;
  },
};

function createBaseGetPairSwapTradesResponse(): GetPairSwapTradesResponse {
  return { trades: [] };
}

export const GetPairSwapTradesResponse: MessageFns<GetPairSwapTradesResponse> = {
  encode(message: GetPairSwapTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trades) {
      ClientSwapTrade.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPairSwapTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPairSwapTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trades.push(ClientSwapTrade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPairSwapTradesResponse {
    return {
      trades: globalThis.Array.isArray(object?.trades)
        ? object.trades.map((e: any) => ClientSwapTrade.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPairSwapTradesResponse): unknown {
    const obj: any = {};
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => ClientSwapTrade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPairSwapTradesResponse>, I>>(base?: I): GetPairSwapTradesResponse {
    return GetPairSwapTradesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPairSwapTradesResponse>, I>>(object: I): GetPairSwapTradesResponse {
    const message = createBaseGetPairSwapTradesResponse();
    message.trades = object.trades?.map((e) => ClientSwapTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderbookUpdate(): OrderbookUpdate {
  return { updatedOrders: {}, removedOrders: [] };
}

export const OrderbookUpdate: MessageFns<OrderbookUpdate> = {
  encode(message: OrderbookUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.updatedOrders).forEach(([key, value]) => {
      OrderbookUpdate_UpdatedOrdersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    for (const v of message.removedOrders) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderbookUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = OrderbookUpdate_UpdatedOrdersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.updatedOrders[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removedOrders.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookUpdate {
    return {
      updatedOrders: isObject(object.updatedOrders)
        ? Object.entries(object.updatedOrders).reduce<{ [key: string]: LiquidityPosition }>((acc, [key, value]) => {
          acc[key] = LiquidityPosition.fromJSON(value);
          return acc;
        }, {})
        : {},
      removedOrders: globalThis.Array.isArray(object?.removedOrders)
        ? object.removedOrders.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OrderbookUpdate): unknown {
    const obj: any = {};
    if (message.updatedOrders) {
      const entries = Object.entries(message.updatedOrders);
      if (entries.length > 0) {
        obj.updatedOrders = {};
        entries.forEach(([k, v]) => {
          obj.updatedOrders[k] = LiquidityPosition.toJSON(v);
        });
      }
    }
    if (message.removedOrders?.length) {
      obj.removedOrders = message.removedOrders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookUpdate>, I>>(base?: I): OrderbookUpdate {
    return OrderbookUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookUpdate>, I>>(object: I): OrderbookUpdate {
    const message = createBaseOrderbookUpdate();
    message.updatedOrders = Object.entries(object.updatedOrders ?? {}).reduce<{ [key: string]: LiquidityPosition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = LiquidityPosition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.removedOrders = object.removedOrders?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderbookUpdate_UpdatedOrdersEntry(): OrderbookUpdate_UpdatedOrdersEntry {
  return { key: "", value: undefined };
}

export const OrderbookUpdate_UpdatedOrdersEntry: MessageFns<OrderbookUpdate_UpdatedOrdersEntry> = {
  encode(message: OrderbookUpdate_UpdatedOrdersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LiquidityPosition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderbookUpdate_UpdatedOrdersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookUpdate_UpdatedOrdersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LiquidityPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookUpdate_UpdatedOrdersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LiquidityPosition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OrderbookUpdate_UpdatedOrdersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LiquidityPosition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookUpdate_UpdatedOrdersEntry>, I>>(
    base?: I,
  ): OrderbookUpdate_UpdatedOrdersEntry {
    return OrderbookUpdate_UpdatedOrdersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookUpdate_UpdatedOrdersEntry>, I>>(
    object: I,
  ): OrderbookUpdate_UpdatedOrdersEntry {
    const message = createBaseOrderbookUpdate_UpdatedOrdersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LiquidityPosition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMarketVolatility(): MarketVolatility {
  return {
    firstPrice: undefined,
    lastPrice: undefined,
    highPrice: undefined,
    lowPrice: undefined,
    baseVolume: undefined,
    quoteVolume: undefined,
  };
}

export const MarketVolatility: MessageFns<MarketVolatility> = {
  encode(message: MarketVolatility, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstPrice !== undefined) {
      DecimalString.encode(message.firstPrice, writer.uint32(10).fork()).join();
    }
    if (message.lastPrice !== undefined) {
      DecimalString.encode(message.lastPrice, writer.uint32(18).fork()).join();
    }
    if (message.highPrice !== undefined) {
      DecimalString.encode(message.highPrice, writer.uint32(26).fork()).join();
    }
    if (message.lowPrice !== undefined) {
      DecimalString.encode(message.lowPrice, writer.uint32(34).fork()).join();
    }
    if (message.baseVolume !== undefined) {
      DecimalString.encode(message.baseVolume, writer.uint32(42).fork()).join();
    }
    if (message.quoteVolume !== undefined) {
      DecimalString.encode(message.quoteVolume, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketVolatility {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketVolatility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.highPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lowPrice = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.baseVolume = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.quoteVolume = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketVolatility {
    return {
      firstPrice: isSet(object.firstPrice) ? DecimalString.fromJSON(object.firstPrice) : undefined,
      lastPrice: isSet(object.lastPrice) ? DecimalString.fromJSON(object.lastPrice) : undefined,
      highPrice: isSet(object.highPrice) ? DecimalString.fromJSON(object.highPrice) : undefined,
      lowPrice: isSet(object.lowPrice) ? DecimalString.fromJSON(object.lowPrice) : undefined,
      baseVolume: isSet(object.baseVolume) ? DecimalString.fromJSON(object.baseVolume) : undefined,
      quoteVolume: isSet(object.quoteVolume) ? DecimalString.fromJSON(object.quoteVolume) : undefined,
    };
  },

  toJSON(message: MarketVolatility): unknown {
    const obj: any = {};
    if (message.firstPrice !== undefined) {
      obj.firstPrice = DecimalString.toJSON(message.firstPrice);
    }
    if (message.lastPrice !== undefined) {
      obj.lastPrice = DecimalString.toJSON(message.lastPrice);
    }
    if (message.highPrice !== undefined) {
      obj.highPrice = DecimalString.toJSON(message.highPrice);
    }
    if (message.lowPrice !== undefined) {
      obj.lowPrice = DecimalString.toJSON(message.lowPrice);
    }
    if (message.baseVolume !== undefined) {
      obj.baseVolume = DecimalString.toJSON(message.baseVolume);
    }
    if (message.quoteVolume !== undefined) {
      obj.quoteVolume = DecimalString.toJSON(message.quoteVolume);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketVolatility>, I>>(base?: I): MarketVolatility {
    return MarketVolatility.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketVolatility>, I>>(object: I): MarketVolatility {
    const message = createBaseMarketVolatility();
    message.firstPrice = (object.firstPrice !== undefined && object.firstPrice !== null)
      ? DecimalString.fromPartial(object.firstPrice)
      : undefined;
    message.lastPrice = (object.lastPrice !== undefined && object.lastPrice !== null)
      ? DecimalString.fromPartial(object.lastPrice)
      : undefined;
    message.highPrice = (object.highPrice !== undefined && object.highPrice !== null)
      ? DecimalString.fromPartial(object.highPrice)
      : undefined;
    message.lowPrice = (object.lowPrice !== undefined && object.lowPrice !== null)
      ? DecimalString.fromPartial(object.lowPrice)
      : undefined;
    message.baseVolume = (object.baseVolume !== undefined && object.baseVolume !== null)
      ? DecimalString.fromPartial(object.baseVolume)
      : undefined;
    message.quoteVolume = (object.quoteVolume !== undefined && object.quoteVolume !== null)
      ? DecimalString.fromPartial(object.quoteVolume)
      : undefined;
    return message;
  },
};

function createBaseMarketDailyStats(): MarketDailyStats {
  return { volatility: undefined };
}

export const MarketDailyStats: MessageFns<MarketDailyStats> = {
  encode(message: MarketDailyStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.volatility !== undefined) {
      MarketVolatility.encode(message.volatility, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketDailyStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketDailyStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.volatility = MarketVolatility.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketDailyStats {
    return { volatility: isSet(object.volatility) ? MarketVolatility.fromJSON(object.volatility) : undefined };
  },

  toJSON(message: MarketDailyStats): unknown {
    const obj: any = {};
    if (message.volatility !== undefined) {
      obj.volatility = MarketVolatility.toJSON(message.volatility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketDailyStats>, I>>(base?: I): MarketDailyStats {
    return MarketDailyStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketDailyStats>, I>>(object: I): MarketDailyStats {
    const message = createBaseMarketDailyStats();
    message.volatility = (object.volatility !== undefined && object.volatility !== null)
      ? MarketVolatility.fromPartial(object.volatility)
      : undefined;
    return message;
  },
};

function createBaseCandlestick(): Candlestick {
  return {
    timestamp: undefined,
    open: undefined,
    close: undefined,
    high: undefined,
    low: undefined,
    baseVolume: undefined,
    quoteVolume: undefined,
  };
}

export const Candlestick: MessageFns<Candlestick> = {
  encode(message: Candlestick, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.open !== undefined) {
      DecimalString.encode(message.open, writer.uint32(18).fork()).join();
    }
    if (message.close !== undefined) {
      DecimalString.encode(message.close, writer.uint32(26).fork()).join();
    }
    if (message.high !== undefined) {
      DecimalString.encode(message.high, writer.uint32(34).fork()).join();
    }
    if (message.low !== undefined) {
      DecimalString.encode(message.low, writer.uint32(42).fork()).join();
    }
    if (message.baseVolume !== undefined) {
      DecimalString.encode(message.baseVolume, writer.uint32(50).fork()).join();
    }
    if (message.quoteVolume !== undefined) {
      DecimalString.encode(message.quoteVolume, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Candlestick {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandlestick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.open = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.close = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.high = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.low = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.baseVolume = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.quoteVolume = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Candlestick {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      open: isSet(object.open) ? DecimalString.fromJSON(object.open) : undefined,
      close: isSet(object.close) ? DecimalString.fromJSON(object.close) : undefined,
      high: isSet(object.high) ? DecimalString.fromJSON(object.high) : undefined,
      low: isSet(object.low) ? DecimalString.fromJSON(object.low) : undefined,
      baseVolume: isSet(object.baseVolume) ? DecimalString.fromJSON(object.baseVolume) : undefined,
      quoteVolume: isSet(object.quoteVolume) ? DecimalString.fromJSON(object.quoteVolume) : undefined,
    };
  },

  toJSON(message: Candlestick): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.open !== undefined) {
      obj.open = DecimalString.toJSON(message.open);
    }
    if (message.close !== undefined) {
      obj.close = DecimalString.toJSON(message.close);
    }
    if (message.high !== undefined) {
      obj.high = DecimalString.toJSON(message.high);
    }
    if (message.low !== undefined) {
      obj.low = DecimalString.toJSON(message.low);
    }
    if (message.baseVolume !== undefined) {
      obj.baseVolume = DecimalString.toJSON(message.baseVolume);
    }
    if (message.quoteVolume !== undefined) {
      obj.quoteVolume = DecimalString.toJSON(message.quoteVolume);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Candlestick>, I>>(base?: I): Candlestick {
    return Candlestick.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Candlestick>, I>>(object: I): Candlestick {
    const message = createBaseCandlestick();
    message.timestamp = object.timestamp ?? undefined;
    message.open = (object.open !== undefined && object.open !== null)
      ? DecimalString.fromPartial(object.open)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? DecimalString.fromPartial(object.close)
      : undefined;
    message.high = (object.high !== undefined && object.high !== null)
      ? DecimalString.fromPartial(object.high)
      : undefined;
    message.low = (object.low !== undefined && object.low !== null) ? DecimalString.fromPartial(object.low) : undefined;
    message.baseVolume = (object.baseVolume !== undefined && object.baseVolume !== null)
      ? DecimalString.fromPartial(object.baseVolume)
      : undefined;
    message.quoteVolume = (object.quoteVolume !== undefined && object.quoteVolume !== null)
      ? DecimalString.fromPartial(object.quoteVolume)
      : undefined;
    return message;
  },
};

function createBaseCandlestickUpdate(): CandlestickUpdate {
  return { interval: 0, candlestick: undefined };
}

export const CandlestickUpdate: MessageFns<CandlestickUpdate> = {
  encode(message: CandlestickUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interval !== 0) {
      writer.uint32(8).int32(message.interval);
    }
    if (message.candlestick !== undefined) {
      Candlestick.encode(message.candlestick, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CandlestickUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandlestickUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.candlestick = Candlestick.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CandlestickUpdate {
    return {
      interval: isSet(object.interval) ? candlestickIntervalFromJSON(object.interval) : 0,
      candlestick: isSet(object.candlestick) ? Candlestick.fromJSON(object.candlestick) : undefined,
    };
  },

  toJSON(message: CandlestickUpdate): unknown {
    const obj: any = {};
    if (message.interval !== 0) {
      obj.interval = candlestickIntervalToJSON(message.interval);
    }
    if (message.candlestick !== undefined) {
      obj.candlestick = Candlestick.toJSON(message.candlestick);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CandlestickUpdate>, I>>(base?: I): CandlestickUpdate {
    return CandlestickUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CandlestickUpdate>, I>>(object: I): CandlestickUpdate {
    const message = createBaseCandlestickUpdate();
    message.interval = object.interval ?? 0;
    message.candlestick = (object.candlestick !== undefined && object.candlestick !== null)
      ? Candlestick.fromPartial(object.candlestick)
      : undefined;
    return message;
  },
};

function createBaseMarketEvent(): MarketEvent {
  return {
    isSynced: undefined,
    orderbookUpdate: undefined,
    tradeUpdate: undefined,
    dailyStatsUpdate: undefined,
    candlestickUpdate: undefined,
  };
}

export const MarketEvent: MessageFns<MarketEvent> = {
  encode(message: MarketEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSynced !== undefined) {
      writer.uint32(8).bool(message.isSynced);
    }
    if (message.orderbookUpdate !== undefined) {
      OrderbookUpdate.encode(message.orderbookUpdate, writer.uint32(18).fork()).join();
    }
    if (message.tradeUpdate !== undefined) {
      Trade.encode(message.tradeUpdate, writer.uint32(26).fork()).join();
    }
    if (message.dailyStatsUpdate !== undefined) {
      MarketDailyStats.encode(message.dailyStatsUpdate, writer.uint32(34).fork()).join();
    }
    if (message.candlestickUpdate !== undefined) {
      CandlestickUpdate.encode(message.candlestickUpdate, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderbookUpdate = OrderbookUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tradeUpdate = Trade.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dailyStatsUpdate = MarketDailyStats.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.candlestickUpdate = CandlestickUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketEvent {
    return {
      isSynced: isSet(object.isSynced) ? globalThis.Boolean(object.isSynced) : undefined,
      orderbookUpdate: isSet(object.orderbookUpdate) ? OrderbookUpdate.fromJSON(object.orderbookUpdate) : undefined,
      tradeUpdate: isSet(object.tradeUpdate) ? Trade.fromJSON(object.tradeUpdate) : undefined,
      dailyStatsUpdate: isSet(object.dailyStatsUpdate) ? MarketDailyStats.fromJSON(object.dailyStatsUpdate) : undefined,
      candlestickUpdate: isSet(object.candlestickUpdate)
        ? CandlestickUpdate.fromJSON(object.candlestickUpdate)
        : undefined,
    };
  },

  toJSON(message: MarketEvent): unknown {
    const obj: any = {};
    if (message.isSynced !== undefined) {
      obj.isSynced = message.isSynced;
    }
    if (message.orderbookUpdate !== undefined) {
      obj.orderbookUpdate = OrderbookUpdate.toJSON(message.orderbookUpdate);
    }
    if (message.tradeUpdate !== undefined) {
      obj.tradeUpdate = Trade.toJSON(message.tradeUpdate);
    }
    if (message.dailyStatsUpdate !== undefined) {
      obj.dailyStatsUpdate = MarketDailyStats.toJSON(message.dailyStatsUpdate);
    }
    if (message.candlestickUpdate !== undefined) {
      obj.candlestickUpdate = CandlestickUpdate.toJSON(message.candlestickUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketEvent>, I>>(base?: I): MarketEvent {
    return MarketEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketEvent>, I>>(object: I): MarketEvent {
    const message = createBaseMarketEvent();
    message.isSynced = object.isSynced ?? undefined;
    message.orderbookUpdate = (object.orderbookUpdate !== undefined && object.orderbookUpdate !== null)
      ? OrderbookUpdate.fromPartial(object.orderbookUpdate)
      : undefined;
    message.tradeUpdate = (object.tradeUpdate !== undefined && object.tradeUpdate !== null)
      ? Trade.fromPartial(object.tradeUpdate)
      : undefined;
    message.dailyStatsUpdate = (object.dailyStatsUpdate !== undefined && object.dailyStatsUpdate !== null)
      ? MarketDailyStats.fromPartial(object.dailyStatsUpdate)
      : undefined;
    message.candlestickUpdate = (object.candlestickUpdate !== undefined && object.candlestickUpdate !== null)
      ? CandlestickUpdate.fromPartial(object.candlestickUpdate)
      : undefined;
    return message;
  },
};

function createBaseBalanceUpdate(): BalanceUpdate {
  return { currency: undefined, balance: undefined };
}

export const BalanceUpdate: MessageFns<BalanceUpdate> = {
  encode(message: BalanceUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== undefined) {
      OrderbookCurrency.encode(message.currency, writer.uint32(10).fork()).join();
    }
    if (message.balance !== undefined) {
      CurrencyBalance.encode(message.balance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = CurrencyBalance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceUpdate {
    return {
      currency: isSet(object.currency) ? OrderbookCurrency.fromJSON(object.currency) : undefined,
      balance: isSet(object.balance) ? CurrencyBalance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: BalanceUpdate): unknown {
    const obj: any = {};
    if (message.currency !== undefined) {
      obj.currency = OrderbookCurrency.toJSON(message.currency);
    }
    if (message.balance !== undefined) {
      obj.balance = CurrencyBalance.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceUpdate>, I>>(base?: I): BalanceUpdate {
    return BalanceUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceUpdate>, I>>(object: I): BalanceUpdate {
    const message = createBaseBalanceUpdate();
    message.currency = (object.currency !== undefined && object.currency !== null)
      ? OrderbookCurrency.fromPartial(object.currency)
      : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? CurrencyBalance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseOrderUpdate(): OrderUpdate {
  return { orderCreated: undefined, orderUpdated: undefined, orderCompleted: undefined, orderCanceled: undefined };
}

export const OrderUpdate: MessageFns<OrderUpdate> = {
  encode(message: OrderUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderCreated !== undefined) {
      OrderUpdate_OrderCreated.encode(message.orderCreated, writer.uint32(10).fork()).join();
    }
    if (message.orderUpdated !== undefined) {
      OrderUpdate_OrderUpdated.encode(message.orderUpdated, writer.uint32(18).fork()).join();
    }
    if (message.orderCompleted !== undefined) {
      OrderUpdate_OrderCompleted.encode(message.orderCompleted, writer.uint32(26).fork()).join();
    }
    if (message.orderCanceled !== undefined) {
      OrderUpdate_OrderCanceled.encode(message.orderCanceled, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderCreated = OrderUpdate_OrderCreated.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderUpdated = OrderUpdate_OrderUpdated.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderCompleted = OrderUpdate_OrderCompleted.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderCanceled = OrderUpdate_OrderCanceled.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderUpdate {
    return {
      orderCreated: isSet(object.orderCreated) ? OrderUpdate_OrderCreated.fromJSON(object.orderCreated) : undefined,
      orderUpdated: isSet(object.orderUpdated) ? OrderUpdate_OrderUpdated.fromJSON(object.orderUpdated) : undefined,
      orderCompleted: isSet(object.orderCompleted)
        ? OrderUpdate_OrderCompleted.fromJSON(object.orderCompleted)
        : undefined,
      orderCanceled: isSet(object.orderCanceled) ? OrderUpdate_OrderCanceled.fromJSON(object.orderCanceled) : undefined,
    };
  },

  toJSON(message: OrderUpdate): unknown {
    const obj: any = {};
    if (message.orderCreated !== undefined) {
      obj.orderCreated = OrderUpdate_OrderCreated.toJSON(message.orderCreated);
    }
    if (message.orderUpdated !== undefined) {
      obj.orderUpdated = OrderUpdate_OrderUpdated.toJSON(message.orderUpdated);
    }
    if (message.orderCompleted !== undefined) {
      obj.orderCompleted = OrderUpdate_OrderCompleted.toJSON(message.orderCompleted);
    }
    if (message.orderCanceled !== undefined) {
      obj.orderCanceled = OrderUpdate_OrderCanceled.toJSON(message.orderCanceled);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderUpdate>, I>>(base?: I): OrderUpdate {
    return OrderUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderUpdate>, I>>(object: I): OrderUpdate {
    const message = createBaseOrderUpdate();
    message.orderCreated = (object.orderCreated !== undefined && object.orderCreated !== null)
      ? OrderUpdate_OrderCreated.fromPartial(object.orderCreated)
      : undefined;
    message.orderUpdated = (object.orderUpdated !== undefined && object.orderUpdated !== null)
      ? OrderUpdate_OrderUpdated.fromPartial(object.orderUpdated)
      : undefined;
    message.orderCompleted = (object.orderCompleted !== undefined && object.orderCompleted !== null)
      ? OrderUpdate_OrderCompleted.fromPartial(object.orderCompleted)
      : undefined;
    message.orderCanceled = (object.orderCanceled !== undefined && object.orderCanceled !== null)
      ? OrderUpdate_OrderCanceled.fromPartial(object.orderCanceled)
      : undefined;
    return message;
  },
};

function createBaseOrderUpdate_OrderCreated(): OrderUpdate_OrderCreated {
  return { orderId: "", order: undefined };
}

export const OrderUpdate_OrderCreated: MessageFns<OrderUpdate_OrderCreated> = {
  encode(message: OrderUpdate_OrderCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderUpdate_OrderCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderUpdate_OrderCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderUpdate_OrderCreated {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: OrderUpdate_OrderCreated): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderUpdate_OrderCreated>, I>>(base?: I): OrderUpdate_OrderCreated {
    return OrderUpdate_OrderCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderUpdate_OrderCreated>, I>>(object: I): OrderUpdate_OrderCreated {
    const message = createBaseOrderUpdate_OrderCreated();
    message.orderId = object.orderId ?? "";
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseOrderUpdate_OrderUpdated(): OrderUpdate_OrderUpdated {
  return { orderId: "", order: undefined };
}

export const OrderUpdate_OrderUpdated: MessageFns<OrderUpdate_OrderUpdated> = {
  encode(message: OrderUpdate_OrderUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderUpdate_OrderUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderUpdate_OrderUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderUpdate_OrderUpdated {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: OrderUpdate_OrderUpdated): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderUpdate_OrderUpdated>, I>>(base?: I): OrderUpdate_OrderUpdated {
    return OrderUpdate_OrderUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderUpdate_OrderUpdated>, I>>(object: I): OrderUpdate_OrderUpdated {
    const message = createBaseOrderUpdate_OrderUpdated();
    message.orderId = object.orderId ?? "";
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseOrderUpdate_OrderCompleted(): OrderUpdate_OrderCompleted {
  return { orderId: "" };
}

export const OrderUpdate_OrderCompleted: MessageFns<OrderUpdate_OrderCompleted> = {
  encode(message: OrderUpdate_OrderCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderUpdate_OrderCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderUpdate_OrderCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderUpdate_OrderCompleted {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: OrderUpdate_OrderCompleted): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderUpdate_OrderCompleted>, I>>(base?: I): OrderUpdate_OrderCompleted {
    return OrderUpdate_OrderCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderUpdate_OrderCompleted>, I>>(object: I): OrderUpdate_OrderCompleted {
    const message = createBaseOrderUpdate_OrderCompleted();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseOrderUpdate_OrderCanceled(): OrderUpdate_OrderCanceled {
  return { orderId: "" };
}

export const OrderUpdate_OrderCanceled: MessageFns<OrderUpdate_OrderCanceled> = {
  encode(message: OrderUpdate_OrderCanceled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderUpdate_OrderCanceled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderUpdate_OrderCanceled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderUpdate_OrderCanceled {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: OrderUpdate_OrderCanceled): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderUpdate_OrderCanceled>, I>>(base?: I): OrderUpdate_OrderCanceled {
    return OrderUpdate_OrderCanceled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderUpdate_OrderCanceled>, I>>(object: I): OrderUpdate_OrderCanceled {
    const message = createBaseOrderUpdate_OrderCanceled();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseSwapHop(): SwapHop {
  return {
    sendingCurrency: undefined,
    receivingCurrency: undefined,
    sendingAmount: undefined,
    receivingAmount: undefined,
    receivingFee: undefined,
  };
}

export const SwapHop: MessageFns<SwapHop> = {
  encode(message: SwapHop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.sendingAmount !== undefined) {
      DecimalString.encode(message.sendingAmount, writer.uint32(26).fork()).join();
    }
    if (message.receivingAmount !== undefined) {
      DecimalString.encode(message.receivingAmount, writer.uint32(34).fork()).join();
    }
    if (message.receivingFee !== undefined) {
      DecimalString.encode(message.receivingFee, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapHop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapHop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receivingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receivingFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapHop {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      sendingAmount: isSet(object.sendingAmount) ? DecimalString.fromJSON(object.sendingAmount) : undefined,
      receivingAmount: isSet(object.receivingAmount) ? DecimalString.fromJSON(object.receivingAmount) : undefined,
      receivingFee: isSet(object.receivingFee) ? DecimalString.fromJSON(object.receivingFee) : undefined,
    };
  },

  toJSON(message: SwapHop): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.sendingAmount !== undefined) {
      obj.sendingAmount = DecimalString.toJSON(message.sendingAmount);
    }
    if (message.receivingAmount !== undefined) {
      obj.receivingAmount = DecimalString.toJSON(message.receivingAmount);
    }
    if (message.receivingFee !== undefined) {
      obj.receivingFee = DecimalString.toJSON(message.receivingFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapHop>, I>>(base?: I): SwapHop {
    return SwapHop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapHop>, I>>(object: I): SwapHop {
    const message = createBaseSwapHop();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.sendingAmount = (object.sendingAmount !== undefined && object.sendingAmount !== null)
      ? DecimalString.fromPartial(object.sendingAmount)
      : undefined;
    message.receivingAmount = (object.receivingAmount !== undefined && object.receivingAmount !== null)
      ? DecimalString.fromPartial(object.receivingAmount)
      : undefined;
    message.receivingFee = (object.receivingFee !== undefined && object.receivingFee !== null)
      ? DecimalString.fromPartial(object.receivingFee)
      : undefined;
    return message;
  },
};

function createBaseSwapPath(): SwapPath {
  return { swapId: "", firstHop: undefined, nextHops: [] };
}

export const SwapPath: MessageFns<SwapPath> = {
  encode(message: SwapPath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.swapId !== "") {
      writer.uint32(10).string(message.swapId);
    }
    if (message.firstHop !== undefined) {
      SwapHop.encode(message.firstHop, writer.uint32(18).fork()).join();
    }
    for (const v of message.nextHops) {
      SwapHop.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapPath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstHop = SwapHop.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextHops.push(SwapHop.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapPath {
    return {
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      firstHop: isSet(object.firstHop) ? SwapHop.fromJSON(object.firstHop) : undefined,
      nextHops: globalThis.Array.isArray(object?.nextHops) ? object.nextHops.map((e: any) => SwapHop.fromJSON(e)) : [],
    };
  },

  toJSON(message: SwapPath): unknown {
    const obj: any = {};
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.firstHop !== undefined) {
      obj.firstHop = SwapHop.toJSON(message.firstHop);
    }
    if (message.nextHops?.length) {
      obj.nextHops = message.nextHops.map((e) => SwapHop.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapPath>, I>>(base?: I): SwapPath {
    return SwapPath.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapPath>, I>>(object: I): SwapPath {
    const message = createBaseSwapPath();
    message.swapId = object.swapId ?? "";
    message.firstHop = (object.firstHop !== undefined && object.firstHop !== null)
      ? SwapHop.fromPartial(object.firstHop)
      : undefined;
    message.nextHops = object.nextHops?.map((e) => SwapHop.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMatchedOrder(): MatchedOrder {
  return { ownOrderId: "", swapRoute: [], isTaker: false };
}

export const MatchedOrder: MessageFns<MatchedOrder> = {
  encode(message: MatchedOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownOrderId !== "") {
      writer.uint32(10).string(message.ownOrderId);
    }
    for (const v of message.swapRoute) {
      SwapPath.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.isTaker !== false) {
      writer.uint32(24).bool(message.isTaker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchedOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchedOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownOrderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapRoute.push(SwapPath.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isTaker = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchedOrder {
    return {
      ownOrderId: isSet(object.ownOrderId) ? globalThis.String(object.ownOrderId) : "",
      swapRoute: globalThis.Array.isArray(object?.swapRoute)
        ? object.swapRoute.map((e: any) => SwapPath.fromJSON(e))
        : [],
      isTaker: isSet(object.isTaker) ? globalThis.Boolean(object.isTaker) : false,
    };
  },

  toJSON(message: MatchedOrder): unknown {
    const obj: any = {};
    if (message.ownOrderId !== "") {
      obj.ownOrderId = message.ownOrderId;
    }
    if (message.swapRoute?.length) {
      obj.swapRoute = message.swapRoute.map((e) => SwapPath.toJSON(e));
    }
    if (message.isTaker !== false) {
      obj.isTaker = message.isTaker;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchedOrder>, I>>(base?: I): MatchedOrder {
    return MatchedOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchedOrder>, I>>(object: I): MatchedOrder {
    const message = createBaseMatchedOrder();
    message.ownOrderId = object.ownOrderId ?? "";
    message.swapRoute = object.swapRoute?.map((e) => SwapPath.fromPartial(e)) || [];
    message.isTaker = object.isTaker ?? false;
    return message;
  },
};

function createBaseSwapUpdate(): SwapUpdate {
  return { orderId: "", swapId: "", progress: undefined };
}

export const SwapUpdate: MessageFns<SwapUpdate> = {
  encode(message: SwapUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.swapId !== "") {
      writer.uint32(18).string(message.swapId);
    }
    if (message.progress !== undefined) {
      SwapProgress.encode(message.progress, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.progress = SwapProgress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapUpdate {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      progress: isSet(object.progress) ? SwapProgress.fromJSON(object.progress) : undefined,
    };
  },

  toJSON(message: SwapUpdate): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.progress !== undefined) {
      obj.progress = SwapProgress.toJSON(message.progress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapUpdate>, I>>(base?: I): SwapUpdate {
    return SwapUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapUpdate>, I>>(object: I): SwapUpdate {
    const message = createBaseSwapUpdate();
    message.orderId = object.orderId ?? "";
    message.swapId = object.swapId ?? "";
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? SwapProgress.fromPartial(object.progress)
      : undefined;
    return message;
  },
};

function createBaseSwapProgress(): SwapProgress {
  return { receivingAmount: undefined, payingAmount: undefined, status: 0, error: undefined };
}

export const SwapProgress: MessageFns<SwapProgress> = {
  encode(message: SwapProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receivingAmount !== undefined) {
      DecimalString.encode(message.receivingAmount, writer.uint32(10).fork()).join();
    }
    if (message.payingAmount !== undefined) {
      DecimalString.encode(message.payingAmount, writer.uint32(18).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.receivingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapProgress {
    return {
      receivingAmount: isSet(object.receivingAmount) ? DecimalString.fromJSON(object.receivingAmount) : undefined,
      payingAmount: isSet(object.payingAmount) ? DecimalString.fromJSON(object.payingAmount) : undefined,
      status: isSet(object.status) ? swapStatusFromJSON(object.status) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: SwapProgress): unknown {
    const obj: any = {};
    if (message.receivingAmount !== undefined) {
      obj.receivingAmount = DecimalString.toJSON(message.receivingAmount);
    }
    if (message.payingAmount !== undefined) {
      obj.payingAmount = DecimalString.toJSON(message.payingAmount);
    }
    if (message.status !== 0) {
      obj.status = swapStatusToJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapProgress>, I>>(base?: I): SwapProgress {
    return SwapProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapProgress>, I>>(object: I): SwapProgress {
    const message = createBaseSwapProgress();
    message.receivingAmount = (object.receivingAmount !== undefined && object.receivingAmount !== null)
      ? DecimalString.fromPartial(object.receivingAmount)
      : undefined;
    message.payingAmount = (object.payingAmount !== undefined && object.payingAmount !== null)
      ? DecimalString.fromPartial(object.payingAmount)
      : undefined;
    message.status = object.status ?? 0;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseMarketTradeUpdate(): MarketTradeUpdate {
  return { base: undefined, quote: undefined, trade: undefined };
}

export const MarketTradeUpdate: MessageFns<MarketTradeUpdate> = {
  encode(message: MarketTradeUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    if (message.trade !== undefined) {
      ClientMarketTrade.encode(message.trade, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketTradeUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketTradeUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trade = ClientMarketTrade.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketTradeUpdate {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
      trade: isSet(object.trade) ? ClientMarketTrade.fromJSON(object.trade) : undefined,
    };
  },

  toJSON(message: MarketTradeUpdate): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    if (message.trade !== undefined) {
      obj.trade = ClientMarketTrade.toJSON(message.trade);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketTradeUpdate>, I>>(base?: I): MarketTradeUpdate {
    return MarketTradeUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketTradeUpdate>, I>>(object: I): MarketTradeUpdate {
    const message = createBaseMarketTradeUpdate();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    message.trade = (object.trade !== undefined && object.trade !== null)
      ? ClientMarketTrade.fromPartial(object.trade)
      : undefined;
    return message;
  },
};

function createBaseSwapTradeUpdate(): SwapTradeUpdate {
  return { fromCurrency: undefined, toCurrency: undefined, trade: undefined };
}

export const SwapTradeUpdate: MessageFns<SwapTradeUpdate> = {
  encode(message: SwapTradeUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== undefined) {
      OrderbookCurrency.encode(message.fromCurrency, writer.uint32(10).fork()).join();
    }
    if (message.toCurrency !== undefined) {
      OrderbookCurrency.encode(message.toCurrency, writer.uint32(18).fork()).join();
    }
    if (message.trade !== undefined) {
      ClientSwapTrade.encode(message.trade, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapTradeUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapTradeUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trade = ClientSwapTrade.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapTradeUpdate {
    return {
      fromCurrency: isSet(object.fromCurrency) ? OrderbookCurrency.fromJSON(object.fromCurrency) : undefined,
      toCurrency: isSet(object.toCurrency) ? OrderbookCurrency.fromJSON(object.toCurrency) : undefined,
      trade: isSet(object.trade) ? ClientSwapTrade.fromJSON(object.trade) : undefined,
    };
  },

  toJSON(message: SwapTradeUpdate): unknown {
    const obj: any = {};
    if (message.fromCurrency !== undefined) {
      obj.fromCurrency = OrderbookCurrency.toJSON(message.fromCurrency);
    }
    if (message.toCurrency !== undefined) {
      obj.toCurrency = OrderbookCurrency.toJSON(message.toCurrency);
    }
    if (message.trade !== undefined) {
      obj.trade = ClientSwapTrade.toJSON(message.trade);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapTradeUpdate>, I>>(base?: I): SwapTradeUpdate {
    return SwapTradeUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapTradeUpdate>, I>>(object: I): SwapTradeUpdate {
    const message = createBaseSwapTradeUpdate();
    message.fromCurrency = (object.fromCurrency !== undefined && object.fromCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.fromCurrency)
      : undefined;
    message.toCurrency = (object.toCurrency !== undefined && object.toCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.toCurrency)
      : undefined;
    message.trade = (object.trade !== undefined && object.trade !== null)
      ? ClientSwapTrade.fromPartial(object.trade)
      : undefined;
    return message;
  },
};

function createBaseDexEvent(): DexEvent {
  return {
    timestamp: undefined,
    isSynced: undefined,
    balanceUpdate: undefined,
    orderUpdate: undefined,
    orderMatched: undefined,
    swapUpdate: undefined,
    marketTradeUpdate: undefined,
    swapTradeUpdate: undefined,
  };
}

export const DexEvent: MessageFns<DexEvent> = {
  encode(message: DexEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.isSynced !== undefined) {
      writer.uint32(16).bool(message.isSynced);
    }
    if (message.balanceUpdate !== undefined) {
      BalanceUpdate.encode(message.balanceUpdate, writer.uint32(26).fork()).join();
    }
    if (message.orderUpdate !== undefined) {
      OrderUpdate.encode(message.orderUpdate, writer.uint32(34).fork()).join();
    }
    if (message.orderMatched !== undefined) {
      MatchedOrder.encode(message.orderMatched, writer.uint32(42).fork()).join();
    }
    if (message.swapUpdate !== undefined) {
      SwapUpdate.encode(message.swapUpdate, writer.uint32(50).fork()).join();
    }
    if (message.marketTradeUpdate !== undefined) {
      MarketTradeUpdate.encode(message.marketTradeUpdate, writer.uint32(58).fork()).join();
    }
    if (message.swapTradeUpdate !== undefined) {
      SwapTradeUpdate.encode(message.swapTradeUpdate, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DexEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDexEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.balanceUpdate = BalanceUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderUpdate = OrderUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderMatched = MatchedOrder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.swapUpdate = SwapUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.marketTradeUpdate = MarketTradeUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.swapTradeUpdate = SwapTradeUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DexEvent {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      isSynced: isSet(object.isSynced) ? globalThis.Boolean(object.isSynced) : undefined,
      balanceUpdate: isSet(object.balanceUpdate) ? BalanceUpdate.fromJSON(object.balanceUpdate) : undefined,
      orderUpdate: isSet(object.orderUpdate) ? OrderUpdate.fromJSON(object.orderUpdate) : undefined,
      orderMatched: isSet(object.orderMatched) ? MatchedOrder.fromJSON(object.orderMatched) : undefined,
      swapUpdate: isSet(object.swapUpdate) ? SwapUpdate.fromJSON(object.swapUpdate) : undefined,
      marketTradeUpdate: isSet(object.marketTradeUpdate)
        ? MarketTradeUpdate.fromJSON(object.marketTradeUpdate)
        : undefined,
      swapTradeUpdate: isSet(object.swapTradeUpdate) ? SwapTradeUpdate.fromJSON(object.swapTradeUpdate) : undefined,
    };
  },

  toJSON(message: DexEvent): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.isSynced !== undefined) {
      obj.isSynced = message.isSynced;
    }
    if (message.balanceUpdate !== undefined) {
      obj.balanceUpdate = BalanceUpdate.toJSON(message.balanceUpdate);
    }
    if (message.orderUpdate !== undefined) {
      obj.orderUpdate = OrderUpdate.toJSON(message.orderUpdate);
    }
    if (message.orderMatched !== undefined) {
      obj.orderMatched = MatchedOrder.toJSON(message.orderMatched);
    }
    if (message.swapUpdate !== undefined) {
      obj.swapUpdate = SwapUpdate.toJSON(message.swapUpdate);
    }
    if (message.marketTradeUpdate !== undefined) {
      obj.marketTradeUpdate = MarketTradeUpdate.toJSON(message.marketTradeUpdate);
    }
    if (message.swapTradeUpdate !== undefined) {
      obj.swapTradeUpdate = SwapTradeUpdate.toJSON(message.swapTradeUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DexEvent>, I>>(base?: I): DexEvent {
    return DexEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DexEvent>, I>>(object: I): DexEvent {
    const message = createBaseDexEvent();
    message.timestamp = object.timestamp ?? undefined;
    message.isSynced = object.isSynced ?? undefined;
    message.balanceUpdate = (object.balanceUpdate !== undefined && object.balanceUpdate !== null)
      ? BalanceUpdate.fromPartial(object.balanceUpdate)
      : undefined;
    message.orderUpdate = (object.orderUpdate !== undefined && object.orderUpdate !== null)
      ? OrderUpdate.fromPartial(object.orderUpdate)
      : undefined;
    message.orderMatched = (object.orderMatched !== undefined && object.orderMatched !== null)
      ? MatchedOrder.fromPartial(object.orderMatched)
      : undefined;
    message.swapUpdate = (object.swapUpdate !== undefined && object.swapUpdate !== null)
      ? SwapUpdate.fromPartial(object.swapUpdate)
      : undefined;
    message.marketTradeUpdate = (object.marketTradeUpdate !== undefined && object.marketTradeUpdate !== null)
      ? MarketTradeUpdate.fromPartial(object.marketTradeUpdate)
      : undefined;
    message.swapTradeUpdate = (object.swapTradeUpdate !== undefined && object.swapTradeUpdate !== null)
      ? SwapTradeUpdate.fromPartial(object.swapTradeUpdate)
      : undefined;
    return message;
  },
};

function createBaseSubscribeMarketEventsRequest(): SubscribeMarketEventsRequest {
  return { base: undefined, quote: undefined };
}

export const SubscribeMarketEventsRequest: MessageFns<SubscribeMarketEventsRequest> = {
  encode(message: SubscribeMarketEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      OrderbookCurrency.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.quote !== undefined) {
      OrderbookCurrency.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeMarketEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeMarketEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeMarketEventsRequest {
    return {
      base: isSet(object.base) ? OrderbookCurrency.fromJSON(object.base) : undefined,
      quote: isSet(object.quote) ? OrderbookCurrency.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: SubscribeMarketEventsRequest): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = OrderbookCurrency.toJSON(message.base);
    }
    if (message.quote !== undefined) {
      obj.quote = OrderbookCurrency.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeMarketEventsRequest>, I>>(base?: I): SubscribeMarketEventsRequest {
    return SubscribeMarketEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeMarketEventsRequest>, I>>(object: I): SubscribeMarketEventsRequest {
    const message = createBaseSubscribeMarketEventsRequest();
    message.base = (object.base !== undefined && object.base !== null)
      ? OrderbookCurrency.fromPartial(object.base)
      : undefined;
    message.quote = (object.quote !== undefined && object.quote !== null)
      ? OrderbookCurrency.fromPartial(object.quote)
      : undefined;
    return message;
  },
};

function createBaseSubscribeDexEventsRequest(): SubscribeDexEventsRequest {
  return {};
}

export const SubscribeDexEventsRequest: MessageFns<SubscribeDexEventsRequest> = {
  encode(_: SubscribeDexEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeDexEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeDexEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubscribeDexEventsRequest {
    return {};
  },

  toJSON(_: SubscribeDexEventsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeDexEventsRequest>, I>>(base?: I): SubscribeDexEventsRequest {
    return SubscribeDexEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeDexEventsRequest>, I>>(_: I): SubscribeDexEventsRequest {
    const message = createBaseSubscribeDexEventsRequest();
    return message;
  },
};

/**
 * Orderbook service definition for managing orderbook operations.
 * This service provides methods to initialize markets, manage orders,
 * and retrieve orderbook info and balances.
 */
export interface OrderbookService {
  /**
   * Initialize a market with two currencies.
   * This operation starts a task on the server that will
   * handle order matches and other market-related operations performing and
   * resolving swaps. If the provided market pair is invalid, the server
   * will return None.
   */
  InitMarket(request: InitMarketRequest): Promise<InitMarketResponse>;
  /** Get the list of initialized markets. */
  GetInitializedMarkets(request: GetInitializedMarketsRequest): Promise<GetInitializedMarketsResponse>;
  /** Get the info of the available markets. */
  GetMarketsInfo(request: GetMarketsInfoRequest): Promise<GetMarketsInfoResponse>;
  /** Get the info of a specific market. */
  GetMarketInfo(request: GetMarketInfoRequest): Promise<GetMarketInfoResponse>;
  /**
   * Get the orderbook balances for the currencies in the market, including
   * the available and locked sending and receiving balances.
   */
  GetOrderbookBalances(request: GetOrderbookBalancesRequest): Promise<GetOrderbookBalancesResponse>;
  /** Get the orderbook for the specified market. */
  GetOrderbook(request: GetOrderbookRequest): Promise<GetOrderbookResponse>;
  /**
   * Estimate the order matching for a specific market based on the
   * order operation that will be performed.
   */
  EstimateOrder(request: EstimateOrderRequest): Promise<EstimateOrderResponse>;
  /** Create a new order for a specific market. */
  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse>;
  /** Cancel an existing order by its ID. */
  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse>;
  /** Cancel all orders in the orderbook. */
  CancelAllOrders(request: CancelAllOrdersRequest): Promise<CancelAllOrdersResponse>;
  /** Get all own orders in the orderbook. */
  GetAllOwnOrders(request: GetAllOwnOrdersRequest): Promise<GetAllOwnOrdersResponse>;
  /** Get own orders in the orderbook for a specific market. */
  GetOwnOrders(request: GetOwnOrdersRequest): Promise<GetOwnOrdersResponse>;
  /** Get a specific order by its ID. */
  GetOrder(request: GetOrderRequest): Promise<GetOrderResponse>;
  /** Get the public trade history for a specific market. */
  GetTradeHistory(request: GetTradeHistoryRequest): Promise<GetTradeHistoryResponse>;
  /** Get all the market trades performed by the user in the orderbook. */
  GetAllMarketTrades(request: GetAllMarketTradesRequest): Promise<GetAllMarketTradesResponse>;
  /** Get the trades performed by the user in a specific market. */
  GetPairMarketTrades(request: GetPairMarketTradesRequest): Promise<GetPairMarketTradesResponse>;
  /** Get all the swap trades performed by the user in the orderbook. */
  GetAllSwapTrades(request: GetAllSwapTradesRequest): Promise<GetAllSwapTradesResponse>;
  /**
   * Get the swap trades performed by the user for a specific pair of
   * currencies.
   */
  GetPairSwapTrades(request: GetPairSwapTradesRequest): Promise<GetPairSwapTradesResponse>;
  /**
   * This method is used to subscribe to the updates of a market.
   * The user will receive updates about the market activity, including
   * order book changes, trade executions, stats and candlestick updates.
   */
  SubscribeMarketEvents(request: SubscribeMarketEventsRequest): Observable<MarketEvent>;
  /**
   * This method is used to subscribe to the dex events.
   * The user will receive updates about their own orders, trades, and balances.
   */
  SubscribeDexEvents(request: SubscribeDexEventsRequest): Observable<DexEvent>;
}

export const OrderbookServiceServiceName = "hydra_app.OrderbookService";
export class OrderbookServiceClientImpl implements OrderbookService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || OrderbookServiceServiceName;
    this.rpc = rpc;
    this.InitMarket = this.InitMarket.bind(this);
    this.GetInitializedMarkets = this.GetInitializedMarkets.bind(this);
    this.GetMarketsInfo = this.GetMarketsInfo.bind(this);
    this.GetMarketInfo = this.GetMarketInfo.bind(this);
    this.GetOrderbookBalances = this.GetOrderbookBalances.bind(this);
    this.GetOrderbook = this.GetOrderbook.bind(this);
    this.EstimateOrder = this.EstimateOrder.bind(this);
    this.CreateOrder = this.CreateOrder.bind(this);
    this.CancelOrder = this.CancelOrder.bind(this);
    this.CancelAllOrders = this.CancelAllOrders.bind(this);
    this.GetAllOwnOrders = this.GetAllOwnOrders.bind(this);
    this.GetOwnOrders = this.GetOwnOrders.bind(this);
    this.GetOrder = this.GetOrder.bind(this);
    this.GetTradeHistory = this.GetTradeHistory.bind(this);
    this.GetAllMarketTrades = this.GetAllMarketTrades.bind(this);
    this.GetPairMarketTrades = this.GetPairMarketTrades.bind(this);
    this.GetAllSwapTrades = this.GetAllSwapTrades.bind(this);
    this.GetPairSwapTrades = this.GetPairSwapTrades.bind(this);
    this.SubscribeMarketEvents = this.SubscribeMarketEvents.bind(this);
    this.SubscribeDexEvents = this.SubscribeDexEvents.bind(this);
  }
  InitMarket(request: InitMarketRequest): Promise<InitMarketResponse> {
    const data = InitMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitMarket", data);
    return promise.then((data) => InitMarketResponse.decode(new BinaryReader(data)));
  }

  GetInitializedMarkets(request: GetInitializedMarketsRequest): Promise<GetInitializedMarketsResponse> {
    const data = GetInitializedMarketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInitializedMarkets", data);
    return promise.then((data) => GetInitializedMarketsResponse.decode(new BinaryReader(data)));
  }

  GetMarketsInfo(request: GetMarketsInfoRequest): Promise<GetMarketsInfoResponse> {
    const data = GetMarketsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMarketsInfo", data);
    return promise.then((data) => GetMarketsInfoResponse.decode(new BinaryReader(data)));
  }

  GetMarketInfo(request: GetMarketInfoRequest): Promise<GetMarketInfoResponse> {
    const data = GetMarketInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMarketInfo", data);
    return promise.then((data) => GetMarketInfoResponse.decode(new BinaryReader(data)));
  }

  GetOrderbookBalances(request: GetOrderbookBalancesRequest): Promise<GetOrderbookBalancesResponse> {
    const data = GetOrderbookBalancesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrderbookBalances", data);
    return promise.then((data) => GetOrderbookBalancesResponse.decode(new BinaryReader(data)));
  }

  GetOrderbook(request: GetOrderbookRequest): Promise<GetOrderbookResponse> {
    const data = GetOrderbookRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrderbook", data);
    return promise.then((data) => GetOrderbookResponse.decode(new BinaryReader(data)));
  }

  EstimateOrder(request: EstimateOrderRequest): Promise<EstimateOrderResponse> {
    const data = EstimateOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateOrder", data);
    return promise.then((data) => EstimateOrderResponse.decode(new BinaryReader(data)));
  }

  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    const data = CreateOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOrder", data);
    return promise.then((data) => CreateOrderResponse.decode(new BinaryReader(data)));
  }

  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse> {
    const data = CancelOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelOrder", data);
    return promise.then((data) => CancelOrderResponse.decode(new BinaryReader(data)));
  }

  CancelAllOrders(request: CancelAllOrdersRequest): Promise<CancelAllOrdersResponse> {
    const data = CancelAllOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelAllOrders", data);
    return promise.then((data) => CancelAllOrdersResponse.decode(new BinaryReader(data)));
  }

  GetAllOwnOrders(request: GetAllOwnOrdersRequest): Promise<GetAllOwnOrdersResponse> {
    const data = GetAllOwnOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllOwnOrders", data);
    return promise.then((data) => GetAllOwnOrdersResponse.decode(new BinaryReader(data)));
  }

  GetOwnOrders(request: GetOwnOrdersRequest): Promise<GetOwnOrdersResponse> {
    const data = GetOwnOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOwnOrders", data);
    return promise.then((data) => GetOwnOrdersResponse.decode(new BinaryReader(data)));
  }

  GetOrder(request: GetOrderRequest): Promise<GetOrderResponse> {
    const data = GetOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrder", data);
    return promise.then((data) => GetOrderResponse.decode(new BinaryReader(data)));
  }

  GetTradeHistory(request: GetTradeHistoryRequest): Promise<GetTradeHistoryResponse> {
    const data = GetTradeHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTradeHistory", data);
    return promise.then((data) => GetTradeHistoryResponse.decode(new BinaryReader(data)));
  }

  GetAllMarketTrades(request: GetAllMarketTradesRequest): Promise<GetAllMarketTradesResponse> {
    const data = GetAllMarketTradesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllMarketTrades", data);
    return promise.then((data) => GetAllMarketTradesResponse.decode(new BinaryReader(data)));
  }

  GetPairMarketTrades(request: GetPairMarketTradesRequest): Promise<GetPairMarketTradesResponse> {
    const data = GetPairMarketTradesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPairMarketTrades", data);
    return promise.then((data) => GetPairMarketTradesResponse.decode(new BinaryReader(data)));
  }

  GetAllSwapTrades(request: GetAllSwapTradesRequest): Promise<GetAllSwapTradesResponse> {
    const data = GetAllSwapTradesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllSwapTrades", data);
    return promise.then((data) => GetAllSwapTradesResponse.decode(new BinaryReader(data)));
  }

  GetPairSwapTrades(request: GetPairSwapTradesRequest): Promise<GetPairSwapTradesResponse> {
    const data = GetPairSwapTradesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPairSwapTrades", data);
    return promise.then((data) => GetPairSwapTradesResponse.decode(new BinaryReader(data)));
  }

  SubscribeMarketEvents(request: SubscribeMarketEventsRequest): Observable<MarketEvent> {
    const data = SubscribeMarketEventsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SubscribeMarketEvents", data);
    return result.pipe(map((data) => MarketEvent.decode(new BinaryReader(data))));
  }

  SubscribeDexEvents(request: SubscribeDexEventsRequest): Observable<DexEvent> {
    const data = SubscribeDexEventsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SubscribeDexEvents", data);
    return result.pipe(map((data) => DexEvent.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
