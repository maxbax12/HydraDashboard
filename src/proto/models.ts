// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.1
// source: models.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "hydra_app";

export enum Protocol {
  BITCOIN = 0,
  EVM = 1,
  UNRECOGNIZED = -1,
}

export function protocolFromJSON(object: any): Protocol {
  switch (object) {
    case 0:
    case "BITCOIN":
      return Protocol.BITCOIN;
    case 1:
    case "EVM":
      return Protocol.EVM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Protocol.UNRECOGNIZED;
  }
}

export function protocolToJSON(object: Protocol): string {
  switch (object) {
    case Protocol.BITCOIN:
      return "BITCOIN";
    case Protocol.EVM:
      return "EVM";
    case Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChannelStatus {
  INACTIVE = 0,
  ACTIVE = 1,
  UPDATING = 2,
  CLOSED = 3,
  CLOSED_REDEEMABLE = 4,
  UNRECOGNIZED = -1,
}

export function channelStatusFromJSON(object: any): ChannelStatus {
  switch (object) {
    case 0:
    case "INACTIVE":
      return ChannelStatus.INACTIVE;
    case 1:
    case "ACTIVE":
      return ChannelStatus.ACTIVE;
    case 2:
    case "UPDATING":
      return ChannelStatus.UPDATING;
    case 3:
    case "CLOSED":
      return ChannelStatus.CLOSED;
    case 4:
    case "CLOSED_REDEEMABLE":
      return ChannelStatus.CLOSED_REDEEMABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChannelStatus.UNRECOGNIZED;
  }
}

export function channelStatusToJSON(object: ChannelStatus): string {
  switch (object) {
    case ChannelStatus.INACTIVE:
      return "INACTIVE";
    case ChannelStatus.ACTIVE:
      return "ACTIVE";
    case ChannelStatus.UPDATING:
      return "UPDATING";
    case ChannelStatus.CLOSED:
      return "CLOSED";
    case ChannelStatus.CLOSED_REDEEMABLE:
      return "CLOSED_REDEEMABLE";
    case ChannelStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Disputer {
  LOCAL = 0,
  REMOTE = 1,
  WATCHTOWER = 2,
  UNRECOGNIZED = -1,
}

export function disputerFromJSON(object: any): Disputer {
  switch (object) {
    case 0:
    case "LOCAL":
      return Disputer.LOCAL;
    case 1:
    case "REMOTE":
      return Disputer.REMOTE;
    case 2:
    case "WATCHTOWER":
      return Disputer.WATCHTOWER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Disputer.UNRECOGNIZED;
  }
}

export function disputerToJSON(object: Disputer): string {
  switch (object) {
    case Disputer.LOCAL:
      return "LOCAL";
    case Disputer.REMOTE:
      return "REMOTE";
    case Disputer.WATCHTOWER:
      return "WATCHTOWER";
    case Disputer.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FiatCurrency {
  USD = 0,
  EUR = 1,
  GBP = 2,
  AUD = 3,
  CAD = 4,
  CHF = 5,
  CNY = 6,
  JPY = 7,
  KRW = 8,
  RUB = 9,
  TRY = 10,
  INR = 11,
  UNRECOGNIZED = -1,
}

export function fiatCurrencyFromJSON(object: any): FiatCurrency {
  switch (object) {
    case 0:
    case "USD":
      return FiatCurrency.USD;
    case 1:
    case "EUR":
      return FiatCurrency.EUR;
    case 2:
    case "GBP":
      return FiatCurrency.GBP;
    case 3:
    case "AUD":
      return FiatCurrency.AUD;
    case 4:
    case "CAD":
      return FiatCurrency.CAD;
    case 5:
    case "CHF":
      return FiatCurrency.CHF;
    case 6:
    case "CNY":
      return FiatCurrency.CNY;
    case 7:
    case "JPY":
      return FiatCurrency.JPY;
    case 8:
    case "KRW":
      return FiatCurrency.KRW;
    case 9:
    case "RUB":
      return FiatCurrency.RUB;
    case 10:
    case "TRY":
      return FiatCurrency.TRY;
    case 11:
    case "INR":
      return FiatCurrency.INR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FiatCurrency.UNRECOGNIZED;
  }
}

export function fiatCurrencyToJSON(object: FiatCurrency): string {
  switch (object) {
    case FiatCurrency.USD:
      return "USD";
    case FiatCurrency.EUR:
      return "EUR";
    case FiatCurrency.GBP:
      return "GBP";
    case FiatCurrency.AUD:
      return "AUD";
    case FiatCurrency.CAD:
      return "CAD";
    case FiatCurrency.CHF:
      return "CHF";
    case FiatCurrency.CNY:
      return "CNY";
    case FiatCurrency.JPY:
      return "JPY";
    case FiatCurrency.KRW:
      return "KRW";
    case FiatCurrency.RUB:
      return "RUB";
    case FiatCurrency.TRY:
      return "TRY";
    case FiatCurrency.INR:
      return "INR";
    case FiatCurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Network {
  protocol: Protocol;
  id: string;
}

export interface BlockHeader {
  number: string;
  hash: string;
  timestamp?: Date | undefined;
  prevHash: string;
}

export interface Asset {
  id: string;
  name: string;
  symbol: string;
  decimals: number;
}

export interface DecimalString {
  value: string;
}

export interface U256String {
  value: string;
}

export interface Message {
  data?: Message_Data | undefined;
  hash?: Message_Hash | undefined;
  typed?: Message_Typed | undefined;
}

export interface Message_Data {
  data: Uint8Array;
}

export interface Message_Hash {
  hash: Uint8Array;
}

export interface Message_Typed {
  payload: Uint8Array;
}

export interface Deadline {
  timestamp?: Deadline_Timestamp | undefined;
  timeDelta?: Deadline_TimeDelta | undefined;
  blockNumber?: Deadline_BlockNumber | undefined;
  blockDelta?: Deadline_BlockDelta | undefined;
}

export interface Deadline_Timestamp {
  timestamp?: Date | undefined;
}

export interface Deadline_TimeDelta {
  seconds: string;
}

export interface Deadline_BlockNumber {
  blockNumber: string;
}

export interface Deadline_BlockDelta {
  blockDelta: string;
}

export interface FeeRate {
  maxTipFeePerUnit?: U256String | undefined;
  maxFeePerUnit?: U256String | undefined;
}

export interface ChainFee {
  baseFeePerUnit?: U256String | undefined;
  maxTipFeePerUnit?: U256String | undefined;
  maxFeePerUnit?: U256String | undefined;
}

export interface FeeEstimate {
  low?: ChainFee | undefined;
  medium?: ChainFee | undefined;
  high?: ChainFee | undefined;
}

export interface FeeOption {
  low?: FeeOption_Low | undefined;
  medium?: FeeOption_Medium | undefined;
  high?: FeeOption_High | undefined;
  custom?: FeeOption_Custom | undefined;
}

export interface FeeOption_Low {
}

export interface FeeOption_Medium {
}

export interface FeeOption_High {
}

export interface FeeOption_Custom {
  feeRate?: FeeRate | undefined;
}

export interface OnchainBalance {
  /** Tha amount of asset that is available for spending on-chain. */
  usable?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is pending confirmation on-chain.
   * This will become usable once the transaction has reached the required
   * number of confirmations for finality.
   */
  pending?: DecimalString | undefined;
}

export interface OffchainBalance {
  /**
   * The amount of asset on the local side of the channels that is free to
   * spend.
   */
  freeLocal?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset on the remote side of the channels that can be
   * received.
   */
  freeRemote?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is pending confirmation on the local side.
   * This can include asset that is locked in channels that are being opened
   * or updated.
   */
  pendingLocal?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is pending confirmation on the remote side.
   * This can include asset that is locked in channels that are being opened
   * or updated.
   */
  pendingRemote?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is unavailable for spending on the local side.
   * This can include local assets that are locked in channels that are
   * inactive, closed, or being closed.
   */
  unavailableLocal?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is unavailable for spending on the remote side.
   * This can include local assets that are locked in channels that are
   * inactive, closed, or being closed.
   */
  unavailableRemote?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is locked in pending channel payments sent to the
   * counterparty.
   */
  payingLocal?:
    | DecimalString
    | undefined;
  /**
   * The amount of asset that is locked in pending channel payments received
   * from the counterparty.
   */
  payingRemote?:
    | DecimalString
    | undefined;
  /**
   * The amount of local asset that is reserved for punishment in case of a
   * channel dispute or for paying fees in case of a channel closure.
   */
  unspendableLocalReserve?:
    | DecimalString
    | undefined;
  /**
   * The amount of remote asset that is reserved for punishment in case of a
   * channel dispute or for paying fees in case of a channel closure.
   */
  unspendableRemoteReserve?: DecimalString | undefined;
}

export interface Balance {
  onchain?: OnchainBalance | undefined;
  offchain?: OffchainBalance | undefined;
}

export interface SendAmount {
  all?: SendAmount_All | undefined;
  exact?: SendAmount_Exact | undefined;
}

export interface SendAmount_All {
}

export interface SendAmount_Exact {
  amount?: DecimalString | undefined;
}

export interface DualFundAmount {
  /** Amount of the asset going to self in the channel */
  local?:
    | DecimalString
    | undefined;
  /** Amount of the asset going to the counterparty in the channel */
  remote?:
    | DecimalString
    | undefined;
  /** Amount of the asset deposited by self in the channel */
  selfDeposit?: DecimalString | undefined;
}

export interface AllowanceAmount {
  unlimited?: AllowanceAmount_Unlimited | undefined;
  exact?: AllowanceAmount_Exact | undefined;
}

export interface AllowanceAmount_Unlimited {
}

export interface AllowanceAmount_Exact {
  amount?: DecimalString | undefined;
}

export interface SetAllowance {
  contract?: SetAllowance_Contract | undefined;
  uniqueToken?: SetAllowance_UniqueToken | undefined;
  token?: SetAllowance_Token | undefined;
}

export interface SetAllowance_Contract {
  contractAddress: string;
  tokenVariant: string;
  approved: boolean;
}

export interface SetAllowance_UniqueToken {
  tokenId: string;
  approved: boolean;
}

export interface SetAllowance_Token {
  tokenId: string;
  amount?: AllowanceAmount | undefined;
}

export interface Allowance {
  contract?: Allowance_Contract | undefined;
  uniqueToken?: Allowance_UniqueToken | undefined;
  token?: Allowance_Token | undefined;
}

export interface Allowance_Contract {
  contractAddress: string;
  tokenVariant: string;
  approved: boolean;
}

export interface Allowance_UniqueToken {
  token?: Asset | undefined;
  approved: boolean;
}

export interface Allowance_Token {
  token?: Asset | undefined;
  amount?: AllowanceAmount | undefined;
}

export interface Transaction {
  id: string;
  status: Transaction_TxStatus;
  confirmations: string;
  blockHeight?: string | undefined;
  timestamp?: Date | undefined;
  fee?:
    | DecimalString
    | undefined;
  /** key: asset_id */
  spent: { [key: string]: DecimalString };
  /** key: asset_id */
  received: { [key: string]: DecimalString };
  operations: Operation[];
  metadata: Uint8Array;
}

export enum Transaction_TxStatus {
  UNKNOWN = 0,
  IN_MEMPOOL = 1,
  PENDING_CONFIRMATIONS = 2,
  COMPLETED = 3,
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function transaction_TxStatusFromJSON(object: any): Transaction_TxStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Transaction_TxStatus.UNKNOWN;
    case 1:
    case "IN_MEMPOOL":
      return Transaction_TxStatus.IN_MEMPOOL;
    case 2:
    case "PENDING_CONFIRMATIONS":
      return Transaction_TxStatus.PENDING_CONFIRMATIONS;
    case 3:
    case "COMPLETED":
      return Transaction_TxStatus.COMPLETED;
    case 4:
    case "FAILED":
      return Transaction_TxStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_TxStatus.UNRECOGNIZED;
  }
}

export function transaction_TxStatusToJSON(object: Transaction_TxStatus): string {
  switch (object) {
    case Transaction_TxStatus.UNKNOWN:
      return "UNKNOWN";
    case Transaction_TxStatus.IN_MEMPOOL:
      return "IN_MEMPOOL";
    case Transaction_TxStatus.PENDING_CONFIRMATIONS:
      return "PENDING_CONFIRMATIONS";
    case Transaction_TxStatus.COMPLETED:
      return "COMPLETED";
    case Transaction_TxStatus.FAILED:
      return "FAILED";
    case Transaction_TxStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction_SpentEntry {
  key: string;
  value?: DecimalString | undefined;
}

export interface Transaction_ReceivedEntry {
  key: string;
  value?: DecimalString | undefined;
}

export interface Operation {
  send?: Operation_Send | undefined;
  receive?: Operation_Receive | undefined;
  selfTransfer?: Operation_SelfTransfer | undefined;
}

export interface Operation_Send {
  assetId: string;
  to?: string | undefined;
  amount?: DecimalString | undefined;
}

export interface Operation_Receive {
  assetId: string;
  from?: string | undefined;
  amount?: DecimalString | undefined;
}

export interface Operation_SelfTransfer {
  assetId: string;
  amount?: DecimalString | undefined;
}

export interface Channel {
  id: string;
  counterparty: string;
  status: ChannelStatus;
  /** key: asset_id */
  assetChannels: { [key: string]: AssetChannel };
}

export interface Channel_AssetChannelsEntry {
  key: string;
  value?: AssetChannel | undefined;
}

export interface AssetChannelStatus {
  cooperativelyOpening?: AssetChannelStatus_CooperativelyOpening | undefined;
  opening?: AssetChannelStatus_Opening | undefined;
  cooperativelyUpdating?: AssetChannelStatus_CooperativelyUpdating | undefined;
  updating?: AssetChannelStatus_Updating | undefined;
  cooperativelyClosing?: AssetChannelStatus_CooperativelyClosing | undefined;
  closing?: AssetChannelStatus_Closing | undefined;
  forceClosing?: AssetChannelStatus_ForceClosing | undefined;
  closedRedeemable?: AssetChannelStatus_ClosedRedeemable | undefined;
  closed?: AssetChannelStatus_Closed | undefined;
  inactive?: AssetChannelStatus_Inactive | undefined;
  activeSending?: AssetChannelStatus_ActiveSending | undefined;
  activeReceiving?: AssetChannelStatus_ActiveReceiving | undefined;
  active?: AssetChannelStatus_Active | undefined;
  recovering?: AssetChannelStatus_Recovering | undefined;
}

export interface AssetChannelStatus_CooperativelyOpening {
}

export interface AssetChannelStatus_Opening {
}

export interface AssetChannelStatus_CooperativelyUpdating {
}

export interface AssetChannelStatus_Updating {
}

export interface AssetChannelStatus_CooperativelyClosing {
}

export interface AssetChannelStatus_Closing {
  closedAtBlock: string;
}

export interface AssetChannelStatus_ForceClosing {
  /**
   * / The block number at which the channel was force-closed
   * / Optional the transaction might be broadcasted but not confirmed yet
   */
  forceClosedAtBlock?:
    | string
    | undefined;
  /** / The disputer of the channel */
  disputer: Disputer;
  /** / The deadline until which the channel can be disputed onchain */
  disputeDeadline?: Deadline | undefined;
}

export interface AssetChannelStatus_ClosedRedeemable {
}

export interface AssetChannelStatus_Closed {
}

export interface AssetChannelStatus_Inactive {
}

export interface AssetChannelStatus_ActiveSending {
}

export interface AssetChannelStatus_ActiveReceiving {
}

export interface AssetChannelStatus_Active {
}

export interface AssetChannelStatus_Recovering {
}

export interface AssetChannel {
  status?: AssetChannelStatus | undefined;
  balance?: OffchainBalance | undefined;
  lastOnchainTxid?: string | undefined;
  lastOperationConfirmations: string;
  lastOperationTimestamp?: Date | undefined;
  isUpdatable: boolean;
}

export interface PaymentStatus {
  pending?: PaymentStatus_Pending | undefined;
  pendingPreimage?: PaymentStatus_PendingPreimage | undefined;
  completed?: PaymentStatus_Completed | undefined;
  expired?: PaymentStatus_Expired | undefined;
  failed?: PaymentStatus_Failed | undefined;
  rejected?: PaymentStatus_Rejected | undefined;
}

export interface PaymentStatus_Pending {
}

export interface PaymentStatus_PendingPreimage {
  resolutionDeadline?: Deadline | undefined;
}

export interface PaymentStatus_Completed {
}

export interface PaymentStatus_Expired {
}

export interface PaymentStatus_Failed {
}

export interface PaymentStatus_Rejected {
}

export interface Payment {
  id: string;
  hash?: string | undefined;
  preimage?: string | undefined;
  status?: PaymentStatus | undefined;
  timestamp?:
    | Date
    | undefined;
  /** key: asset_id */
  spent: { [key: string]: DecimalString };
  /** key: asset_id */
  received: { [key: string]: DecimalString };
  operations: PaymentOperation[];
}

export interface Payment_SpentEntry {
  key: string;
  value?: DecimalString | undefined;
}

export interface Payment_ReceivedEntry {
  key: string;
  value?: DecimalString | undefined;
}

/** / An operation in a payment */
export interface PaymentOperation {
  send?: PaymentOperation_Send | undefined;
  receive?: PaymentOperation_Receive | undefined;
  route?: PaymentOperation_Route | undefined;
}

/** / We sent a payment */
export interface PaymentOperation_Send {
  /** / The asset being sent */
  assetId: string;
  /** / The recipient of the payment */
  to: string;
  /** / The amount intended for the recipient */
  recipientAmount?:
    | DecimalString
    | undefined;
  /** / The shards of the payment */
  shards: SendingPaymentShard[];
}

/** / We received a payment */
export interface PaymentOperation_Receive {
  /** / The asset being received */
  assetId: string;
  /** / The sender of the payment */
  from?:
    | string
    | undefined;
  /** / The amount intended for the recipient */
  recipientAmount?:
    | DecimalString
    | undefined;
  /** / The shards of the payment */
  shards: ReceivingPaymentShard[];
}

/** / We routed a payment */
export interface PaymentOperation_Route {
  /** / The asset being routed */
  assetId: string;
  /** / The channel id of previous hop of the routed payment */
  routedFromChannelId: string;
  /** / The node public key of previous hop of the routed payment */
  routedFromNodeId: string;
  /** / The channel id of next hop of the routed payment */
  routedToChannelId: string;
  /** / The node public key of next hop of the routed payment */
  routedToNodeId: string;
  /** / The amount being routed (including fees) */
  amount?:
    | DecimalString
    | undefined;
  /** / The fee earned for routing the payment */
  earnedFee?: DecimalString | undefined;
}

/**
 * / Represents a shard of an outgoing payment through a specific channel to a
 * / counterparty.
 */
export interface SendingPaymentShard {
  /** / The channel used in the next hop for this shard. */
  channelId: string;
  /** / The counterparty node for the next hop for this shard. */
  counterparty: string;
  /** / The amount transferred in this shard (including fees). */
  amount?:
    | DecimalString
    | undefined;
  /** / The fee paid in the path for this shard. */
  fee?: DecimalString | undefined;
}

/**
 * / Represents a shard of an incoming payment through a specific channel from a
 * / counterparty.
 */
export interface ReceivingPaymentShard {
  /** / The channel used in the previous hop for this shard. */
  channelId: string;
  /** / The counterparty node for the previous hop for this shard. */
  counterparty: string;
  /** / The amount received in this shard. */
  amount?: DecimalString | undefined;
}

export interface Invoice {
  network?:
    | Network
    | undefined;
  /** The string representation of the invoice that can be used to pay it. */
  paymentRequest: string;
  paymentHash: string;
  paymentSecret: string;
  assetId: string;
  amount?: U256String | undefined;
  recipient: string;
  expiryTimestamp?: Date | undefined;
  signature: Uint8Array;
  signableHash: Uint8Array;
}

export interface Hashlock {
  known?: Hashlock_Known | undefined;
  unknown?: Hashlock_Unknown | undefined;
}

export interface Hashlock_Known {
  preimage: string;
}

export interface Hashlock_Unknown {
  hash: string;
}

export interface ClientEvent {
  syncing?: ClientEvent_Syncing | undefined;
  synced?: ClientEvent_Synced | undefined;
  newBlock?: ClientEvent_NewBlock | undefined;
  transactionUpdate?: ClientEvent_TransactionUpdate | undefined;
  transactionRemoved?: ClientEvent_TransactionRemoved | undefined;
  balanceUpdate?: ClientEvent_BalanceUpdate | undefined;
}

export interface ClientEvent_Syncing {
}

export interface ClientEvent_Synced {
}

export interface ClientEvent_NewBlock {
  number: string;
}

export interface ClientEvent_TransactionUpdate {
  transaction?: Transaction | undefined;
}

export interface ClientEvent_TransactionRemoved {
  txid: string;
}

export interface ClientEvent_BalanceUpdate {
  assetId: string;
  balance?: Balance | undefined;
}

export interface NodeEvent {
  syncing?: NodeEvent_Syncing | undefined;
  synced?: NodeEvent_Synced | undefined;
  channelUpdate?: NodeEvent_ChannelUpdate | undefined;
  channelClosed?: NodeEvent_ChannelClosed | undefined;
  assetChannelUpdate?: NodeEvent_AssetChannelUpdate | undefined;
  assetChannelClosed?: NodeEvent_AssetChannelClosed | undefined;
  paymentUpdate?: NodeEvent_PaymentUpdate | undefined;
  peerConnected?: NodeEvent_PeerConnected | undefined;
  peerDisconnected?: NodeEvent_PeerDisconnected | undefined;
  watchtowerConnected?: NodeEvent_WatchtowerConnected | undefined;
  watchtowerDisconnected?: NodeEvent_WatchtowerDisconnected | undefined;
}

export interface NodeEvent_Syncing {
}

export interface NodeEvent_Synced {
}

export interface NodeEvent_ChannelUpdate {
  channel?: Channel | undefined;
}

export interface NodeEvent_ChannelClosed {
  channelId: string;
}

export interface NodeEvent_AssetChannelUpdate {
  channelId: string;
  assetId: string;
  assetChannel?: AssetChannel | undefined;
}

export interface NodeEvent_AssetChannelClosed {
  channelId: string;
  assetId: string;
}

export interface NodeEvent_PaymentUpdate {
  payment?: Payment | undefined;
}

export interface NodeEvent_PeerConnected {
  nodeId: string;
}

export interface NodeEvent_PeerDisconnected {
  nodeId: string;
}

export interface NodeEvent_WatchtowerConnected {
  nodeId: string;
}

export interface NodeEvent_WatchtowerDisconnected {
  nodeId: string;
}

export interface OrderbookCurrency {
  protocol: Protocol;
  networkId: string;
  assetId: string;
}

export interface SwapAmount {
  from?: SwapAmount_From | undefined;
  to?: SwapAmount_To | undefined;
}

export interface SwapAmount_From {
  amount?: DecimalString | undefined;
}

export interface SwapAmount_To {
  amount?: DecimalString | undefined;
}

/** Represents a match of an order in the orderbook for a pair of currencies. */
export interface PairOrderMatch {
  /** The currency being sent */
  sendingCurrency?:
    | OrderbookCurrency
    | undefined;
  /** The currency being received */
  receivingCurrency?:
    | OrderbookCurrency
    | undefined;
  /** The matched amount being sent */
  sendingAmount?:
    | DecimalString
    | undefined;
  /** The matched amount being received */
  receivingAmount?:
    | DecimalString
    | undefined;
  /** The fee paid in the receiving currency */
  receivingFee?:
    | DecimalString
    | undefined;
  /**
   * The slippage of the order ((average price of order - best price of order)
   * / best price of order)
   */
  slippage?: DecimalString | undefined;
}

/**
 * Represents a match of an order in the orderbook for a swap between two
 * currencies. It can either be a single pair order match or a swap that
 * involves multiple pair order matches.
 */
export interface OrderMatch {
  pair?: OrderMatch_Pair | undefined;
  swap?: OrderMatch_Swap | undefined;
}

export interface OrderMatch_Pair {
  pairOrderMatch?: PairOrderMatch | undefined;
}

export interface OrderMatch_Swap {
  pairOrderMatches: PairOrderMatch[];
}

function createBaseNetwork(): Network {
  return { protocol: 0, id: "" };
}

export const Network: MessageFns<Network> = {
  encode(message: Network, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network {
    return {
      protocol: isSet(object.protocol) ? protocolFromJSON(object.protocol) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: Network): unknown {
    const obj: any = {};
    if (message.protocol !== 0) {
      obj.protocol = protocolToJSON(message.protocol);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Network>, I>>(base?: I): Network {
    return Network.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Network>, I>>(object: I): Network {
    const message = createBaseNetwork();
    message.protocol = object.protocol ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return { number: "0", hash: "", timestamp: undefined, prevHash: "" };
}

export const BlockHeader: MessageFns<BlockHeader> = {
  encode(message: BlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "0") {
      writer.uint32(8).uint64(message.number);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.prevHash !== "") {
      writer.uint32(34).string(message.prevHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prevHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : "0",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      prevHash: isSet(object.prevHash) ? globalThis.String(object.prevHash) : "",
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.number !== "0") {
      obj.number = message.number;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.prevHash !== "") {
      obj.prevHash = message.prevHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader>, I>>(base?: I): BlockHeader {
    return BlockHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader>, I>>(object: I): BlockHeader {
    const message = createBaseBlockHeader();
    message.number = object.number ?? "0";
    message.hash = object.hash ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.prevHash = object.prevHash ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { id: "", name: "", symbol: "", decimals: 0 };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint32(message.decimals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    return message;
  },
};

function createBaseDecimalString(): DecimalString {
  return { value: "" };
}

export const DecimalString: MessageFns<DecimalString> = {
  encode(message: DecimalString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecimalString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimalString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecimalString {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: DecimalString): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecimalString>, I>>(base?: I): DecimalString {
    return DecimalString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecimalString>, I>>(object: I): DecimalString {
    const message = createBaseDecimalString();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseU256String(): U256String {
  return { value: "" };
}

export const U256String: MessageFns<U256String> = {
  encode(message: U256String, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): U256String {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseU256String();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): U256String {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: U256String): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<U256String>, I>>(base?: I): U256String {
    return U256String.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<U256String>, I>>(object: I): U256String {
    const message = createBaseU256String();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return { data: undefined, hash: undefined, typed: undefined };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Message_Data.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.hash !== undefined) {
      Message_Hash.encode(message.hash, writer.uint32(18).fork()).join();
    }
    if (message.typed !== undefined) {
      Message_Typed.encode(message.typed, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Message_Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = Message_Hash.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.typed = Message_Typed.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      data: isSet(object.data) ? Message_Data.fromJSON(object.data) : undefined,
      hash: isSet(object.hash) ? Message_Hash.fromJSON(object.hash) : undefined,
      typed: isSet(object.typed) ? Message_Typed.fromJSON(object.typed) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Message_Data.toJSON(message.data);
    }
    if (message.hash !== undefined) {
      obj.hash = Message_Hash.toJSON(message.hash);
    }
    if (message.typed !== undefined) {
      obj.typed = Message_Typed.toJSON(message.typed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.data = (object.data !== undefined && object.data !== null)
      ? Message_Data.fromPartial(object.data)
      : undefined;
    message.hash = (object.hash !== undefined && object.hash !== null)
      ? Message_Hash.fromPartial(object.hash)
      : undefined;
    message.typed = (object.typed !== undefined && object.typed !== null)
      ? Message_Typed.fromPartial(object.typed)
      : undefined;
    return message;
  },
};

function createBaseMessage_Data(): Message_Data {
  return { data: new Uint8Array(0) };
}

export const Message_Data: MessageFns<Message_Data> = {
  encode(message: Message_Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message_Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message_Data {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: Message_Data): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message_Data>, I>>(base?: I): Message_Data {
    return Message_Data.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message_Data>, I>>(object: I): Message_Data {
    const message = createBaseMessage_Data();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMessage_Hash(): Message_Hash {
  return { hash: new Uint8Array(0) };
}

export const Message_Hash: MessageFns<Message_Hash> = {
  encode(message: Message_Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message_Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage_Hash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message_Hash {
    return { hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0) };
  },

  toJSON(message: Message_Hash): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message_Hash>, I>>(base?: I): Message_Hash {
    return Message_Hash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message_Hash>, I>>(object: I): Message_Hash {
    const message = createBaseMessage_Hash();
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMessage_Typed(): Message_Typed {
  return { payload: new Uint8Array(0) };
}

export const Message_Typed: MessageFns<Message_Typed> = {
  encode(message: Message_Typed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload.length !== 0) {
      writer.uint32(10).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message_Typed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage_Typed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message_Typed {
    return { payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0) };
  },

  toJSON(message: Message_Typed): unknown {
    const obj: any = {};
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message_Typed>, I>>(base?: I): Message_Typed {
    return Message_Typed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message_Typed>, I>>(object: I): Message_Typed {
    const message = createBaseMessage_Typed();
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeadline(): Deadline {
  return { timestamp: undefined, timeDelta: undefined, blockNumber: undefined, blockDelta: undefined };
}

export const Deadline: MessageFns<Deadline> = {
  encode(message: Deadline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Deadline_Timestamp.encode(message.timestamp, writer.uint32(10).fork()).join();
    }
    if (message.timeDelta !== undefined) {
      Deadline_TimeDelta.encode(message.timeDelta, writer.uint32(18).fork()).join();
    }
    if (message.blockNumber !== undefined) {
      Deadline_BlockNumber.encode(message.blockNumber, writer.uint32(26).fork()).join();
    }
    if (message.blockDelta !== undefined) {
      Deadline_BlockDelta.encode(message.blockDelta, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deadline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = Deadline_Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeDelta = Deadline_TimeDelta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockNumber = Deadline_BlockNumber.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockDelta = Deadline_BlockDelta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deadline {
    return {
      timestamp: isSet(object.timestamp) ? Deadline_Timestamp.fromJSON(object.timestamp) : undefined,
      timeDelta: isSet(object.timeDelta) ? Deadline_TimeDelta.fromJSON(object.timeDelta) : undefined,
      blockNumber: isSet(object.blockNumber) ? Deadline_BlockNumber.fromJSON(object.blockNumber) : undefined,
      blockDelta: isSet(object.blockDelta) ? Deadline_BlockDelta.fromJSON(object.blockDelta) : undefined,
    };
  },

  toJSON(message: Deadline): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = Deadline_Timestamp.toJSON(message.timestamp);
    }
    if (message.timeDelta !== undefined) {
      obj.timeDelta = Deadline_TimeDelta.toJSON(message.timeDelta);
    }
    if (message.blockNumber !== undefined) {
      obj.blockNumber = Deadline_BlockNumber.toJSON(message.blockNumber);
    }
    if (message.blockDelta !== undefined) {
      obj.blockDelta = Deadline_BlockDelta.toJSON(message.blockDelta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deadline>, I>>(base?: I): Deadline {
    return Deadline.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deadline>, I>>(object: I): Deadline {
    const message = createBaseDeadline();
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Deadline_Timestamp.fromPartial(object.timestamp)
      : undefined;
    message.timeDelta = (object.timeDelta !== undefined && object.timeDelta !== null)
      ? Deadline_TimeDelta.fromPartial(object.timeDelta)
      : undefined;
    message.blockNumber = (object.blockNumber !== undefined && object.blockNumber !== null)
      ? Deadline_BlockNumber.fromPartial(object.blockNumber)
      : undefined;
    message.blockDelta = (object.blockDelta !== undefined && object.blockDelta !== null)
      ? Deadline_BlockDelta.fromPartial(object.blockDelta)
      : undefined;
    return message;
  },
};

function createBaseDeadline_Timestamp(): Deadline_Timestamp {
  return { timestamp: undefined };
}

export const Deadline_Timestamp: MessageFns<Deadline_Timestamp> = {
  encode(message: Deadline_Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deadline_Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadline_Timestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deadline_Timestamp {
    return { timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined };
  },

  toJSON(message: Deadline_Timestamp): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deadline_Timestamp>, I>>(base?: I): Deadline_Timestamp {
    return Deadline_Timestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deadline_Timestamp>, I>>(object: I): Deadline_Timestamp {
    const message = createBaseDeadline_Timestamp();
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseDeadline_TimeDelta(): Deadline_TimeDelta {
  return { seconds: "0" };
}

export const Deadline_TimeDelta: MessageFns<Deadline_TimeDelta> = {
  encode(message: Deadline_TimeDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== "0") {
      writer.uint32(8).uint64(message.seconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deadline_TimeDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadline_TimeDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deadline_TimeDelta {
    return { seconds: isSet(object.seconds) ? globalThis.String(object.seconds) : "0" };
  },

  toJSON(message: Deadline_TimeDelta): unknown {
    const obj: any = {};
    if (message.seconds !== "0") {
      obj.seconds = message.seconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deadline_TimeDelta>, I>>(base?: I): Deadline_TimeDelta {
    return Deadline_TimeDelta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deadline_TimeDelta>, I>>(object: I): Deadline_TimeDelta {
    const message = createBaseDeadline_TimeDelta();
    message.seconds = object.seconds ?? "0";
    return message;
  },
};

function createBaseDeadline_BlockNumber(): Deadline_BlockNumber {
  return { blockNumber: "0" };
}

export const Deadline_BlockNumber: MessageFns<Deadline_BlockNumber> = {
  encode(message: Deadline_BlockNumber, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockNumber !== "0") {
      writer.uint32(8).uint64(message.blockNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deadline_BlockNumber {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadline_BlockNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockNumber = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deadline_BlockNumber {
    return { blockNumber: isSet(object.blockNumber) ? globalThis.String(object.blockNumber) : "0" };
  },

  toJSON(message: Deadline_BlockNumber): unknown {
    const obj: any = {};
    if (message.blockNumber !== "0") {
      obj.blockNumber = message.blockNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deadline_BlockNumber>, I>>(base?: I): Deadline_BlockNumber {
    return Deadline_BlockNumber.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deadline_BlockNumber>, I>>(object: I): Deadline_BlockNumber {
    const message = createBaseDeadline_BlockNumber();
    message.blockNumber = object.blockNumber ?? "0";
    return message;
  },
};

function createBaseDeadline_BlockDelta(): Deadline_BlockDelta {
  return { blockDelta: "0" };
}

export const Deadline_BlockDelta: MessageFns<Deadline_BlockDelta> = {
  encode(message: Deadline_BlockDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockDelta !== "0") {
      writer.uint32(8).uint64(message.blockDelta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deadline_BlockDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadline_BlockDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockDelta = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deadline_BlockDelta {
    return { blockDelta: isSet(object.blockDelta) ? globalThis.String(object.blockDelta) : "0" };
  },

  toJSON(message: Deadline_BlockDelta): unknown {
    const obj: any = {};
    if (message.blockDelta !== "0") {
      obj.blockDelta = message.blockDelta;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deadline_BlockDelta>, I>>(base?: I): Deadline_BlockDelta {
    return Deadline_BlockDelta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deadline_BlockDelta>, I>>(object: I): Deadline_BlockDelta {
    const message = createBaseDeadline_BlockDelta();
    message.blockDelta = object.blockDelta ?? "0";
    return message;
  },
};

function createBaseFeeRate(): FeeRate {
  return { maxTipFeePerUnit: undefined, maxFeePerUnit: undefined };
}

export const FeeRate: MessageFns<FeeRate> = {
  encode(message: FeeRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxTipFeePerUnit !== undefined) {
      U256String.encode(message.maxTipFeePerUnit, writer.uint32(10).fork()).join();
    }
    if (message.maxFeePerUnit !== undefined) {
      U256String.encode(message.maxFeePerUnit, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.maxTipFeePerUnit = U256String.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maxFeePerUnit = U256String.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeRate {
    return {
      maxTipFeePerUnit: isSet(object.maxTipFeePerUnit) ? U256String.fromJSON(object.maxTipFeePerUnit) : undefined,
      maxFeePerUnit: isSet(object.maxFeePerUnit) ? U256String.fromJSON(object.maxFeePerUnit) : undefined,
    };
  },

  toJSON(message: FeeRate): unknown {
    const obj: any = {};
    if (message.maxTipFeePerUnit !== undefined) {
      obj.maxTipFeePerUnit = U256String.toJSON(message.maxTipFeePerUnit);
    }
    if (message.maxFeePerUnit !== undefined) {
      obj.maxFeePerUnit = U256String.toJSON(message.maxFeePerUnit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeRate>, I>>(base?: I): FeeRate {
    return FeeRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeRate>, I>>(object: I): FeeRate {
    const message = createBaseFeeRate();
    message.maxTipFeePerUnit = (object.maxTipFeePerUnit !== undefined && object.maxTipFeePerUnit !== null)
      ? U256String.fromPartial(object.maxTipFeePerUnit)
      : undefined;
    message.maxFeePerUnit = (object.maxFeePerUnit !== undefined && object.maxFeePerUnit !== null)
      ? U256String.fromPartial(object.maxFeePerUnit)
      : undefined;
    return message;
  },
};

function createBaseChainFee(): ChainFee {
  return { baseFeePerUnit: undefined, maxTipFeePerUnit: undefined, maxFeePerUnit: undefined };
}

export const ChainFee: MessageFns<ChainFee> = {
  encode(message: ChainFee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseFeePerUnit !== undefined) {
      U256String.encode(message.baseFeePerUnit, writer.uint32(10).fork()).join();
    }
    if (message.maxTipFeePerUnit !== undefined) {
      U256String.encode(message.maxTipFeePerUnit, writer.uint32(18).fork()).join();
    }
    if (message.maxFeePerUnit !== undefined) {
      U256String.encode(message.maxFeePerUnit, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainFee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseFeePerUnit = U256String.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maxTipFeePerUnit = U256String.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxFeePerUnit = U256String.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainFee {
    return {
      baseFeePerUnit: isSet(object.baseFeePerUnit) ? U256String.fromJSON(object.baseFeePerUnit) : undefined,
      maxTipFeePerUnit: isSet(object.maxTipFeePerUnit) ? U256String.fromJSON(object.maxTipFeePerUnit) : undefined,
      maxFeePerUnit: isSet(object.maxFeePerUnit) ? U256String.fromJSON(object.maxFeePerUnit) : undefined,
    };
  },

  toJSON(message: ChainFee): unknown {
    const obj: any = {};
    if (message.baseFeePerUnit !== undefined) {
      obj.baseFeePerUnit = U256String.toJSON(message.baseFeePerUnit);
    }
    if (message.maxTipFeePerUnit !== undefined) {
      obj.maxTipFeePerUnit = U256String.toJSON(message.maxTipFeePerUnit);
    }
    if (message.maxFeePerUnit !== undefined) {
      obj.maxFeePerUnit = U256String.toJSON(message.maxFeePerUnit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainFee>, I>>(base?: I): ChainFee {
    return ChainFee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainFee>, I>>(object: I): ChainFee {
    const message = createBaseChainFee();
    message.baseFeePerUnit = (object.baseFeePerUnit !== undefined && object.baseFeePerUnit !== null)
      ? U256String.fromPartial(object.baseFeePerUnit)
      : undefined;
    message.maxTipFeePerUnit = (object.maxTipFeePerUnit !== undefined && object.maxTipFeePerUnit !== null)
      ? U256String.fromPartial(object.maxTipFeePerUnit)
      : undefined;
    message.maxFeePerUnit = (object.maxFeePerUnit !== undefined && object.maxFeePerUnit !== null)
      ? U256String.fromPartial(object.maxFeePerUnit)
      : undefined;
    return message;
  },
};

function createBaseFeeEstimate(): FeeEstimate {
  return { low: undefined, medium: undefined, high: undefined };
}

export const FeeEstimate: MessageFns<FeeEstimate> = {
  encode(message: FeeEstimate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.low !== undefined) {
      ChainFee.encode(message.low, writer.uint32(10).fork()).join();
    }
    if (message.medium !== undefined) {
      ChainFee.encode(message.medium, writer.uint32(18).fork()).join();
    }
    if (message.high !== undefined) {
      ChainFee.encode(message.high, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeEstimate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeEstimate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.low = ChainFee.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.medium = ChainFee.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.high = ChainFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeEstimate {
    return {
      low: isSet(object.low) ? ChainFee.fromJSON(object.low) : undefined,
      medium: isSet(object.medium) ? ChainFee.fromJSON(object.medium) : undefined,
      high: isSet(object.high) ? ChainFee.fromJSON(object.high) : undefined,
    };
  },

  toJSON(message: FeeEstimate): unknown {
    const obj: any = {};
    if (message.low !== undefined) {
      obj.low = ChainFee.toJSON(message.low);
    }
    if (message.medium !== undefined) {
      obj.medium = ChainFee.toJSON(message.medium);
    }
    if (message.high !== undefined) {
      obj.high = ChainFee.toJSON(message.high);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeEstimate>, I>>(base?: I): FeeEstimate {
    return FeeEstimate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeEstimate>, I>>(object: I): FeeEstimate {
    const message = createBaseFeeEstimate();
    message.low = (object.low !== undefined && object.low !== null) ? ChainFee.fromPartial(object.low) : undefined;
    message.medium = (object.medium !== undefined && object.medium !== null)
      ? ChainFee.fromPartial(object.medium)
      : undefined;
    message.high = (object.high !== undefined && object.high !== null) ? ChainFee.fromPartial(object.high) : undefined;
    return message;
  },
};

function createBaseFeeOption(): FeeOption {
  return { low: undefined, medium: undefined, high: undefined, custom: undefined };
}

export const FeeOption: MessageFns<FeeOption> = {
  encode(message: FeeOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.low !== undefined) {
      FeeOption_Low.encode(message.low, writer.uint32(10).fork()).join();
    }
    if (message.medium !== undefined) {
      FeeOption_Medium.encode(message.medium, writer.uint32(18).fork()).join();
    }
    if (message.high !== undefined) {
      FeeOption_High.encode(message.high, writer.uint32(26).fork()).join();
    }
    if (message.custom !== undefined) {
      FeeOption_Custom.encode(message.custom, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.low = FeeOption_Low.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.medium = FeeOption_Medium.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.high = FeeOption_High.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.custom = FeeOption_Custom.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeOption {
    return {
      low: isSet(object.low) ? FeeOption_Low.fromJSON(object.low) : undefined,
      medium: isSet(object.medium) ? FeeOption_Medium.fromJSON(object.medium) : undefined,
      high: isSet(object.high) ? FeeOption_High.fromJSON(object.high) : undefined,
      custom: isSet(object.custom) ? FeeOption_Custom.fromJSON(object.custom) : undefined,
    };
  },

  toJSON(message: FeeOption): unknown {
    const obj: any = {};
    if (message.low !== undefined) {
      obj.low = FeeOption_Low.toJSON(message.low);
    }
    if (message.medium !== undefined) {
      obj.medium = FeeOption_Medium.toJSON(message.medium);
    }
    if (message.high !== undefined) {
      obj.high = FeeOption_High.toJSON(message.high);
    }
    if (message.custom !== undefined) {
      obj.custom = FeeOption_Custom.toJSON(message.custom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeOption>, I>>(base?: I): FeeOption {
    return FeeOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeOption>, I>>(object: I): FeeOption {
    const message = createBaseFeeOption();
    message.low = (object.low !== undefined && object.low !== null) ? FeeOption_Low.fromPartial(object.low) : undefined;
    message.medium = (object.medium !== undefined && object.medium !== null)
      ? FeeOption_Medium.fromPartial(object.medium)
      : undefined;
    message.high = (object.high !== undefined && object.high !== null)
      ? FeeOption_High.fromPartial(object.high)
      : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? FeeOption_Custom.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseFeeOption_Low(): FeeOption_Low {
  return {};
}

export const FeeOption_Low: MessageFns<FeeOption_Low> = {
  encode(_: FeeOption_Low, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeOption_Low {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeOption_Low();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FeeOption_Low {
    return {};
  },

  toJSON(_: FeeOption_Low): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeOption_Low>, I>>(base?: I): FeeOption_Low {
    return FeeOption_Low.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeOption_Low>, I>>(_: I): FeeOption_Low {
    const message = createBaseFeeOption_Low();
    return message;
  },
};

function createBaseFeeOption_Medium(): FeeOption_Medium {
  return {};
}

export const FeeOption_Medium: MessageFns<FeeOption_Medium> = {
  encode(_: FeeOption_Medium, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeOption_Medium {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeOption_Medium();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FeeOption_Medium {
    return {};
  },

  toJSON(_: FeeOption_Medium): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeOption_Medium>, I>>(base?: I): FeeOption_Medium {
    return FeeOption_Medium.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeOption_Medium>, I>>(_: I): FeeOption_Medium {
    const message = createBaseFeeOption_Medium();
    return message;
  },
};

function createBaseFeeOption_High(): FeeOption_High {
  return {};
}

export const FeeOption_High: MessageFns<FeeOption_High> = {
  encode(_: FeeOption_High, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeOption_High {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeOption_High();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FeeOption_High {
    return {};
  },

  toJSON(_: FeeOption_High): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeOption_High>, I>>(base?: I): FeeOption_High {
    return FeeOption_High.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeOption_High>, I>>(_: I): FeeOption_High {
    const message = createBaseFeeOption_High();
    return message;
  },
};

function createBaseFeeOption_Custom(): FeeOption_Custom {
  return { feeRate: undefined };
}

export const FeeOption_Custom: MessageFns<FeeOption_Custom> = {
  encode(message: FeeOption_Custom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feeRate !== undefined) {
      FeeRate.encode(message.feeRate, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeOption_Custom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeOption_Custom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feeRate = FeeRate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeOption_Custom {
    return { feeRate: isSet(object.feeRate) ? FeeRate.fromJSON(object.feeRate) : undefined };
  },

  toJSON(message: FeeOption_Custom): unknown {
    const obj: any = {};
    if (message.feeRate !== undefined) {
      obj.feeRate = FeeRate.toJSON(message.feeRate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeOption_Custom>, I>>(base?: I): FeeOption_Custom {
    return FeeOption_Custom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeOption_Custom>, I>>(object: I): FeeOption_Custom {
    const message = createBaseFeeOption_Custom();
    message.feeRate = (object.feeRate !== undefined && object.feeRate !== null)
      ? FeeRate.fromPartial(object.feeRate)
      : undefined;
    return message;
  },
};

function createBaseOnchainBalance(): OnchainBalance {
  return { usable: undefined, pending: undefined };
}

export const OnchainBalance: MessageFns<OnchainBalance> = {
  encode(message: OnchainBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usable !== undefined) {
      DecimalString.encode(message.usable, writer.uint32(10).fork()).join();
    }
    if (message.pending !== undefined) {
      DecimalString.encode(message.pending, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnchainBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnchainBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.usable = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pending = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnchainBalance {
    return {
      usable: isSet(object.usable) ? DecimalString.fromJSON(object.usable) : undefined,
      pending: isSet(object.pending) ? DecimalString.fromJSON(object.pending) : undefined,
    };
  },

  toJSON(message: OnchainBalance): unknown {
    const obj: any = {};
    if (message.usable !== undefined) {
      obj.usable = DecimalString.toJSON(message.usable);
    }
    if (message.pending !== undefined) {
      obj.pending = DecimalString.toJSON(message.pending);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnchainBalance>, I>>(base?: I): OnchainBalance {
    return OnchainBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnchainBalance>, I>>(object: I): OnchainBalance {
    const message = createBaseOnchainBalance();
    message.usable = (object.usable !== undefined && object.usable !== null)
      ? DecimalString.fromPartial(object.usable)
      : undefined;
    message.pending = (object.pending !== undefined && object.pending !== null)
      ? DecimalString.fromPartial(object.pending)
      : undefined;
    return message;
  },
};

function createBaseOffchainBalance(): OffchainBalance {
  return {
    freeLocal: undefined,
    freeRemote: undefined,
    pendingLocal: undefined,
    pendingRemote: undefined,
    unavailableLocal: undefined,
    unavailableRemote: undefined,
    payingLocal: undefined,
    payingRemote: undefined,
    unspendableLocalReserve: undefined,
    unspendableRemoteReserve: undefined,
  };
}

export const OffchainBalance: MessageFns<OffchainBalance> = {
  encode(message: OffchainBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.freeLocal !== undefined) {
      DecimalString.encode(message.freeLocal, writer.uint32(10).fork()).join();
    }
    if (message.freeRemote !== undefined) {
      DecimalString.encode(message.freeRemote, writer.uint32(18).fork()).join();
    }
    if (message.pendingLocal !== undefined) {
      DecimalString.encode(message.pendingLocal, writer.uint32(26).fork()).join();
    }
    if (message.pendingRemote !== undefined) {
      DecimalString.encode(message.pendingRemote, writer.uint32(34).fork()).join();
    }
    if (message.unavailableLocal !== undefined) {
      DecimalString.encode(message.unavailableLocal, writer.uint32(42).fork()).join();
    }
    if (message.unavailableRemote !== undefined) {
      DecimalString.encode(message.unavailableRemote, writer.uint32(50).fork()).join();
    }
    if (message.payingLocal !== undefined) {
      DecimalString.encode(message.payingLocal, writer.uint32(58).fork()).join();
    }
    if (message.payingRemote !== undefined) {
      DecimalString.encode(message.payingRemote, writer.uint32(66).fork()).join();
    }
    if (message.unspendableLocalReserve !== undefined) {
      DecimalString.encode(message.unspendableLocalReserve, writer.uint32(74).fork()).join();
    }
    if (message.unspendableRemoteReserve !== undefined) {
      DecimalString.encode(message.unspendableRemoteReserve, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OffchainBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffchainBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.freeLocal = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.freeRemote = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pendingLocal = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pendingRemote = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unavailableLocal = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unavailableRemote = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payingLocal = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payingRemote = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unspendableLocalReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.unspendableRemoteReserve = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OffchainBalance {
    return {
      freeLocal: isSet(object.freeLocal) ? DecimalString.fromJSON(object.freeLocal) : undefined,
      freeRemote: isSet(object.freeRemote) ? DecimalString.fromJSON(object.freeRemote) : undefined,
      pendingLocal: isSet(object.pendingLocal) ? DecimalString.fromJSON(object.pendingLocal) : undefined,
      pendingRemote: isSet(object.pendingRemote) ? DecimalString.fromJSON(object.pendingRemote) : undefined,
      unavailableLocal: isSet(object.unavailableLocal) ? DecimalString.fromJSON(object.unavailableLocal) : undefined,
      unavailableRemote: isSet(object.unavailableRemote) ? DecimalString.fromJSON(object.unavailableRemote) : undefined,
      payingLocal: isSet(object.payingLocal) ? DecimalString.fromJSON(object.payingLocal) : undefined,
      payingRemote: isSet(object.payingRemote) ? DecimalString.fromJSON(object.payingRemote) : undefined,
      unspendableLocalReserve: isSet(object.unspendableLocalReserve)
        ? DecimalString.fromJSON(object.unspendableLocalReserve)
        : undefined,
      unspendableRemoteReserve: isSet(object.unspendableRemoteReserve)
        ? DecimalString.fromJSON(object.unspendableRemoteReserve)
        : undefined,
    };
  },

  toJSON(message: OffchainBalance): unknown {
    const obj: any = {};
    if (message.freeLocal !== undefined) {
      obj.freeLocal = DecimalString.toJSON(message.freeLocal);
    }
    if (message.freeRemote !== undefined) {
      obj.freeRemote = DecimalString.toJSON(message.freeRemote);
    }
    if (message.pendingLocal !== undefined) {
      obj.pendingLocal = DecimalString.toJSON(message.pendingLocal);
    }
    if (message.pendingRemote !== undefined) {
      obj.pendingRemote = DecimalString.toJSON(message.pendingRemote);
    }
    if (message.unavailableLocal !== undefined) {
      obj.unavailableLocal = DecimalString.toJSON(message.unavailableLocal);
    }
    if (message.unavailableRemote !== undefined) {
      obj.unavailableRemote = DecimalString.toJSON(message.unavailableRemote);
    }
    if (message.payingLocal !== undefined) {
      obj.payingLocal = DecimalString.toJSON(message.payingLocal);
    }
    if (message.payingRemote !== undefined) {
      obj.payingRemote = DecimalString.toJSON(message.payingRemote);
    }
    if (message.unspendableLocalReserve !== undefined) {
      obj.unspendableLocalReserve = DecimalString.toJSON(message.unspendableLocalReserve);
    }
    if (message.unspendableRemoteReserve !== undefined) {
      obj.unspendableRemoteReserve = DecimalString.toJSON(message.unspendableRemoteReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OffchainBalance>, I>>(base?: I): OffchainBalance {
    return OffchainBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OffchainBalance>, I>>(object: I): OffchainBalance {
    const message = createBaseOffchainBalance();
    message.freeLocal = (object.freeLocal !== undefined && object.freeLocal !== null)
      ? DecimalString.fromPartial(object.freeLocal)
      : undefined;
    message.freeRemote = (object.freeRemote !== undefined && object.freeRemote !== null)
      ? DecimalString.fromPartial(object.freeRemote)
      : undefined;
    message.pendingLocal = (object.pendingLocal !== undefined && object.pendingLocal !== null)
      ? DecimalString.fromPartial(object.pendingLocal)
      : undefined;
    message.pendingRemote = (object.pendingRemote !== undefined && object.pendingRemote !== null)
      ? DecimalString.fromPartial(object.pendingRemote)
      : undefined;
    message.unavailableLocal = (object.unavailableLocal !== undefined && object.unavailableLocal !== null)
      ? DecimalString.fromPartial(object.unavailableLocal)
      : undefined;
    message.unavailableRemote = (object.unavailableRemote !== undefined && object.unavailableRemote !== null)
      ? DecimalString.fromPartial(object.unavailableRemote)
      : undefined;
    message.payingLocal = (object.payingLocal !== undefined && object.payingLocal !== null)
      ? DecimalString.fromPartial(object.payingLocal)
      : undefined;
    message.payingRemote = (object.payingRemote !== undefined && object.payingRemote !== null)
      ? DecimalString.fromPartial(object.payingRemote)
      : undefined;
    message.unspendableLocalReserve =
      (object.unspendableLocalReserve !== undefined && object.unspendableLocalReserve !== null)
        ? DecimalString.fromPartial(object.unspendableLocalReserve)
        : undefined;
    message.unspendableRemoteReserve =
      (object.unspendableRemoteReserve !== undefined && object.unspendableRemoteReserve !== null)
        ? DecimalString.fromPartial(object.unspendableRemoteReserve)
        : undefined;
    return message;
  },
};

function createBaseBalance(): Balance {
  return { onchain: undefined, offchain: undefined };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onchain !== undefined) {
      OnchainBalance.encode(message.onchain, writer.uint32(10).fork()).join();
    }
    if (message.offchain !== undefined) {
      OffchainBalance.encode(message.offchain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onchain = OnchainBalance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.offchain = OffchainBalance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      onchain: isSet(object.onchain) ? OnchainBalance.fromJSON(object.onchain) : undefined,
      offchain: isSet(object.offchain) ? OffchainBalance.fromJSON(object.offchain) : undefined,
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.onchain !== undefined) {
      obj.onchain = OnchainBalance.toJSON(message.onchain);
    }
    if (message.offchain !== undefined) {
      obj.offchain = OffchainBalance.toJSON(message.offchain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Balance>, I>>(base?: I): Balance {
    return Balance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Balance>, I>>(object: I): Balance {
    const message = createBaseBalance();
    message.onchain = (object.onchain !== undefined && object.onchain !== null)
      ? OnchainBalance.fromPartial(object.onchain)
      : undefined;
    message.offchain = (object.offchain !== undefined && object.offchain !== null)
      ? OffchainBalance.fromPartial(object.offchain)
      : undefined;
    return message;
  },
};

function createBaseSendAmount(): SendAmount {
  return { all: undefined, exact: undefined };
}

export const SendAmount: MessageFns<SendAmount> = {
  encode(message: SendAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== undefined) {
      SendAmount_All.encode(message.all, writer.uint32(10).fork()).join();
    }
    if (message.exact !== undefined) {
      SendAmount_Exact.encode(message.exact, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.all = SendAmount_All.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exact = SendAmount_Exact.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendAmount {
    return {
      all: isSet(object.all) ? SendAmount_All.fromJSON(object.all) : undefined,
      exact: isSet(object.exact) ? SendAmount_Exact.fromJSON(object.exact) : undefined,
    };
  },

  toJSON(message: SendAmount): unknown {
    const obj: any = {};
    if (message.all !== undefined) {
      obj.all = SendAmount_All.toJSON(message.all);
    }
    if (message.exact !== undefined) {
      obj.exact = SendAmount_Exact.toJSON(message.exact);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendAmount>, I>>(base?: I): SendAmount {
    return SendAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendAmount>, I>>(object: I): SendAmount {
    const message = createBaseSendAmount();
    message.all = (object.all !== undefined && object.all !== null)
      ? SendAmount_All.fromPartial(object.all)
      : undefined;
    message.exact = (object.exact !== undefined && object.exact !== null)
      ? SendAmount_Exact.fromPartial(object.exact)
      : undefined;
    return message;
  },
};

function createBaseSendAmount_All(): SendAmount_All {
  return {};
}

export const SendAmount_All: MessageFns<SendAmount_All> = {
  encode(_: SendAmount_All, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendAmount_All {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendAmount_All();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendAmount_All {
    return {};
  },

  toJSON(_: SendAmount_All): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SendAmount_All>, I>>(base?: I): SendAmount_All {
    return SendAmount_All.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendAmount_All>, I>>(_: I): SendAmount_All {
    const message = createBaseSendAmount_All();
    return message;
  },
};

function createBaseSendAmount_Exact(): SendAmount_Exact {
  return { amount: undefined };
}

export const SendAmount_Exact: MessageFns<SendAmount_Exact> = {
  encode(message: SendAmount_Exact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendAmount_Exact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendAmount_Exact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendAmount_Exact {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: SendAmount_Exact): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendAmount_Exact>, I>>(base?: I): SendAmount_Exact {
    return SendAmount_Exact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendAmount_Exact>, I>>(object: I): SendAmount_Exact {
    const message = createBaseSendAmount_Exact();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseDualFundAmount(): DualFundAmount {
  return { local: undefined, remote: undefined, selfDeposit: undefined };
}

export const DualFundAmount: MessageFns<DualFundAmount> = {
  encode(message: DualFundAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.local !== undefined) {
      DecimalString.encode(message.local, writer.uint32(10).fork()).join();
    }
    if (message.remote !== undefined) {
      DecimalString.encode(message.remote, writer.uint32(18).fork()).join();
    }
    if (message.selfDeposit !== undefined) {
      DecimalString.encode(message.selfDeposit, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DualFundAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDualFundAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.local = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.remote = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selfDeposit = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DualFundAmount {
    return {
      local: isSet(object.local) ? DecimalString.fromJSON(object.local) : undefined,
      remote: isSet(object.remote) ? DecimalString.fromJSON(object.remote) : undefined,
      selfDeposit: isSet(object.selfDeposit) ? DecimalString.fromJSON(object.selfDeposit) : undefined,
    };
  },

  toJSON(message: DualFundAmount): unknown {
    const obj: any = {};
    if (message.local !== undefined) {
      obj.local = DecimalString.toJSON(message.local);
    }
    if (message.remote !== undefined) {
      obj.remote = DecimalString.toJSON(message.remote);
    }
    if (message.selfDeposit !== undefined) {
      obj.selfDeposit = DecimalString.toJSON(message.selfDeposit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DualFundAmount>, I>>(base?: I): DualFundAmount {
    return DualFundAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DualFundAmount>, I>>(object: I): DualFundAmount {
    const message = createBaseDualFundAmount();
    message.local = (object.local !== undefined && object.local !== null)
      ? DecimalString.fromPartial(object.local)
      : undefined;
    message.remote = (object.remote !== undefined && object.remote !== null)
      ? DecimalString.fromPartial(object.remote)
      : undefined;
    message.selfDeposit = (object.selfDeposit !== undefined && object.selfDeposit !== null)
      ? DecimalString.fromPartial(object.selfDeposit)
      : undefined;
    return message;
  },
};

function createBaseAllowanceAmount(): AllowanceAmount {
  return { unlimited: undefined, exact: undefined };
}

export const AllowanceAmount: MessageFns<AllowanceAmount> = {
  encode(message: AllowanceAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unlimited !== undefined) {
      AllowanceAmount_Unlimited.encode(message.unlimited, writer.uint32(10).fork()).join();
    }
    if (message.exact !== undefined) {
      AllowanceAmount_Exact.encode(message.exact, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowanceAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowanceAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unlimited = AllowanceAmount_Unlimited.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exact = AllowanceAmount_Exact.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowanceAmount {
    return {
      unlimited: isSet(object.unlimited) ? AllowanceAmount_Unlimited.fromJSON(object.unlimited) : undefined,
      exact: isSet(object.exact) ? AllowanceAmount_Exact.fromJSON(object.exact) : undefined,
    };
  },

  toJSON(message: AllowanceAmount): unknown {
    const obj: any = {};
    if (message.unlimited !== undefined) {
      obj.unlimited = AllowanceAmount_Unlimited.toJSON(message.unlimited);
    }
    if (message.exact !== undefined) {
      obj.exact = AllowanceAmount_Exact.toJSON(message.exact);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowanceAmount>, I>>(base?: I): AllowanceAmount {
    return AllowanceAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowanceAmount>, I>>(object: I): AllowanceAmount {
    const message = createBaseAllowanceAmount();
    message.unlimited = (object.unlimited !== undefined && object.unlimited !== null)
      ? AllowanceAmount_Unlimited.fromPartial(object.unlimited)
      : undefined;
    message.exact = (object.exact !== undefined && object.exact !== null)
      ? AllowanceAmount_Exact.fromPartial(object.exact)
      : undefined;
    return message;
  },
};

function createBaseAllowanceAmount_Unlimited(): AllowanceAmount_Unlimited {
  return {};
}

export const AllowanceAmount_Unlimited: MessageFns<AllowanceAmount_Unlimited> = {
  encode(_: AllowanceAmount_Unlimited, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowanceAmount_Unlimited {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowanceAmount_Unlimited();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AllowanceAmount_Unlimited {
    return {};
  },

  toJSON(_: AllowanceAmount_Unlimited): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowanceAmount_Unlimited>, I>>(base?: I): AllowanceAmount_Unlimited {
    return AllowanceAmount_Unlimited.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowanceAmount_Unlimited>, I>>(_: I): AllowanceAmount_Unlimited {
    const message = createBaseAllowanceAmount_Unlimited();
    return message;
  },
};

function createBaseAllowanceAmount_Exact(): AllowanceAmount_Exact {
  return { amount: undefined };
}

export const AllowanceAmount_Exact: MessageFns<AllowanceAmount_Exact> = {
  encode(message: AllowanceAmount_Exact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowanceAmount_Exact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowanceAmount_Exact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowanceAmount_Exact {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: AllowanceAmount_Exact): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowanceAmount_Exact>, I>>(base?: I): AllowanceAmount_Exact {
    return AllowanceAmount_Exact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowanceAmount_Exact>, I>>(object: I): AllowanceAmount_Exact {
    const message = createBaseAllowanceAmount_Exact();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseSetAllowance(): SetAllowance {
  return { contract: undefined, uniqueToken: undefined, token: undefined };
}

export const SetAllowance: MessageFns<SetAllowance> = {
  encode(message: SetAllowance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contract !== undefined) {
      SetAllowance_Contract.encode(message.contract, writer.uint32(10).fork()).join();
    }
    if (message.uniqueToken !== undefined) {
      SetAllowance_UniqueToken.encode(message.uniqueToken, writer.uint32(18).fork()).join();
    }
    if (message.token !== undefined) {
      SetAllowance_Token.encode(message.token, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAllowance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAllowance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contract = SetAllowance_Contract.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uniqueToken = SetAllowance_UniqueToken.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = SetAllowance_Token.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAllowance {
    return {
      contract: isSet(object.contract) ? SetAllowance_Contract.fromJSON(object.contract) : undefined,
      uniqueToken: isSet(object.uniqueToken) ? SetAllowance_UniqueToken.fromJSON(object.uniqueToken) : undefined,
      token: isSet(object.token) ? SetAllowance_Token.fromJSON(object.token) : undefined,
    };
  },

  toJSON(message: SetAllowance): unknown {
    const obj: any = {};
    if (message.contract !== undefined) {
      obj.contract = SetAllowance_Contract.toJSON(message.contract);
    }
    if (message.uniqueToken !== undefined) {
      obj.uniqueToken = SetAllowance_UniqueToken.toJSON(message.uniqueToken);
    }
    if (message.token !== undefined) {
      obj.token = SetAllowance_Token.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAllowance>, I>>(base?: I): SetAllowance {
    return SetAllowance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAllowance>, I>>(object: I): SetAllowance {
    const message = createBaseSetAllowance();
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? SetAllowance_Contract.fromPartial(object.contract)
      : undefined;
    message.uniqueToken = (object.uniqueToken !== undefined && object.uniqueToken !== null)
      ? SetAllowance_UniqueToken.fromPartial(object.uniqueToken)
      : undefined;
    message.token = (object.token !== undefined && object.token !== null)
      ? SetAllowance_Token.fromPartial(object.token)
      : undefined;
    return message;
  },
};

function createBaseSetAllowance_Contract(): SetAllowance_Contract {
  return { contractAddress: "", tokenVariant: "", approved: false };
}

export const SetAllowance_Contract: MessageFns<SetAllowance_Contract> = {
  encode(message: SetAllowance_Contract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.tokenVariant !== "") {
      writer.uint32(18).string(message.tokenVariant);
    }
    if (message.approved !== false) {
      writer.uint32(24).bool(message.approved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAllowance_Contract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAllowance_Contract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenVariant = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAllowance_Contract {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenVariant: isSet(object.tokenVariant) ? globalThis.String(object.tokenVariant) : "",
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
    };
  },

  toJSON(message: SetAllowance_Contract): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenVariant !== "") {
      obj.tokenVariant = message.tokenVariant;
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAllowance_Contract>, I>>(base?: I): SetAllowance_Contract {
    return SetAllowance_Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAllowance_Contract>, I>>(object: I): SetAllowance_Contract {
    const message = createBaseSetAllowance_Contract();
    message.contractAddress = object.contractAddress ?? "";
    message.tokenVariant = object.tokenVariant ?? "";
    message.approved = object.approved ?? false;
    return message;
  },
};

function createBaseSetAllowance_UniqueToken(): SetAllowance_UniqueToken {
  return { tokenId: "", approved: false };
}

export const SetAllowance_UniqueToken: MessageFns<SetAllowance_UniqueToken> = {
  encode(message: SetAllowance_UniqueToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.approved !== false) {
      writer.uint32(16).bool(message.approved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAllowance_UniqueToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAllowance_UniqueToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAllowance_UniqueToken {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
    };
  },

  toJSON(message: SetAllowance_UniqueToken): unknown {
    const obj: any = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAllowance_UniqueToken>, I>>(base?: I): SetAllowance_UniqueToken {
    return SetAllowance_UniqueToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAllowance_UniqueToken>, I>>(object: I): SetAllowance_UniqueToken {
    const message = createBaseSetAllowance_UniqueToken();
    message.tokenId = object.tokenId ?? "";
    message.approved = object.approved ?? false;
    return message;
  },
};

function createBaseSetAllowance_Token(): SetAllowance_Token {
  return { tokenId: "", amount: undefined };
}

export const SetAllowance_Token: MessageFns<SetAllowance_Token> = {
  encode(message: SetAllowance_Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.amount !== undefined) {
      AllowanceAmount.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAllowance_Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAllowance_Token();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = AllowanceAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAllowance_Token {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      amount: isSet(object.amount) ? AllowanceAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: SetAllowance_Token): unknown {
    const obj: any = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.amount !== undefined) {
      obj.amount = AllowanceAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAllowance_Token>, I>>(base?: I): SetAllowance_Token {
    return SetAllowance_Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAllowance_Token>, I>>(object: I): SetAllowance_Token {
    const message = createBaseSetAllowance_Token();
    message.tokenId = object.tokenId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? AllowanceAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseAllowance(): Allowance {
  return { contract: undefined, uniqueToken: undefined, token: undefined };
}

export const Allowance: MessageFns<Allowance> = {
  encode(message: Allowance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contract !== undefined) {
      Allowance_Contract.encode(message.contract, writer.uint32(10).fork()).join();
    }
    if (message.uniqueToken !== undefined) {
      Allowance_UniqueToken.encode(message.uniqueToken, writer.uint32(18).fork()).join();
    }
    if (message.token !== undefined) {
      Allowance_Token.encode(message.token, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Allowance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contract = Allowance_Contract.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uniqueToken = Allowance_UniqueToken.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = Allowance_Token.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Allowance {
    return {
      contract: isSet(object.contract) ? Allowance_Contract.fromJSON(object.contract) : undefined,
      uniqueToken: isSet(object.uniqueToken) ? Allowance_UniqueToken.fromJSON(object.uniqueToken) : undefined,
      token: isSet(object.token) ? Allowance_Token.fromJSON(object.token) : undefined,
    };
  },

  toJSON(message: Allowance): unknown {
    const obj: any = {};
    if (message.contract !== undefined) {
      obj.contract = Allowance_Contract.toJSON(message.contract);
    }
    if (message.uniqueToken !== undefined) {
      obj.uniqueToken = Allowance_UniqueToken.toJSON(message.uniqueToken);
    }
    if (message.token !== undefined) {
      obj.token = Allowance_Token.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Allowance>, I>>(base?: I): Allowance {
    return Allowance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Allowance>, I>>(object: I): Allowance {
    const message = createBaseAllowance();
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? Allowance_Contract.fromPartial(object.contract)
      : undefined;
    message.uniqueToken = (object.uniqueToken !== undefined && object.uniqueToken !== null)
      ? Allowance_UniqueToken.fromPartial(object.uniqueToken)
      : undefined;
    message.token = (object.token !== undefined && object.token !== null)
      ? Allowance_Token.fromPartial(object.token)
      : undefined;
    return message;
  },
};

function createBaseAllowance_Contract(): Allowance_Contract {
  return { contractAddress: "", tokenVariant: "", approved: false };
}

export const Allowance_Contract: MessageFns<Allowance_Contract> = {
  encode(message: Allowance_Contract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.tokenVariant !== "") {
      writer.uint32(18).string(message.tokenVariant);
    }
    if (message.approved !== false) {
      writer.uint32(24).bool(message.approved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Allowance_Contract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowance_Contract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenVariant = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Allowance_Contract {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenVariant: isSet(object.tokenVariant) ? globalThis.String(object.tokenVariant) : "",
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
    };
  },

  toJSON(message: Allowance_Contract): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenVariant !== "") {
      obj.tokenVariant = message.tokenVariant;
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Allowance_Contract>, I>>(base?: I): Allowance_Contract {
    return Allowance_Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Allowance_Contract>, I>>(object: I): Allowance_Contract {
    const message = createBaseAllowance_Contract();
    message.contractAddress = object.contractAddress ?? "";
    message.tokenVariant = object.tokenVariant ?? "";
    message.approved = object.approved ?? false;
    return message;
  },
};

function createBaseAllowance_UniqueToken(): Allowance_UniqueToken {
  return { token: undefined, approved: false };
}

export const Allowance_UniqueToken: MessageFns<Allowance_UniqueToken> = {
  encode(message: Allowance_UniqueToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      Asset.encode(message.token, writer.uint32(10).fork()).join();
    }
    if (message.approved !== false) {
      writer.uint32(16).bool(message.approved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Allowance_UniqueToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowance_UniqueToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = Asset.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Allowance_UniqueToken {
    return {
      token: isSet(object.token) ? Asset.fromJSON(object.token) : undefined,
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
    };
  },

  toJSON(message: Allowance_UniqueToken): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = Asset.toJSON(message.token);
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Allowance_UniqueToken>, I>>(base?: I): Allowance_UniqueToken {
    return Allowance_UniqueToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Allowance_UniqueToken>, I>>(object: I): Allowance_UniqueToken {
    const message = createBaseAllowance_UniqueToken();
    message.token = (object.token !== undefined && object.token !== null) ? Asset.fromPartial(object.token) : undefined;
    message.approved = object.approved ?? false;
    return message;
  },
};

function createBaseAllowance_Token(): Allowance_Token {
  return { token: undefined, amount: undefined };
}

export const Allowance_Token: MessageFns<Allowance_Token> = {
  encode(message: Allowance_Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      Asset.encode(message.token, writer.uint32(10).fork()).join();
    }
    if (message.amount !== undefined) {
      AllowanceAmount.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Allowance_Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowance_Token();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = Asset.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = AllowanceAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Allowance_Token {
    return {
      token: isSet(object.token) ? Asset.fromJSON(object.token) : undefined,
      amount: isSet(object.amount) ? AllowanceAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: Allowance_Token): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = Asset.toJSON(message.token);
    }
    if (message.amount !== undefined) {
      obj.amount = AllowanceAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Allowance_Token>, I>>(base?: I): Allowance_Token {
    return Allowance_Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Allowance_Token>, I>>(object: I): Allowance_Token {
    const message = createBaseAllowance_Token();
    message.token = (object.token !== undefined && object.token !== null) ? Asset.fromPartial(object.token) : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? AllowanceAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    id: "",
    status: 0,
    confirmations: "0",
    blockHeight: undefined,
    timestamp: undefined,
    fee: undefined,
    spent: {},
    received: {},
    operations: [],
    metadata: new Uint8Array(0),
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.confirmations !== "0") {
      writer.uint32(24).uint64(message.confirmations);
    }
    if (message.blockHeight !== undefined) {
      writer.uint32(32).uint64(message.blockHeight);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).join();
    }
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(50).fork()).join();
    }
    Object.entries(message.spent).forEach(([key, value]) => {
      Transaction_SpentEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.received).forEach(([key, value]) => {
      Transaction_ReceivedEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.metadata.length !== 0) {
      writer.uint32(82).bytes(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confirmations = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blockHeight = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Transaction_SpentEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.spent[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Transaction_ReceivedEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.received[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? transaction_TxStatusFromJSON(object.status) : 0,
      confirmations: isSet(object.confirmations) ? globalThis.String(object.confirmations) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined,
      spent: isObject(object.spent)
        ? Object.entries(object.spent).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
          acc[key] = DecimalString.fromJSON(value);
          return acc;
        }, {})
        : {},
      received: isObject(object.received)
        ? Object.entries(object.received).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
          acc[key] = DecimalString.fromJSON(value);
          return acc;
        }, {})
        : {},
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array(0),
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== 0) {
      obj.status = transaction_TxStatusToJSON(message.status);
    }
    if (message.confirmations !== "0") {
      obj.confirmations = message.confirmations;
    }
    if (message.blockHeight !== undefined) {
      obj.blockHeight = message.blockHeight;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    if (message.spent) {
      const entries = Object.entries(message.spent);
      if (entries.length > 0) {
        obj.spent = {};
        entries.forEach(([k, v]) => {
          obj.spent[k] = DecimalString.toJSON(v);
        });
      }
    }
    if (message.received) {
      const entries = Object.entries(message.received);
      if (entries.length > 0) {
        obj.received = {};
        entries.forEach(([k, v]) => {
          obj.received[k] = DecimalString.toJSON(v);
        });
      }
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    message.confirmations = object.confirmations ?? "0";
    message.blockHeight = object.blockHeight ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    message.spent = Object.entries(object.spent ?? {}).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DecimalString.fromPartial(value);
      }
      return acc;
    }, {});
    message.received = Object.entries(object.received ?? {}).reduce<{ [key: string]: DecimalString }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DecimalString.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    message.metadata = object.metadata ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransaction_SpentEntry(): Transaction_SpentEntry {
  return { key: "", value: undefined };
}

export const Transaction_SpentEntry: MessageFns<Transaction_SpentEntry> = {
  encode(message: Transaction_SpentEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DecimalString.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction_SpentEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_SpentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction_SpentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DecimalString.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Transaction_SpentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DecimalString.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_SpentEntry>, I>>(base?: I): Transaction_SpentEntry {
    return Transaction_SpentEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_SpentEntry>, I>>(object: I): Transaction_SpentEntry {
    const message = createBaseTransaction_SpentEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DecimalString.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTransaction_ReceivedEntry(): Transaction_ReceivedEntry {
  return { key: "", value: undefined };
}

export const Transaction_ReceivedEntry: MessageFns<Transaction_ReceivedEntry> = {
  encode(message: Transaction_ReceivedEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DecimalString.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction_ReceivedEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_ReceivedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction_ReceivedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DecimalString.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Transaction_ReceivedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DecimalString.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_ReceivedEntry>, I>>(base?: I): Transaction_ReceivedEntry {
    return Transaction_ReceivedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_ReceivedEntry>, I>>(object: I): Transaction_ReceivedEntry {
    const message = createBaseTransaction_ReceivedEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DecimalString.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOperation(): Operation {
  return { send: undefined, receive: undefined, selfTransfer: undefined };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.send !== undefined) {
      Operation_Send.encode(message.send, writer.uint32(10).fork()).join();
    }
    if (message.receive !== undefined) {
      Operation_Receive.encode(message.receive, writer.uint32(18).fork()).join();
    }
    if (message.selfTransfer !== undefined) {
      Operation_SelfTransfer.encode(message.selfTransfer, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.send = Operation_Send.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receive = Operation_Receive.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selfTransfer = Operation_SelfTransfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      send: isSet(object.send) ? Operation_Send.fromJSON(object.send) : undefined,
      receive: isSet(object.receive) ? Operation_Receive.fromJSON(object.receive) : undefined,
      selfTransfer: isSet(object.selfTransfer) ? Operation_SelfTransfer.fromJSON(object.selfTransfer) : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.send !== undefined) {
      obj.send = Operation_Send.toJSON(message.send);
    }
    if (message.receive !== undefined) {
      obj.receive = Operation_Receive.toJSON(message.receive);
    }
    if (message.selfTransfer !== undefined) {
      obj.selfTransfer = Operation_SelfTransfer.toJSON(message.selfTransfer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(object: I): Operation {
    const message = createBaseOperation();
    message.send = (object.send !== undefined && object.send !== null)
      ? Operation_Send.fromPartial(object.send)
      : undefined;
    message.receive = (object.receive !== undefined && object.receive !== null)
      ? Operation_Receive.fromPartial(object.receive)
      : undefined;
    message.selfTransfer = (object.selfTransfer !== undefined && object.selfTransfer !== null)
      ? Operation_SelfTransfer.fromPartial(object.selfTransfer)
      : undefined;
    return message;
  },
};

function createBaseOperation_Send(): Operation_Send {
  return { assetId: "", to: undefined, amount: undefined };
}

export const Operation_Send: MessageFns<Operation_Send> = {
  encode(message: Operation_Send, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.to !== undefined) {
      writer.uint32(18).string(message.to);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation_Send {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_Send();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation_Send {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : undefined,
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: Operation_Send): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.to !== undefined) {
      obj.to = message.to;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation_Send>, I>>(base?: I): Operation_Send {
    return Operation_Send.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation_Send>, I>>(object: I): Operation_Send {
    const message = createBaseOperation_Send();
    message.assetId = object.assetId ?? "";
    message.to = object.to ?? undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseOperation_Receive(): Operation_Receive {
  return { assetId: "", from: undefined, amount: undefined };
}

export const Operation_Receive: MessageFns<Operation_Receive> = {
  encode(message: Operation_Receive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.from !== undefined) {
      writer.uint32(18).string(message.from);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation_Receive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_Receive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation_Receive {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : undefined,
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: Operation_Receive): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation_Receive>, I>>(base?: I): Operation_Receive {
    return Operation_Receive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation_Receive>, I>>(object: I): Operation_Receive {
    const message = createBaseOperation_Receive();
    message.assetId = object.assetId ?? "";
    message.from = object.from ?? undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseOperation_SelfTransfer(): Operation_SelfTransfer {
  return { assetId: "", amount: undefined };
}

export const Operation_SelfTransfer: MessageFns<Operation_SelfTransfer> = {
  encode(message: Operation_SelfTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation_SelfTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_SelfTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation_SelfTransfer {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: Operation_SelfTransfer): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation_SelfTransfer>, I>>(base?: I): Operation_SelfTransfer {
    return Operation_SelfTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation_SelfTransfer>, I>>(object: I): Operation_SelfTransfer {
    const message = createBaseOperation_SelfTransfer();
    message.assetId = object.assetId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseChannel(): Channel {
  return { id: "", counterparty: "", status: 0, assetChannels: {} };
}

export const Channel: MessageFns<Channel> = {
  encode(message: Channel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.counterparty !== "") {
      writer.uint32(18).string(message.counterparty);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    Object.entries(message.assetChannels).forEach(([key, value]) => {
      Channel_AssetChannelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterparty = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Channel_AssetChannelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.assetChannels[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      counterparty: isSet(object.counterparty) ? globalThis.String(object.counterparty) : "",
      status: isSet(object.status) ? channelStatusFromJSON(object.status) : 0,
      assetChannels: isObject(object.assetChannels)
        ? Object.entries(object.assetChannels).reduce<{ [key: string]: AssetChannel }>((acc, [key, value]) => {
          acc[key] = AssetChannel.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.counterparty !== "") {
      obj.counterparty = message.counterparty;
    }
    if (message.status !== 0) {
      obj.status = channelStatusToJSON(message.status);
    }
    if (message.assetChannels) {
      const entries = Object.entries(message.assetChannels);
      if (entries.length > 0) {
        obj.assetChannels = {};
        entries.forEach(([k, v]) => {
          obj.assetChannels[k] = AssetChannel.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.id = object.id ?? "";
    message.counterparty = object.counterparty ?? "";
    message.status = object.status ?? 0;
    message.assetChannels = Object.entries(object.assetChannels ?? {}).reduce<{ [key: string]: AssetChannel }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AssetChannel.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseChannel_AssetChannelsEntry(): Channel_AssetChannelsEntry {
  return { key: "", value: undefined };
}

export const Channel_AssetChannelsEntry: MessageFns<Channel_AssetChannelsEntry> = {
  encode(message: Channel_AssetChannelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AssetChannel.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel_AssetChannelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel_AssetChannelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AssetChannel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel_AssetChannelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AssetChannel.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Channel_AssetChannelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AssetChannel.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel_AssetChannelsEntry>, I>>(base?: I): Channel_AssetChannelsEntry {
    return Channel_AssetChannelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel_AssetChannelsEntry>, I>>(object: I): Channel_AssetChannelsEntry {
    const message = createBaseChannel_AssetChannelsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AssetChannel.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAssetChannelStatus(): AssetChannelStatus {
  return {
    cooperativelyOpening: undefined,
    opening: undefined,
    cooperativelyUpdating: undefined,
    updating: undefined,
    cooperativelyClosing: undefined,
    closing: undefined,
    forceClosing: undefined,
    closedRedeemable: undefined,
    closed: undefined,
    inactive: undefined,
    activeSending: undefined,
    activeReceiving: undefined,
    active: undefined,
    recovering: undefined,
  };
}

export const AssetChannelStatus: MessageFns<AssetChannelStatus> = {
  encode(message: AssetChannelStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cooperativelyOpening !== undefined) {
      AssetChannelStatus_CooperativelyOpening.encode(message.cooperativelyOpening, writer.uint32(10).fork()).join();
    }
    if (message.opening !== undefined) {
      AssetChannelStatus_Opening.encode(message.opening, writer.uint32(18).fork()).join();
    }
    if (message.cooperativelyUpdating !== undefined) {
      AssetChannelStatus_CooperativelyUpdating.encode(message.cooperativelyUpdating, writer.uint32(26).fork()).join();
    }
    if (message.updating !== undefined) {
      AssetChannelStatus_Updating.encode(message.updating, writer.uint32(34).fork()).join();
    }
    if (message.cooperativelyClosing !== undefined) {
      AssetChannelStatus_CooperativelyClosing.encode(message.cooperativelyClosing, writer.uint32(42).fork()).join();
    }
    if (message.closing !== undefined) {
      AssetChannelStatus_Closing.encode(message.closing, writer.uint32(50).fork()).join();
    }
    if (message.forceClosing !== undefined) {
      AssetChannelStatus_ForceClosing.encode(message.forceClosing, writer.uint32(58).fork()).join();
    }
    if (message.closedRedeemable !== undefined) {
      AssetChannelStatus_ClosedRedeemable.encode(message.closedRedeemable, writer.uint32(66).fork()).join();
    }
    if (message.closed !== undefined) {
      AssetChannelStatus_Closed.encode(message.closed, writer.uint32(74).fork()).join();
    }
    if (message.inactive !== undefined) {
      AssetChannelStatus_Inactive.encode(message.inactive, writer.uint32(82).fork()).join();
    }
    if (message.activeSending !== undefined) {
      AssetChannelStatus_ActiveSending.encode(message.activeSending, writer.uint32(90).fork()).join();
    }
    if (message.activeReceiving !== undefined) {
      AssetChannelStatus_ActiveReceiving.encode(message.activeReceiving, writer.uint32(98).fork()).join();
    }
    if (message.active !== undefined) {
      AssetChannelStatus_Active.encode(message.active, writer.uint32(106).fork()).join();
    }
    if (message.recovering !== undefined) {
      AssetChannelStatus_Recovering.encode(message.recovering, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cooperativelyOpening = AssetChannelStatus_CooperativelyOpening.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opening = AssetChannelStatus_Opening.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cooperativelyUpdating = AssetChannelStatus_CooperativelyUpdating.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updating = AssetChannelStatus_Updating.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cooperativelyClosing = AssetChannelStatus_CooperativelyClosing.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.closing = AssetChannelStatus_Closing.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.forceClosing = AssetChannelStatus_ForceClosing.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.closedRedeemable = AssetChannelStatus_ClosedRedeemable.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.closed = AssetChannelStatus_Closed.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.inactive = AssetChannelStatus_Inactive.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.activeSending = AssetChannelStatus_ActiveSending.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.activeReceiving = AssetChannelStatus_ActiveReceiving.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.active = AssetChannelStatus_Active.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.recovering = AssetChannelStatus_Recovering.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetChannelStatus {
    return {
      cooperativelyOpening: isSet(object.cooperativelyOpening)
        ? AssetChannelStatus_CooperativelyOpening.fromJSON(object.cooperativelyOpening)
        : undefined,
      opening: isSet(object.opening) ? AssetChannelStatus_Opening.fromJSON(object.opening) : undefined,
      cooperativelyUpdating: isSet(object.cooperativelyUpdating)
        ? AssetChannelStatus_CooperativelyUpdating.fromJSON(object.cooperativelyUpdating)
        : undefined,
      updating: isSet(object.updating) ? AssetChannelStatus_Updating.fromJSON(object.updating) : undefined,
      cooperativelyClosing: isSet(object.cooperativelyClosing)
        ? AssetChannelStatus_CooperativelyClosing.fromJSON(object.cooperativelyClosing)
        : undefined,
      closing: isSet(object.closing) ? AssetChannelStatus_Closing.fromJSON(object.closing) : undefined,
      forceClosing: isSet(object.forceClosing)
        ? AssetChannelStatus_ForceClosing.fromJSON(object.forceClosing)
        : undefined,
      closedRedeemable: isSet(object.closedRedeemable)
        ? AssetChannelStatus_ClosedRedeemable.fromJSON(object.closedRedeemable)
        : undefined,
      closed: isSet(object.closed) ? AssetChannelStatus_Closed.fromJSON(object.closed) : undefined,
      inactive: isSet(object.inactive) ? AssetChannelStatus_Inactive.fromJSON(object.inactive) : undefined,
      activeSending: isSet(object.activeSending)
        ? AssetChannelStatus_ActiveSending.fromJSON(object.activeSending)
        : undefined,
      activeReceiving: isSet(object.activeReceiving)
        ? AssetChannelStatus_ActiveReceiving.fromJSON(object.activeReceiving)
        : undefined,
      active: isSet(object.active) ? AssetChannelStatus_Active.fromJSON(object.active) : undefined,
      recovering: isSet(object.recovering) ? AssetChannelStatus_Recovering.fromJSON(object.recovering) : undefined,
    };
  },

  toJSON(message: AssetChannelStatus): unknown {
    const obj: any = {};
    if (message.cooperativelyOpening !== undefined) {
      obj.cooperativelyOpening = AssetChannelStatus_CooperativelyOpening.toJSON(message.cooperativelyOpening);
    }
    if (message.opening !== undefined) {
      obj.opening = AssetChannelStatus_Opening.toJSON(message.opening);
    }
    if (message.cooperativelyUpdating !== undefined) {
      obj.cooperativelyUpdating = AssetChannelStatus_CooperativelyUpdating.toJSON(message.cooperativelyUpdating);
    }
    if (message.updating !== undefined) {
      obj.updating = AssetChannelStatus_Updating.toJSON(message.updating);
    }
    if (message.cooperativelyClosing !== undefined) {
      obj.cooperativelyClosing = AssetChannelStatus_CooperativelyClosing.toJSON(message.cooperativelyClosing);
    }
    if (message.closing !== undefined) {
      obj.closing = AssetChannelStatus_Closing.toJSON(message.closing);
    }
    if (message.forceClosing !== undefined) {
      obj.forceClosing = AssetChannelStatus_ForceClosing.toJSON(message.forceClosing);
    }
    if (message.closedRedeemable !== undefined) {
      obj.closedRedeemable = AssetChannelStatus_ClosedRedeemable.toJSON(message.closedRedeemable);
    }
    if (message.closed !== undefined) {
      obj.closed = AssetChannelStatus_Closed.toJSON(message.closed);
    }
    if (message.inactive !== undefined) {
      obj.inactive = AssetChannelStatus_Inactive.toJSON(message.inactive);
    }
    if (message.activeSending !== undefined) {
      obj.activeSending = AssetChannelStatus_ActiveSending.toJSON(message.activeSending);
    }
    if (message.activeReceiving !== undefined) {
      obj.activeReceiving = AssetChannelStatus_ActiveReceiving.toJSON(message.activeReceiving);
    }
    if (message.active !== undefined) {
      obj.active = AssetChannelStatus_Active.toJSON(message.active);
    }
    if (message.recovering !== undefined) {
      obj.recovering = AssetChannelStatus_Recovering.toJSON(message.recovering);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus>, I>>(base?: I): AssetChannelStatus {
    return AssetChannelStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus>, I>>(object: I): AssetChannelStatus {
    const message = createBaseAssetChannelStatus();
    message.cooperativelyOpening = (object.cooperativelyOpening !== undefined && object.cooperativelyOpening !== null)
      ? AssetChannelStatus_CooperativelyOpening.fromPartial(object.cooperativelyOpening)
      : undefined;
    message.opening = (object.opening !== undefined && object.opening !== null)
      ? AssetChannelStatus_Opening.fromPartial(object.opening)
      : undefined;
    message.cooperativelyUpdating =
      (object.cooperativelyUpdating !== undefined && object.cooperativelyUpdating !== null)
        ? AssetChannelStatus_CooperativelyUpdating.fromPartial(object.cooperativelyUpdating)
        : undefined;
    message.updating = (object.updating !== undefined && object.updating !== null)
      ? AssetChannelStatus_Updating.fromPartial(object.updating)
      : undefined;
    message.cooperativelyClosing = (object.cooperativelyClosing !== undefined && object.cooperativelyClosing !== null)
      ? AssetChannelStatus_CooperativelyClosing.fromPartial(object.cooperativelyClosing)
      : undefined;
    message.closing = (object.closing !== undefined && object.closing !== null)
      ? AssetChannelStatus_Closing.fromPartial(object.closing)
      : undefined;
    message.forceClosing = (object.forceClosing !== undefined && object.forceClosing !== null)
      ? AssetChannelStatus_ForceClosing.fromPartial(object.forceClosing)
      : undefined;
    message.closedRedeemable = (object.closedRedeemable !== undefined && object.closedRedeemable !== null)
      ? AssetChannelStatus_ClosedRedeemable.fromPartial(object.closedRedeemable)
      : undefined;
    message.closed = (object.closed !== undefined && object.closed !== null)
      ? AssetChannelStatus_Closed.fromPartial(object.closed)
      : undefined;
    message.inactive = (object.inactive !== undefined && object.inactive !== null)
      ? AssetChannelStatus_Inactive.fromPartial(object.inactive)
      : undefined;
    message.activeSending = (object.activeSending !== undefined && object.activeSending !== null)
      ? AssetChannelStatus_ActiveSending.fromPartial(object.activeSending)
      : undefined;
    message.activeReceiving = (object.activeReceiving !== undefined && object.activeReceiving !== null)
      ? AssetChannelStatus_ActiveReceiving.fromPartial(object.activeReceiving)
      : undefined;
    message.active = (object.active !== undefined && object.active !== null)
      ? AssetChannelStatus_Active.fromPartial(object.active)
      : undefined;
    message.recovering = (object.recovering !== undefined && object.recovering !== null)
      ? AssetChannelStatus_Recovering.fromPartial(object.recovering)
      : undefined;
    return message;
  },
};

function createBaseAssetChannelStatus_CooperativelyOpening(): AssetChannelStatus_CooperativelyOpening {
  return {};
}

export const AssetChannelStatus_CooperativelyOpening: MessageFns<AssetChannelStatus_CooperativelyOpening> = {
  encode(_: AssetChannelStatus_CooperativelyOpening, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_CooperativelyOpening {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_CooperativelyOpening();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_CooperativelyOpening {
    return {};
  },

  toJSON(_: AssetChannelStatus_CooperativelyOpening): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyOpening>, I>>(
    base?: I,
  ): AssetChannelStatus_CooperativelyOpening {
    return AssetChannelStatus_CooperativelyOpening.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyOpening>, I>>(
    _: I,
  ): AssetChannelStatus_CooperativelyOpening {
    const message = createBaseAssetChannelStatus_CooperativelyOpening();
    return message;
  },
};

function createBaseAssetChannelStatus_Opening(): AssetChannelStatus_Opening {
  return {};
}

export const AssetChannelStatus_Opening: MessageFns<AssetChannelStatus_Opening> = {
  encode(_: AssetChannelStatus_Opening, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Opening {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Opening();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Opening {
    return {};
  },

  toJSON(_: AssetChannelStatus_Opening): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Opening>, I>>(base?: I): AssetChannelStatus_Opening {
    return AssetChannelStatus_Opening.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Opening>, I>>(_: I): AssetChannelStatus_Opening {
    const message = createBaseAssetChannelStatus_Opening();
    return message;
  },
};

function createBaseAssetChannelStatus_CooperativelyUpdating(): AssetChannelStatus_CooperativelyUpdating {
  return {};
}

export const AssetChannelStatus_CooperativelyUpdating: MessageFns<AssetChannelStatus_CooperativelyUpdating> = {
  encode(_: AssetChannelStatus_CooperativelyUpdating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_CooperativelyUpdating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_CooperativelyUpdating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_CooperativelyUpdating {
    return {};
  },

  toJSON(_: AssetChannelStatus_CooperativelyUpdating): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyUpdating>, I>>(
    base?: I,
  ): AssetChannelStatus_CooperativelyUpdating {
    return AssetChannelStatus_CooperativelyUpdating.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyUpdating>, I>>(
    _: I,
  ): AssetChannelStatus_CooperativelyUpdating {
    const message = createBaseAssetChannelStatus_CooperativelyUpdating();
    return message;
  },
};

function createBaseAssetChannelStatus_Updating(): AssetChannelStatus_Updating {
  return {};
}

export const AssetChannelStatus_Updating: MessageFns<AssetChannelStatus_Updating> = {
  encode(_: AssetChannelStatus_Updating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Updating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Updating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Updating {
    return {};
  },

  toJSON(_: AssetChannelStatus_Updating): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Updating>, I>>(base?: I): AssetChannelStatus_Updating {
    return AssetChannelStatus_Updating.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Updating>, I>>(_: I): AssetChannelStatus_Updating {
    const message = createBaseAssetChannelStatus_Updating();
    return message;
  },
};

function createBaseAssetChannelStatus_CooperativelyClosing(): AssetChannelStatus_CooperativelyClosing {
  return {};
}

export const AssetChannelStatus_CooperativelyClosing: MessageFns<AssetChannelStatus_CooperativelyClosing> = {
  encode(_: AssetChannelStatus_CooperativelyClosing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_CooperativelyClosing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_CooperativelyClosing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_CooperativelyClosing {
    return {};
  },

  toJSON(_: AssetChannelStatus_CooperativelyClosing): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyClosing>, I>>(
    base?: I,
  ): AssetChannelStatus_CooperativelyClosing {
    return AssetChannelStatus_CooperativelyClosing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_CooperativelyClosing>, I>>(
    _: I,
  ): AssetChannelStatus_CooperativelyClosing {
    const message = createBaseAssetChannelStatus_CooperativelyClosing();
    return message;
  },
};

function createBaseAssetChannelStatus_Closing(): AssetChannelStatus_Closing {
  return { closedAtBlock: "0" };
}

export const AssetChannelStatus_Closing: MessageFns<AssetChannelStatus_Closing> = {
  encode(message: AssetChannelStatus_Closing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.closedAtBlock !== "0") {
      writer.uint32(8).uint64(message.closedAtBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Closing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Closing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.closedAtBlock = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetChannelStatus_Closing {
    return { closedAtBlock: isSet(object.closedAtBlock) ? globalThis.String(object.closedAtBlock) : "0" };
  },

  toJSON(message: AssetChannelStatus_Closing): unknown {
    const obj: any = {};
    if (message.closedAtBlock !== "0") {
      obj.closedAtBlock = message.closedAtBlock;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Closing>, I>>(base?: I): AssetChannelStatus_Closing {
    return AssetChannelStatus_Closing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Closing>, I>>(object: I): AssetChannelStatus_Closing {
    const message = createBaseAssetChannelStatus_Closing();
    message.closedAtBlock = object.closedAtBlock ?? "0";
    return message;
  },
};

function createBaseAssetChannelStatus_ForceClosing(): AssetChannelStatus_ForceClosing {
  return { forceClosedAtBlock: undefined, disputer: 0, disputeDeadline: undefined };
}

export const AssetChannelStatus_ForceClosing: MessageFns<AssetChannelStatus_ForceClosing> = {
  encode(message: AssetChannelStatus_ForceClosing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.forceClosedAtBlock !== undefined) {
      writer.uint32(8).uint64(message.forceClosedAtBlock);
    }
    if (message.disputer !== 0) {
      writer.uint32(16).int32(message.disputer);
    }
    if (message.disputeDeadline !== undefined) {
      Deadline.encode(message.disputeDeadline, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_ForceClosing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_ForceClosing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.forceClosedAtBlock = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.disputer = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disputeDeadline = Deadline.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetChannelStatus_ForceClosing {
    return {
      forceClosedAtBlock: isSet(object.forceClosedAtBlock) ? globalThis.String(object.forceClosedAtBlock) : undefined,
      disputer: isSet(object.disputer) ? disputerFromJSON(object.disputer) : 0,
      disputeDeadline: isSet(object.disputeDeadline) ? Deadline.fromJSON(object.disputeDeadline) : undefined,
    };
  },

  toJSON(message: AssetChannelStatus_ForceClosing): unknown {
    const obj: any = {};
    if (message.forceClosedAtBlock !== undefined) {
      obj.forceClosedAtBlock = message.forceClosedAtBlock;
    }
    if (message.disputer !== 0) {
      obj.disputer = disputerToJSON(message.disputer);
    }
    if (message.disputeDeadline !== undefined) {
      obj.disputeDeadline = Deadline.toJSON(message.disputeDeadline);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_ForceClosing>, I>>(base?: I): AssetChannelStatus_ForceClosing {
    return AssetChannelStatus_ForceClosing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_ForceClosing>, I>>(
    object: I,
  ): AssetChannelStatus_ForceClosing {
    const message = createBaseAssetChannelStatus_ForceClosing();
    message.forceClosedAtBlock = object.forceClosedAtBlock ?? undefined;
    message.disputer = object.disputer ?? 0;
    message.disputeDeadline = (object.disputeDeadline !== undefined && object.disputeDeadline !== null)
      ? Deadline.fromPartial(object.disputeDeadline)
      : undefined;
    return message;
  },
};

function createBaseAssetChannelStatus_ClosedRedeemable(): AssetChannelStatus_ClosedRedeemable {
  return {};
}

export const AssetChannelStatus_ClosedRedeemable: MessageFns<AssetChannelStatus_ClosedRedeemable> = {
  encode(_: AssetChannelStatus_ClosedRedeemable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_ClosedRedeemable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_ClosedRedeemable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_ClosedRedeemable {
    return {};
  },

  toJSON(_: AssetChannelStatus_ClosedRedeemable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_ClosedRedeemable>, I>>(
    base?: I,
  ): AssetChannelStatus_ClosedRedeemable {
    return AssetChannelStatus_ClosedRedeemable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_ClosedRedeemable>, I>>(
    _: I,
  ): AssetChannelStatus_ClosedRedeemable {
    const message = createBaseAssetChannelStatus_ClosedRedeemable();
    return message;
  },
};

function createBaseAssetChannelStatus_Closed(): AssetChannelStatus_Closed {
  return {};
}

export const AssetChannelStatus_Closed: MessageFns<AssetChannelStatus_Closed> = {
  encode(_: AssetChannelStatus_Closed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Closed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Closed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Closed {
    return {};
  },

  toJSON(_: AssetChannelStatus_Closed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Closed>, I>>(base?: I): AssetChannelStatus_Closed {
    return AssetChannelStatus_Closed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Closed>, I>>(_: I): AssetChannelStatus_Closed {
    const message = createBaseAssetChannelStatus_Closed();
    return message;
  },
};

function createBaseAssetChannelStatus_Inactive(): AssetChannelStatus_Inactive {
  return {};
}

export const AssetChannelStatus_Inactive: MessageFns<AssetChannelStatus_Inactive> = {
  encode(_: AssetChannelStatus_Inactive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Inactive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Inactive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Inactive {
    return {};
  },

  toJSON(_: AssetChannelStatus_Inactive): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Inactive>, I>>(base?: I): AssetChannelStatus_Inactive {
    return AssetChannelStatus_Inactive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Inactive>, I>>(_: I): AssetChannelStatus_Inactive {
    const message = createBaseAssetChannelStatus_Inactive();
    return message;
  },
};

function createBaseAssetChannelStatus_ActiveSending(): AssetChannelStatus_ActiveSending {
  return {};
}

export const AssetChannelStatus_ActiveSending: MessageFns<AssetChannelStatus_ActiveSending> = {
  encode(_: AssetChannelStatus_ActiveSending, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_ActiveSending {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_ActiveSending();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_ActiveSending {
    return {};
  },

  toJSON(_: AssetChannelStatus_ActiveSending): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_ActiveSending>, I>>(
    base?: I,
  ): AssetChannelStatus_ActiveSending {
    return AssetChannelStatus_ActiveSending.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_ActiveSending>, I>>(
    _: I,
  ): AssetChannelStatus_ActiveSending {
    const message = createBaseAssetChannelStatus_ActiveSending();
    return message;
  },
};

function createBaseAssetChannelStatus_ActiveReceiving(): AssetChannelStatus_ActiveReceiving {
  return {};
}

export const AssetChannelStatus_ActiveReceiving: MessageFns<AssetChannelStatus_ActiveReceiving> = {
  encode(_: AssetChannelStatus_ActiveReceiving, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_ActiveReceiving {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_ActiveReceiving();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_ActiveReceiving {
    return {};
  },

  toJSON(_: AssetChannelStatus_ActiveReceiving): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_ActiveReceiving>, I>>(
    base?: I,
  ): AssetChannelStatus_ActiveReceiving {
    return AssetChannelStatus_ActiveReceiving.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_ActiveReceiving>, I>>(
    _: I,
  ): AssetChannelStatus_ActiveReceiving {
    const message = createBaseAssetChannelStatus_ActiveReceiving();
    return message;
  },
};

function createBaseAssetChannelStatus_Active(): AssetChannelStatus_Active {
  return {};
}

export const AssetChannelStatus_Active: MessageFns<AssetChannelStatus_Active> = {
  encode(_: AssetChannelStatus_Active, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Active {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Active();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Active {
    return {};
  },

  toJSON(_: AssetChannelStatus_Active): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Active>, I>>(base?: I): AssetChannelStatus_Active {
    return AssetChannelStatus_Active.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Active>, I>>(_: I): AssetChannelStatus_Active {
    const message = createBaseAssetChannelStatus_Active();
    return message;
  },
};

function createBaseAssetChannelStatus_Recovering(): AssetChannelStatus_Recovering {
  return {};
}

export const AssetChannelStatus_Recovering: MessageFns<AssetChannelStatus_Recovering> = {
  encode(_: AssetChannelStatus_Recovering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannelStatus_Recovering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannelStatus_Recovering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssetChannelStatus_Recovering {
    return {};
  },

  toJSON(_: AssetChannelStatus_Recovering): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannelStatus_Recovering>, I>>(base?: I): AssetChannelStatus_Recovering {
    return AssetChannelStatus_Recovering.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannelStatus_Recovering>, I>>(_: I): AssetChannelStatus_Recovering {
    const message = createBaseAssetChannelStatus_Recovering();
    return message;
  },
};

function createBaseAssetChannel(): AssetChannel {
  return {
    status: undefined,
    balance: undefined,
    lastOnchainTxid: undefined,
    lastOperationConfirmations: "0",
    lastOperationTimestamp: undefined,
    isUpdatable: false,
  };
}

export const AssetChannel: MessageFns<AssetChannel> = {
  encode(message: AssetChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      AssetChannelStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.balance !== undefined) {
      OffchainBalance.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.lastOnchainTxid !== undefined) {
      writer.uint32(26).string(message.lastOnchainTxid);
    }
    if (message.lastOperationConfirmations !== "0") {
      writer.uint32(32).uint64(message.lastOperationConfirmations);
    }
    if (message.lastOperationTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.lastOperationTimestamp), writer.uint32(42).fork()).join();
    }
    if (message.isUpdatable !== false) {
      writer.uint32(48).bool(message.isUpdatable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = AssetChannelStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = OffchainBalance.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastOnchainTxid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastOperationConfirmations = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastOperationTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isUpdatable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetChannel {
    return {
      status: isSet(object.status) ? AssetChannelStatus.fromJSON(object.status) : undefined,
      balance: isSet(object.balance) ? OffchainBalance.fromJSON(object.balance) : undefined,
      lastOnchainTxid: isSet(object.lastOnchainTxid) ? globalThis.String(object.lastOnchainTxid) : undefined,
      lastOperationConfirmations: isSet(object.lastOperationConfirmations)
        ? globalThis.String(object.lastOperationConfirmations)
        : "0",
      lastOperationTimestamp: isSet(object.lastOperationTimestamp)
        ? fromJsonTimestamp(object.lastOperationTimestamp)
        : undefined,
      isUpdatable: isSet(object.isUpdatable) ? globalThis.Boolean(object.isUpdatable) : false,
    };
  },

  toJSON(message: AssetChannel): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = AssetChannelStatus.toJSON(message.status);
    }
    if (message.balance !== undefined) {
      obj.balance = OffchainBalance.toJSON(message.balance);
    }
    if (message.lastOnchainTxid !== undefined) {
      obj.lastOnchainTxid = message.lastOnchainTxid;
    }
    if (message.lastOperationConfirmations !== "0") {
      obj.lastOperationConfirmations = message.lastOperationConfirmations;
    }
    if (message.lastOperationTimestamp !== undefined) {
      obj.lastOperationTimestamp = message.lastOperationTimestamp.toISOString();
    }
    if (message.isUpdatable !== false) {
      obj.isUpdatable = message.isUpdatable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChannel>, I>>(base?: I): AssetChannel {
    return AssetChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChannel>, I>>(object: I): AssetChannel {
    const message = createBaseAssetChannel();
    message.status = (object.status !== undefined && object.status !== null)
      ? AssetChannelStatus.fromPartial(object.status)
      : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? OffchainBalance.fromPartial(object.balance)
      : undefined;
    message.lastOnchainTxid = object.lastOnchainTxid ?? undefined;
    message.lastOperationConfirmations = object.lastOperationConfirmations ?? "0";
    message.lastOperationTimestamp = object.lastOperationTimestamp ?? undefined;
    message.isUpdatable = object.isUpdatable ?? false;
    return message;
  },
};

function createBasePaymentStatus(): PaymentStatus {
  return {
    pending: undefined,
    pendingPreimage: undefined,
    completed: undefined,
    expired: undefined,
    failed: undefined,
    rejected: undefined,
  };
}

export const PaymentStatus: MessageFns<PaymentStatus> = {
  encode(message: PaymentStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pending !== undefined) {
      PaymentStatus_Pending.encode(message.pending, writer.uint32(10).fork()).join();
    }
    if (message.pendingPreimage !== undefined) {
      PaymentStatus_PendingPreimage.encode(message.pendingPreimage, writer.uint32(18).fork()).join();
    }
    if (message.completed !== undefined) {
      PaymentStatus_Completed.encode(message.completed, writer.uint32(26).fork()).join();
    }
    if (message.expired !== undefined) {
      PaymentStatus_Expired.encode(message.expired, writer.uint32(34).fork()).join();
    }
    if (message.failed !== undefined) {
      PaymentStatus_Failed.encode(message.failed, writer.uint32(42).fork()).join();
    }
    if (message.rejected !== undefined) {
      PaymentStatus_Rejected.encode(message.rejected, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pending = PaymentStatus_Pending.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pendingPreimage = PaymentStatus_PendingPreimage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.completed = PaymentStatus_Completed.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expired = PaymentStatus_Expired.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.failed = PaymentStatus_Failed.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rejected = PaymentStatus_Rejected.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentStatus {
    return {
      pending: isSet(object.pending) ? PaymentStatus_Pending.fromJSON(object.pending) : undefined,
      pendingPreimage: isSet(object.pendingPreimage)
        ? PaymentStatus_PendingPreimage.fromJSON(object.pendingPreimage)
        : undefined,
      completed: isSet(object.completed) ? PaymentStatus_Completed.fromJSON(object.completed) : undefined,
      expired: isSet(object.expired) ? PaymentStatus_Expired.fromJSON(object.expired) : undefined,
      failed: isSet(object.failed) ? PaymentStatus_Failed.fromJSON(object.failed) : undefined,
      rejected: isSet(object.rejected) ? PaymentStatus_Rejected.fromJSON(object.rejected) : undefined,
    };
  },

  toJSON(message: PaymentStatus): unknown {
    const obj: any = {};
    if (message.pending !== undefined) {
      obj.pending = PaymentStatus_Pending.toJSON(message.pending);
    }
    if (message.pendingPreimage !== undefined) {
      obj.pendingPreimage = PaymentStatus_PendingPreimage.toJSON(message.pendingPreimage);
    }
    if (message.completed !== undefined) {
      obj.completed = PaymentStatus_Completed.toJSON(message.completed);
    }
    if (message.expired !== undefined) {
      obj.expired = PaymentStatus_Expired.toJSON(message.expired);
    }
    if (message.failed !== undefined) {
      obj.failed = PaymentStatus_Failed.toJSON(message.failed);
    }
    if (message.rejected !== undefined) {
      obj.rejected = PaymentStatus_Rejected.toJSON(message.rejected);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus>, I>>(base?: I): PaymentStatus {
    return PaymentStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus>, I>>(object: I): PaymentStatus {
    const message = createBasePaymentStatus();
    message.pending = (object.pending !== undefined && object.pending !== null)
      ? PaymentStatus_Pending.fromPartial(object.pending)
      : undefined;
    message.pendingPreimage = (object.pendingPreimage !== undefined && object.pendingPreimage !== null)
      ? PaymentStatus_PendingPreimage.fromPartial(object.pendingPreimage)
      : undefined;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? PaymentStatus_Completed.fromPartial(object.completed)
      : undefined;
    message.expired = (object.expired !== undefined && object.expired !== null)
      ? PaymentStatus_Expired.fromPartial(object.expired)
      : undefined;
    message.failed = (object.failed !== undefined && object.failed !== null)
      ? PaymentStatus_Failed.fromPartial(object.failed)
      : undefined;
    message.rejected = (object.rejected !== undefined && object.rejected !== null)
      ? PaymentStatus_Rejected.fromPartial(object.rejected)
      : undefined;
    return message;
  },
};

function createBasePaymentStatus_Pending(): PaymentStatus_Pending {
  return {};
}

export const PaymentStatus_Pending: MessageFns<PaymentStatus_Pending> = {
  encode(_: PaymentStatus_Pending, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_Pending {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_Pending();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentStatus_Pending {
    return {};
  },

  toJSON(_: PaymentStatus_Pending): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_Pending>, I>>(base?: I): PaymentStatus_Pending {
    return PaymentStatus_Pending.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_Pending>, I>>(_: I): PaymentStatus_Pending {
    const message = createBasePaymentStatus_Pending();
    return message;
  },
};

function createBasePaymentStatus_PendingPreimage(): PaymentStatus_PendingPreimage {
  return { resolutionDeadline: undefined };
}

export const PaymentStatus_PendingPreimage: MessageFns<PaymentStatus_PendingPreimage> = {
  encode(message: PaymentStatus_PendingPreimage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resolutionDeadline !== undefined) {
      Deadline.encode(message.resolutionDeadline, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_PendingPreimage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_PendingPreimage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resolutionDeadline = Deadline.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentStatus_PendingPreimage {
    return {
      resolutionDeadline: isSet(object.resolutionDeadline) ? Deadline.fromJSON(object.resolutionDeadline) : undefined,
    };
  },

  toJSON(message: PaymentStatus_PendingPreimage): unknown {
    const obj: any = {};
    if (message.resolutionDeadline !== undefined) {
      obj.resolutionDeadline = Deadline.toJSON(message.resolutionDeadline);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_PendingPreimage>, I>>(base?: I): PaymentStatus_PendingPreimage {
    return PaymentStatus_PendingPreimage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_PendingPreimage>, I>>(
    object: I,
  ): PaymentStatus_PendingPreimage {
    const message = createBasePaymentStatus_PendingPreimage();
    message.resolutionDeadline = (object.resolutionDeadline !== undefined && object.resolutionDeadline !== null)
      ? Deadline.fromPartial(object.resolutionDeadline)
      : undefined;
    return message;
  },
};

function createBasePaymentStatus_Completed(): PaymentStatus_Completed {
  return {};
}

export const PaymentStatus_Completed: MessageFns<PaymentStatus_Completed> = {
  encode(_: PaymentStatus_Completed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_Completed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_Completed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentStatus_Completed {
    return {};
  },

  toJSON(_: PaymentStatus_Completed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_Completed>, I>>(base?: I): PaymentStatus_Completed {
    return PaymentStatus_Completed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_Completed>, I>>(_: I): PaymentStatus_Completed {
    const message = createBasePaymentStatus_Completed();
    return message;
  },
};

function createBasePaymentStatus_Expired(): PaymentStatus_Expired {
  return {};
}

export const PaymentStatus_Expired: MessageFns<PaymentStatus_Expired> = {
  encode(_: PaymentStatus_Expired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_Expired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_Expired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentStatus_Expired {
    return {};
  },

  toJSON(_: PaymentStatus_Expired): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_Expired>, I>>(base?: I): PaymentStatus_Expired {
    return PaymentStatus_Expired.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_Expired>, I>>(_: I): PaymentStatus_Expired {
    const message = createBasePaymentStatus_Expired();
    return message;
  },
};

function createBasePaymentStatus_Failed(): PaymentStatus_Failed {
  return {};
}

export const PaymentStatus_Failed: MessageFns<PaymentStatus_Failed> = {
  encode(_: PaymentStatus_Failed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_Failed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_Failed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentStatus_Failed {
    return {};
  },

  toJSON(_: PaymentStatus_Failed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_Failed>, I>>(base?: I): PaymentStatus_Failed {
    return PaymentStatus_Failed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_Failed>, I>>(_: I): PaymentStatus_Failed {
    const message = createBasePaymentStatus_Failed();
    return message;
  },
};

function createBasePaymentStatus_Rejected(): PaymentStatus_Rejected {
  return {};
}

export const PaymentStatus_Rejected: MessageFns<PaymentStatus_Rejected> = {
  encode(_: PaymentStatus_Rejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentStatus_Rejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentStatus_Rejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PaymentStatus_Rejected {
    return {};
  },

  toJSON(_: PaymentStatus_Rejected): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentStatus_Rejected>, I>>(base?: I): PaymentStatus_Rejected {
    return PaymentStatus_Rejected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentStatus_Rejected>, I>>(_: I): PaymentStatus_Rejected {
    const message = createBasePaymentStatus_Rejected();
    return message;
  },
};

function createBasePayment(): Payment {
  return {
    id: "",
    hash: undefined,
    preimage: undefined,
    status: undefined,
    timestamp: undefined,
    spent: {},
    received: {},
    operations: [],
  };
}

export const Payment: MessageFns<Payment> = {
  encode(message: Payment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.hash !== undefined) {
      writer.uint32(18).string(message.hash);
    }
    if (message.preimage !== undefined) {
      writer.uint32(26).string(message.preimage);
    }
    if (message.status !== undefined) {
      PaymentStatus.encode(message.status, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).join();
    }
    Object.entries(message.spent).forEach(([key, value]) => {
      Payment_SpentEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.received).forEach(([key, value]) => {
      Payment_ReceivedEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.operations) {
      PaymentOperation.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.preimage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = PaymentStatus.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = Payment_SpentEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.spent[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Payment_ReceivedEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.received[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.operations.push(PaymentOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : undefined,
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : undefined,
      status: isSet(object.status) ? PaymentStatus.fromJSON(object.status) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      spent: isObject(object.spent)
        ? Object.entries(object.spent).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
          acc[key] = DecimalString.fromJSON(value);
          return acc;
        }, {})
        : {},
      received: isObject(object.received)
        ? Object.entries(object.received).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
          acc[key] = DecimalString.fromJSON(value);
          return acc;
        }, {})
        : {},
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => PaymentOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Payment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.preimage !== undefined) {
      obj.preimage = message.preimage;
    }
    if (message.status !== undefined) {
      obj.status = PaymentStatus.toJSON(message.status);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.spent) {
      const entries = Object.entries(message.spent);
      if (entries.length > 0) {
        obj.spent = {};
        entries.forEach(([k, v]) => {
          obj.spent[k] = DecimalString.toJSON(v);
        });
      }
    }
    if (message.received) {
      const entries = Object.entries(message.received);
      if (entries.length > 0) {
        obj.received = {};
        entries.forEach(([k, v]) => {
          obj.received[k] = DecimalString.toJSON(v);
        });
      }
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => PaymentOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment>, I>>(base?: I): Payment {
    return Payment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment>, I>>(object: I): Payment {
    const message = createBasePayment();
    message.id = object.id ?? "";
    message.hash = object.hash ?? undefined;
    message.preimage = object.preimage ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PaymentStatus.fromPartial(object.status)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.spent = Object.entries(object.spent ?? {}).reduce<{ [key: string]: DecimalString }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DecimalString.fromPartial(value);
      }
      return acc;
    }, {});
    message.received = Object.entries(object.received ?? {}).reduce<{ [key: string]: DecimalString }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DecimalString.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.operations = object.operations?.map((e) => PaymentOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayment_SpentEntry(): Payment_SpentEntry {
  return { key: "", value: undefined };
}

export const Payment_SpentEntry: MessageFns<Payment_SpentEntry> = {
  encode(message: Payment_SpentEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DecimalString.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment_SpentEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment_SpentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment_SpentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DecimalString.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Payment_SpentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DecimalString.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment_SpentEntry>, I>>(base?: I): Payment_SpentEntry {
    return Payment_SpentEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment_SpentEntry>, I>>(object: I): Payment_SpentEntry {
    const message = createBasePayment_SpentEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DecimalString.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePayment_ReceivedEntry(): Payment_ReceivedEntry {
  return { key: "", value: undefined };
}

export const Payment_ReceivedEntry: MessageFns<Payment_ReceivedEntry> = {
  encode(message: Payment_ReceivedEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DecimalString.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment_ReceivedEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment_ReceivedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment_ReceivedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DecimalString.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Payment_ReceivedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DecimalString.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment_ReceivedEntry>, I>>(base?: I): Payment_ReceivedEntry {
    return Payment_ReceivedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment_ReceivedEntry>, I>>(object: I): Payment_ReceivedEntry {
    const message = createBasePayment_ReceivedEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DecimalString.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePaymentOperation(): PaymentOperation {
  return { send: undefined, receive: undefined, route: undefined };
}

export const PaymentOperation: MessageFns<PaymentOperation> = {
  encode(message: PaymentOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.send !== undefined) {
      PaymentOperation_Send.encode(message.send, writer.uint32(10).fork()).join();
    }
    if (message.receive !== undefined) {
      PaymentOperation_Receive.encode(message.receive, writer.uint32(18).fork()).join();
    }
    if (message.route !== undefined) {
      PaymentOperation_Route.encode(message.route, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.send = PaymentOperation_Send.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receive = PaymentOperation_Receive.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.route = PaymentOperation_Route.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentOperation {
    return {
      send: isSet(object.send) ? PaymentOperation_Send.fromJSON(object.send) : undefined,
      receive: isSet(object.receive) ? PaymentOperation_Receive.fromJSON(object.receive) : undefined,
      route: isSet(object.route) ? PaymentOperation_Route.fromJSON(object.route) : undefined,
    };
  },

  toJSON(message: PaymentOperation): unknown {
    const obj: any = {};
    if (message.send !== undefined) {
      obj.send = PaymentOperation_Send.toJSON(message.send);
    }
    if (message.receive !== undefined) {
      obj.receive = PaymentOperation_Receive.toJSON(message.receive);
    }
    if (message.route !== undefined) {
      obj.route = PaymentOperation_Route.toJSON(message.route);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentOperation>, I>>(base?: I): PaymentOperation {
    return PaymentOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentOperation>, I>>(object: I): PaymentOperation {
    const message = createBasePaymentOperation();
    message.send = (object.send !== undefined && object.send !== null)
      ? PaymentOperation_Send.fromPartial(object.send)
      : undefined;
    message.receive = (object.receive !== undefined && object.receive !== null)
      ? PaymentOperation_Receive.fromPartial(object.receive)
      : undefined;
    message.route = (object.route !== undefined && object.route !== null)
      ? PaymentOperation_Route.fromPartial(object.route)
      : undefined;
    return message;
  },
};

function createBasePaymentOperation_Send(): PaymentOperation_Send {
  return { assetId: "", to: "", recipientAmount: undefined, shards: [] };
}

export const PaymentOperation_Send: MessageFns<PaymentOperation_Send> = {
  encode(message: PaymentOperation_Send, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.recipientAmount !== undefined) {
      DecimalString.encode(message.recipientAmount, writer.uint32(26).fork()).join();
    }
    for (const v of message.shards) {
      SendingPaymentShard.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentOperation_Send {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentOperation_Send();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recipientAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shards.push(SendingPaymentShard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentOperation_Send {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      recipientAmount: isSet(object.recipientAmount) ? DecimalString.fromJSON(object.recipientAmount) : undefined,
      shards: globalThis.Array.isArray(object?.shards)
        ? object.shards.map((e: any) => SendingPaymentShard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PaymentOperation_Send): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.recipientAmount !== undefined) {
      obj.recipientAmount = DecimalString.toJSON(message.recipientAmount);
    }
    if (message.shards?.length) {
      obj.shards = message.shards.map((e) => SendingPaymentShard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentOperation_Send>, I>>(base?: I): PaymentOperation_Send {
    return PaymentOperation_Send.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentOperation_Send>, I>>(object: I): PaymentOperation_Send {
    const message = createBasePaymentOperation_Send();
    message.assetId = object.assetId ?? "";
    message.to = object.to ?? "";
    message.recipientAmount = (object.recipientAmount !== undefined && object.recipientAmount !== null)
      ? DecimalString.fromPartial(object.recipientAmount)
      : undefined;
    message.shards = object.shards?.map((e) => SendingPaymentShard.fromPartial(e)) || [];
    return message;
  },
};

function createBasePaymentOperation_Receive(): PaymentOperation_Receive {
  return { assetId: "", from: undefined, recipientAmount: undefined, shards: [] };
}

export const PaymentOperation_Receive: MessageFns<PaymentOperation_Receive> = {
  encode(message: PaymentOperation_Receive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.from !== undefined) {
      writer.uint32(18).string(message.from);
    }
    if (message.recipientAmount !== undefined) {
      DecimalString.encode(message.recipientAmount, writer.uint32(26).fork()).join();
    }
    for (const v of message.shards) {
      ReceivingPaymentShard.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentOperation_Receive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentOperation_Receive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recipientAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shards.push(ReceivingPaymentShard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentOperation_Receive {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : undefined,
      recipientAmount: isSet(object.recipientAmount) ? DecimalString.fromJSON(object.recipientAmount) : undefined,
      shards: globalThis.Array.isArray(object?.shards)
        ? object.shards.map((e: any) => ReceivingPaymentShard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PaymentOperation_Receive): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.recipientAmount !== undefined) {
      obj.recipientAmount = DecimalString.toJSON(message.recipientAmount);
    }
    if (message.shards?.length) {
      obj.shards = message.shards.map((e) => ReceivingPaymentShard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentOperation_Receive>, I>>(base?: I): PaymentOperation_Receive {
    return PaymentOperation_Receive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentOperation_Receive>, I>>(object: I): PaymentOperation_Receive {
    const message = createBasePaymentOperation_Receive();
    message.assetId = object.assetId ?? "";
    message.from = object.from ?? undefined;
    message.recipientAmount = (object.recipientAmount !== undefined && object.recipientAmount !== null)
      ? DecimalString.fromPartial(object.recipientAmount)
      : undefined;
    message.shards = object.shards?.map((e) => ReceivingPaymentShard.fromPartial(e)) || [];
    return message;
  },
};

function createBasePaymentOperation_Route(): PaymentOperation_Route {
  return {
    assetId: "",
    routedFromChannelId: "",
    routedFromNodeId: "",
    routedToChannelId: "",
    routedToNodeId: "",
    amount: undefined,
    earnedFee: undefined,
  };
}

export const PaymentOperation_Route: MessageFns<PaymentOperation_Route> = {
  encode(message: PaymentOperation_Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.routedFromChannelId !== "") {
      writer.uint32(18).string(message.routedFromChannelId);
    }
    if (message.routedFromNodeId !== "") {
      writer.uint32(26).string(message.routedFromNodeId);
    }
    if (message.routedToChannelId !== "") {
      writer.uint32(34).string(message.routedToChannelId);
    }
    if (message.routedToNodeId !== "") {
      writer.uint32(42).string(message.routedToNodeId);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(50).fork()).join();
    }
    if (message.earnedFee !== undefined) {
      DecimalString.encode(message.earnedFee, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentOperation_Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentOperation_Route();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.routedFromChannelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.routedFromNodeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.routedToChannelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.routedToNodeId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.earnedFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentOperation_Route {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      routedFromChannelId: isSet(object.routedFromChannelId) ? globalThis.String(object.routedFromChannelId) : "",
      routedFromNodeId: isSet(object.routedFromNodeId) ? globalThis.String(object.routedFromNodeId) : "",
      routedToChannelId: isSet(object.routedToChannelId) ? globalThis.String(object.routedToChannelId) : "",
      routedToNodeId: isSet(object.routedToNodeId) ? globalThis.String(object.routedToNodeId) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      earnedFee: isSet(object.earnedFee) ? DecimalString.fromJSON(object.earnedFee) : undefined,
    };
  },

  toJSON(message: PaymentOperation_Route): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.routedFromChannelId !== "") {
      obj.routedFromChannelId = message.routedFromChannelId;
    }
    if (message.routedFromNodeId !== "") {
      obj.routedFromNodeId = message.routedFromNodeId;
    }
    if (message.routedToChannelId !== "") {
      obj.routedToChannelId = message.routedToChannelId;
    }
    if (message.routedToNodeId !== "") {
      obj.routedToNodeId = message.routedToNodeId;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.earnedFee !== undefined) {
      obj.earnedFee = DecimalString.toJSON(message.earnedFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentOperation_Route>, I>>(base?: I): PaymentOperation_Route {
    return PaymentOperation_Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentOperation_Route>, I>>(object: I): PaymentOperation_Route {
    const message = createBasePaymentOperation_Route();
    message.assetId = object.assetId ?? "";
    message.routedFromChannelId = object.routedFromChannelId ?? "";
    message.routedFromNodeId = object.routedFromNodeId ?? "";
    message.routedToChannelId = object.routedToChannelId ?? "";
    message.routedToNodeId = object.routedToNodeId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.earnedFee = (object.earnedFee !== undefined && object.earnedFee !== null)
      ? DecimalString.fromPartial(object.earnedFee)
      : undefined;
    return message;
  },
};

function createBaseSendingPaymentShard(): SendingPaymentShard {
  return { channelId: "", counterparty: "", amount: undefined, fee: undefined };
}

export const SendingPaymentShard: MessageFns<SendingPaymentShard> = {
  encode(message: SendingPaymentShard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterparty !== "") {
      writer.uint32(18).string(message.counterparty);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.fee !== undefined) {
      DecimalString.encode(message.fee, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendingPaymentShard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendingPaymentShard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterparty = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendingPaymentShard {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterparty: isSet(object.counterparty) ? globalThis.String(object.counterparty) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
      fee: isSet(object.fee) ? DecimalString.fromJSON(object.fee) : undefined,
    };
  },

  toJSON(message: SendingPaymentShard): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterparty !== "") {
      obj.counterparty = message.counterparty;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    if (message.fee !== undefined) {
      obj.fee = DecimalString.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendingPaymentShard>, I>>(base?: I): SendingPaymentShard {
    return SendingPaymentShard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendingPaymentShard>, I>>(object: I): SendingPaymentShard {
    const message = createBaseSendingPaymentShard();
    message.channelId = object.channelId ?? "";
    message.counterparty = object.counterparty ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    message.fee = (object.fee !== undefined && object.fee !== null) ? DecimalString.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseReceivingPaymentShard(): ReceivingPaymentShard {
  return { channelId: "", counterparty: "", amount: undefined };
}

export const ReceivingPaymentShard: MessageFns<ReceivingPaymentShard> = {
  encode(message: ReceivingPaymentShard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.counterparty !== "") {
      writer.uint32(18).string(message.counterparty);
    }
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivingPaymentShard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivingPaymentShard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counterparty = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivingPaymentShard {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      counterparty: isSet(object.counterparty) ? globalThis.String(object.counterparty) : "",
      amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: ReceivingPaymentShard): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.counterparty !== "") {
      obj.counterparty = message.counterparty;
    }
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceivingPaymentShard>, I>>(base?: I): ReceivingPaymentShard {
    return ReceivingPaymentShard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceivingPaymentShard>, I>>(object: I): ReceivingPaymentShard {
    const message = createBaseReceivingPaymentShard();
    message.channelId = object.channelId ?? "";
    message.counterparty = object.counterparty ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseInvoice(): Invoice {
  return {
    network: undefined,
    paymentRequest: "",
    paymentHash: "",
    paymentSecret: "",
    assetId: "",
    amount: undefined,
    recipient: "",
    expiryTimestamp: undefined,
    signature: new Uint8Array(0),
    signableHash: new Uint8Array(0),
  };
}

export const Invoice: MessageFns<Invoice> = {
  encode(message: Invoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.paymentRequest !== "") {
      writer.uint32(18).string(message.paymentRequest);
    }
    if (message.paymentHash !== "") {
      writer.uint32(26).string(message.paymentHash);
    }
    if (message.paymentSecret !== "") {
      writer.uint32(34).string(message.paymentSecret);
    }
    if (message.assetId !== "") {
      writer.uint32(42).string(message.assetId);
    }
    if (message.amount !== undefined) {
      U256String.encode(message.amount, writer.uint32(50).fork()).join();
    }
    if (message.recipient !== "") {
      writer.uint32(58).string(message.recipient);
    }
    if (message.expiryTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTimestamp), writer.uint32(66).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(74).bytes(message.signature);
    }
    if (message.signableHash.length !== 0) {
      writer.uint32(82).bytes(message.signableHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRequest = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentSecret = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = U256String.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expiryTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signableHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invoice {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      paymentRequest: isSet(object.paymentRequest) ? globalThis.String(object.paymentRequest) : "",
      paymentHash: isSet(object.paymentHash) ? globalThis.String(object.paymentHash) : "",
      paymentSecret: isSet(object.paymentSecret) ? globalThis.String(object.paymentSecret) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      amount: isSet(object.amount) ? U256String.fromJSON(object.amount) : undefined,
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
      expiryTimestamp: isSet(object.expiryTimestamp) ? fromJsonTimestamp(object.expiryTimestamp) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      signableHash: isSet(object.signableHash) ? bytesFromBase64(object.signableHash) : new Uint8Array(0),
    };
  },

  toJSON(message: Invoice): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.paymentRequest !== "") {
      obj.paymentRequest = message.paymentRequest;
    }
    if (message.paymentHash !== "") {
      obj.paymentHash = message.paymentHash;
    }
    if (message.paymentSecret !== "") {
      obj.paymentSecret = message.paymentSecret;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.amount !== undefined) {
      obj.amount = U256String.toJSON(message.amount);
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    if (message.expiryTimestamp !== undefined) {
      obj.expiryTimestamp = message.expiryTimestamp.toISOString();
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.signableHash.length !== 0) {
      obj.signableHash = base64FromBytes(message.signableHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Invoice>, I>>(base?: I): Invoice {
    return Invoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Invoice>, I>>(object: I): Invoice {
    const message = createBaseInvoice();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.paymentRequest = object.paymentRequest ?? "";
    message.paymentHash = object.paymentHash ?? "";
    message.paymentSecret = object.paymentSecret ?? "";
    message.assetId = object.assetId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? U256String.fromPartial(object.amount)
      : undefined;
    message.recipient = object.recipient ?? "";
    message.expiryTimestamp = object.expiryTimestamp ?? undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    message.signableHash = object.signableHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHashlock(): Hashlock {
  return { known: undefined, unknown: undefined };
}

export const Hashlock: MessageFns<Hashlock> = {
  encode(message: Hashlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.known !== undefined) {
      Hashlock_Known.encode(message.known, writer.uint32(10).fork()).join();
    }
    if (message.unknown !== undefined) {
      Hashlock_Unknown.encode(message.unknown, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hashlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.known = Hashlock_Known.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unknown = Hashlock_Unknown.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hashlock {
    return {
      known: isSet(object.known) ? Hashlock_Known.fromJSON(object.known) : undefined,
      unknown: isSet(object.unknown) ? Hashlock_Unknown.fromJSON(object.unknown) : undefined,
    };
  },

  toJSON(message: Hashlock): unknown {
    const obj: any = {};
    if (message.known !== undefined) {
      obj.known = Hashlock_Known.toJSON(message.known);
    }
    if (message.unknown !== undefined) {
      obj.unknown = Hashlock_Unknown.toJSON(message.unknown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hashlock>, I>>(base?: I): Hashlock {
    return Hashlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hashlock>, I>>(object: I): Hashlock {
    const message = createBaseHashlock();
    message.known = (object.known !== undefined && object.known !== null)
      ? Hashlock_Known.fromPartial(object.known)
      : undefined;
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? Hashlock_Unknown.fromPartial(object.unknown)
      : undefined;
    return message;
  },
};

function createBaseHashlock_Known(): Hashlock_Known {
  return { preimage: "" };
}

export const Hashlock_Known: MessageFns<Hashlock_Known> = {
  encode(message: Hashlock_Known, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preimage !== "") {
      writer.uint32(10).string(message.preimage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hashlock_Known {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashlock_Known();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preimage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hashlock_Known {
    return { preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : "" };
  },

  toJSON(message: Hashlock_Known): unknown {
    const obj: any = {};
    if (message.preimage !== "") {
      obj.preimage = message.preimage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hashlock_Known>, I>>(base?: I): Hashlock_Known {
    return Hashlock_Known.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hashlock_Known>, I>>(object: I): Hashlock_Known {
    const message = createBaseHashlock_Known();
    message.preimage = object.preimage ?? "";
    return message;
  },
};

function createBaseHashlock_Unknown(): Hashlock_Unknown {
  return { hash: "" };
}

export const Hashlock_Unknown: MessageFns<Hashlock_Unknown> = {
  encode(message: Hashlock_Unknown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hashlock_Unknown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashlock_Unknown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hashlock_Unknown {
    return { hash: isSet(object.hash) ? globalThis.String(object.hash) : "" };
  },

  toJSON(message: Hashlock_Unknown): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hashlock_Unknown>, I>>(base?: I): Hashlock_Unknown {
    return Hashlock_Unknown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hashlock_Unknown>, I>>(object: I): Hashlock_Unknown {
    const message = createBaseHashlock_Unknown();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseClientEvent(): ClientEvent {
  return {
    syncing: undefined,
    synced: undefined,
    newBlock: undefined,
    transactionUpdate: undefined,
    transactionRemoved: undefined,
    balanceUpdate: undefined,
  };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncing !== undefined) {
      ClientEvent_Syncing.encode(message.syncing, writer.uint32(10).fork()).join();
    }
    if (message.synced !== undefined) {
      ClientEvent_Synced.encode(message.synced, writer.uint32(18).fork()).join();
    }
    if (message.newBlock !== undefined) {
      ClientEvent_NewBlock.encode(message.newBlock, writer.uint32(26).fork()).join();
    }
    if (message.transactionUpdate !== undefined) {
      ClientEvent_TransactionUpdate.encode(message.transactionUpdate, writer.uint32(34).fork()).join();
    }
    if (message.transactionRemoved !== undefined) {
      ClientEvent_TransactionRemoved.encode(message.transactionRemoved, writer.uint32(42).fork()).join();
    }
    if (message.balanceUpdate !== undefined) {
      ClientEvent_BalanceUpdate.encode(message.balanceUpdate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.syncing = ClientEvent_Syncing.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.synced = ClientEvent_Synced.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newBlock = ClientEvent_NewBlock.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transactionUpdate = ClientEvent_TransactionUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionRemoved = ClientEvent_TransactionRemoved.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.balanceUpdate = ClientEvent_BalanceUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      syncing: isSet(object.syncing) ? ClientEvent_Syncing.fromJSON(object.syncing) : undefined,
      synced: isSet(object.synced) ? ClientEvent_Synced.fromJSON(object.synced) : undefined,
      newBlock: isSet(object.newBlock) ? ClientEvent_NewBlock.fromJSON(object.newBlock) : undefined,
      transactionUpdate: isSet(object.transactionUpdate)
        ? ClientEvent_TransactionUpdate.fromJSON(object.transactionUpdate)
        : undefined,
      transactionRemoved: isSet(object.transactionRemoved)
        ? ClientEvent_TransactionRemoved.fromJSON(object.transactionRemoved)
        : undefined,
      balanceUpdate: isSet(object.balanceUpdate) ? ClientEvent_BalanceUpdate.fromJSON(object.balanceUpdate) : undefined,
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.syncing !== undefined) {
      obj.syncing = ClientEvent_Syncing.toJSON(message.syncing);
    }
    if (message.synced !== undefined) {
      obj.synced = ClientEvent_Synced.toJSON(message.synced);
    }
    if (message.newBlock !== undefined) {
      obj.newBlock = ClientEvent_NewBlock.toJSON(message.newBlock);
    }
    if (message.transactionUpdate !== undefined) {
      obj.transactionUpdate = ClientEvent_TransactionUpdate.toJSON(message.transactionUpdate);
    }
    if (message.transactionRemoved !== undefined) {
      obj.transactionRemoved = ClientEvent_TransactionRemoved.toJSON(message.transactionRemoved);
    }
    if (message.balanceUpdate !== undefined) {
      obj.balanceUpdate = ClientEvent_BalanceUpdate.toJSON(message.balanceUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.syncing = (object.syncing !== undefined && object.syncing !== null)
      ? ClientEvent_Syncing.fromPartial(object.syncing)
      : undefined;
    message.synced = (object.synced !== undefined && object.synced !== null)
      ? ClientEvent_Synced.fromPartial(object.synced)
      : undefined;
    message.newBlock = (object.newBlock !== undefined && object.newBlock !== null)
      ? ClientEvent_NewBlock.fromPartial(object.newBlock)
      : undefined;
    message.transactionUpdate = (object.transactionUpdate !== undefined && object.transactionUpdate !== null)
      ? ClientEvent_TransactionUpdate.fromPartial(object.transactionUpdate)
      : undefined;
    message.transactionRemoved = (object.transactionRemoved !== undefined && object.transactionRemoved !== null)
      ? ClientEvent_TransactionRemoved.fromPartial(object.transactionRemoved)
      : undefined;
    message.balanceUpdate = (object.balanceUpdate !== undefined && object.balanceUpdate !== null)
      ? ClientEvent_BalanceUpdate.fromPartial(object.balanceUpdate)
      : undefined;
    return message;
  },
};

function createBaseClientEvent_Syncing(): ClientEvent_Syncing {
  return {};
}

export const ClientEvent_Syncing: MessageFns<ClientEvent_Syncing> = {
  encode(_: ClientEvent_Syncing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_Syncing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_Syncing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClientEvent_Syncing {
    return {};
  },

  toJSON(_: ClientEvent_Syncing): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_Syncing>, I>>(base?: I): ClientEvent_Syncing {
    return ClientEvent_Syncing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_Syncing>, I>>(_: I): ClientEvent_Syncing {
    const message = createBaseClientEvent_Syncing();
    return message;
  },
};

function createBaseClientEvent_Synced(): ClientEvent_Synced {
  return {};
}

export const ClientEvent_Synced: MessageFns<ClientEvent_Synced> = {
  encode(_: ClientEvent_Synced, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_Synced {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_Synced();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClientEvent_Synced {
    return {};
  },

  toJSON(_: ClientEvent_Synced): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_Synced>, I>>(base?: I): ClientEvent_Synced {
    return ClientEvent_Synced.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_Synced>, I>>(_: I): ClientEvent_Synced {
    const message = createBaseClientEvent_Synced();
    return message;
  },
};

function createBaseClientEvent_NewBlock(): ClientEvent_NewBlock {
  return { number: "0" };
}

export const ClientEvent_NewBlock: MessageFns<ClientEvent_NewBlock> = {
  encode(message: ClientEvent_NewBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "0") {
      writer.uint32(8).uint64(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_NewBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_NewBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent_NewBlock {
    return { number: isSet(object.number) ? globalThis.String(object.number) : "0" };
  },

  toJSON(message: ClientEvent_NewBlock): unknown {
    const obj: any = {};
    if (message.number !== "0") {
      obj.number = message.number;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_NewBlock>, I>>(base?: I): ClientEvent_NewBlock {
    return ClientEvent_NewBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_NewBlock>, I>>(object: I): ClientEvent_NewBlock {
    const message = createBaseClientEvent_NewBlock();
    message.number = object.number ?? "0";
    return message;
  },
};

function createBaseClientEvent_TransactionUpdate(): ClientEvent_TransactionUpdate {
  return { transaction: undefined };
}

export const ClientEvent_TransactionUpdate: MessageFns<ClientEvent_TransactionUpdate> = {
  encode(message: ClientEvent_TransactionUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_TransactionUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_TransactionUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent_TransactionUpdate {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: ClientEvent_TransactionUpdate): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_TransactionUpdate>, I>>(base?: I): ClientEvent_TransactionUpdate {
    return ClientEvent_TransactionUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_TransactionUpdate>, I>>(
    object: I,
  ): ClientEvent_TransactionUpdate {
    const message = createBaseClientEvent_TransactionUpdate();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseClientEvent_TransactionRemoved(): ClientEvent_TransactionRemoved {
  return { txid: "" };
}

export const ClientEvent_TransactionRemoved: MessageFns<ClientEvent_TransactionRemoved> = {
  encode(message: ClientEvent_TransactionRemoved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_TransactionRemoved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_TransactionRemoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent_TransactionRemoved {
    return { txid: isSet(object.txid) ? globalThis.String(object.txid) : "" };
  },

  toJSON(message: ClientEvent_TransactionRemoved): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_TransactionRemoved>, I>>(base?: I): ClientEvent_TransactionRemoved {
    return ClientEvent_TransactionRemoved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_TransactionRemoved>, I>>(
    object: I,
  ): ClientEvent_TransactionRemoved {
    const message = createBaseClientEvent_TransactionRemoved();
    message.txid = object.txid ?? "";
    return message;
  },
};

function createBaseClientEvent_BalanceUpdate(): ClientEvent_BalanceUpdate {
  return { assetId: "", balance: undefined };
}

export const ClientEvent_BalanceUpdate: MessageFns<ClientEvent_BalanceUpdate> = {
  encode(message: ClientEvent_BalanceUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_BalanceUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_BalanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent_BalanceUpdate {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: ClientEvent_BalanceUpdate): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_BalanceUpdate>, I>>(base?: I): ClientEvent_BalanceUpdate {
    return ClientEvent_BalanceUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_BalanceUpdate>, I>>(object: I): ClientEvent_BalanceUpdate {
    const message = createBaseClientEvent_BalanceUpdate();
    message.assetId = object.assetId ?? "";
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseNodeEvent(): NodeEvent {
  return {
    syncing: undefined,
    synced: undefined,
    channelUpdate: undefined,
    channelClosed: undefined,
    assetChannelUpdate: undefined,
    assetChannelClosed: undefined,
    paymentUpdate: undefined,
    peerConnected: undefined,
    peerDisconnected: undefined,
    watchtowerConnected: undefined,
    watchtowerDisconnected: undefined,
  };
}

export const NodeEvent: MessageFns<NodeEvent> = {
  encode(message: NodeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncing !== undefined) {
      NodeEvent_Syncing.encode(message.syncing, writer.uint32(10).fork()).join();
    }
    if (message.synced !== undefined) {
      NodeEvent_Synced.encode(message.synced, writer.uint32(18).fork()).join();
    }
    if (message.channelUpdate !== undefined) {
      NodeEvent_ChannelUpdate.encode(message.channelUpdate, writer.uint32(26).fork()).join();
    }
    if (message.channelClosed !== undefined) {
      NodeEvent_ChannelClosed.encode(message.channelClosed, writer.uint32(34).fork()).join();
    }
    if (message.assetChannelUpdate !== undefined) {
      NodeEvent_AssetChannelUpdate.encode(message.assetChannelUpdate, writer.uint32(42).fork()).join();
    }
    if (message.assetChannelClosed !== undefined) {
      NodeEvent_AssetChannelClosed.encode(message.assetChannelClosed, writer.uint32(50).fork()).join();
    }
    if (message.paymentUpdate !== undefined) {
      NodeEvent_PaymentUpdate.encode(message.paymentUpdate, writer.uint32(58).fork()).join();
    }
    if (message.peerConnected !== undefined) {
      NodeEvent_PeerConnected.encode(message.peerConnected, writer.uint32(66).fork()).join();
    }
    if (message.peerDisconnected !== undefined) {
      NodeEvent_PeerDisconnected.encode(message.peerDisconnected, writer.uint32(74).fork()).join();
    }
    if (message.watchtowerConnected !== undefined) {
      NodeEvent_WatchtowerConnected.encode(message.watchtowerConnected, writer.uint32(82).fork()).join();
    }
    if (message.watchtowerDisconnected !== undefined) {
      NodeEvent_WatchtowerDisconnected.encode(message.watchtowerDisconnected, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.syncing = NodeEvent_Syncing.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.synced = NodeEvent_Synced.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelUpdate = NodeEvent_ChannelUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelClosed = NodeEvent_ChannelClosed.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetChannelUpdate = NodeEvent_AssetChannelUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetChannelClosed = NodeEvent_AssetChannelClosed.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentUpdate = NodeEvent_PaymentUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.peerConnected = NodeEvent_PeerConnected.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.peerDisconnected = NodeEvent_PeerDisconnected.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.watchtowerConnected = NodeEvent_WatchtowerConnected.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.watchtowerDisconnected = NodeEvent_WatchtowerDisconnected.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent {
    return {
      syncing: isSet(object.syncing) ? NodeEvent_Syncing.fromJSON(object.syncing) : undefined,
      synced: isSet(object.synced) ? NodeEvent_Synced.fromJSON(object.synced) : undefined,
      channelUpdate: isSet(object.channelUpdate) ? NodeEvent_ChannelUpdate.fromJSON(object.channelUpdate) : undefined,
      channelClosed: isSet(object.channelClosed) ? NodeEvent_ChannelClosed.fromJSON(object.channelClosed) : undefined,
      assetChannelUpdate: isSet(object.assetChannelUpdate)
        ? NodeEvent_AssetChannelUpdate.fromJSON(object.assetChannelUpdate)
        : undefined,
      assetChannelClosed: isSet(object.assetChannelClosed)
        ? NodeEvent_AssetChannelClosed.fromJSON(object.assetChannelClosed)
        : undefined,
      paymentUpdate: isSet(object.paymentUpdate) ? NodeEvent_PaymentUpdate.fromJSON(object.paymentUpdate) : undefined,
      peerConnected: isSet(object.peerConnected) ? NodeEvent_PeerConnected.fromJSON(object.peerConnected) : undefined,
      peerDisconnected: isSet(object.peerDisconnected)
        ? NodeEvent_PeerDisconnected.fromJSON(object.peerDisconnected)
        : undefined,
      watchtowerConnected: isSet(object.watchtowerConnected)
        ? NodeEvent_WatchtowerConnected.fromJSON(object.watchtowerConnected)
        : undefined,
      watchtowerDisconnected: isSet(object.watchtowerDisconnected)
        ? NodeEvent_WatchtowerDisconnected.fromJSON(object.watchtowerDisconnected)
        : undefined,
    };
  },

  toJSON(message: NodeEvent): unknown {
    const obj: any = {};
    if (message.syncing !== undefined) {
      obj.syncing = NodeEvent_Syncing.toJSON(message.syncing);
    }
    if (message.synced !== undefined) {
      obj.synced = NodeEvent_Synced.toJSON(message.synced);
    }
    if (message.channelUpdate !== undefined) {
      obj.channelUpdate = NodeEvent_ChannelUpdate.toJSON(message.channelUpdate);
    }
    if (message.channelClosed !== undefined) {
      obj.channelClosed = NodeEvent_ChannelClosed.toJSON(message.channelClosed);
    }
    if (message.assetChannelUpdate !== undefined) {
      obj.assetChannelUpdate = NodeEvent_AssetChannelUpdate.toJSON(message.assetChannelUpdate);
    }
    if (message.assetChannelClosed !== undefined) {
      obj.assetChannelClosed = NodeEvent_AssetChannelClosed.toJSON(message.assetChannelClosed);
    }
    if (message.paymentUpdate !== undefined) {
      obj.paymentUpdate = NodeEvent_PaymentUpdate.toJSON(message.paymentUpdate);
    }
    if (message.peerConnected !== undefined) {
      obj.peerConnected = NodeEvent_PeerConnected.toJSON(message.peerConnected);
    }
    if (message.peerDisconnected !== undefined) {
      obj.peerDisconnected = NodeEvent_PeerDisconnected.toJSON(message.peerDisconnected);
    }
    if (message.watchtowerConnected !== undefined) {
      obj.watchtowerConnected = NodeEvent_WatchtowerConnected.toJSON(message.watchtowerConnected);
    }
    if (message.watchtowerDisconnected !== undefined) {
      obj.watchtowerDisconnected = NodeEvent_WatchtowerDisconnected.toJSON(message.watchtowerDisconnected);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent>, I>>(base?: I): NodeEvent {
    return NodeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent>, I>>(object: I): NodeEvent {
    const message = createBaseNodeEvent();
    message.syncing = (object.syncing !== undefined && object.syncing !== null)
      ? NodeEvent_Syncing.fromPartial(object.syncing)
      : undefined;
    message.synced = (object.synced !== undefined && object.synced !== null)
      ? NodeEvent_Synced.fromPartial(object.synced)
      : undefined;
    message.channelUpdate = (object.channelUpdate !== undefined && object.channelUpdate !== null)
      ? NodeEvent_ChannelUpdate.fromPartial(object.channelUpdate)
      : undefined;
    message.channelClosed = (object.channelClosed !== undefined && object.channelClosed !== null)
      ? NodeEvent_ChannelClosed.fromPartial(object.channelClosed)
      : undefined;
    message.assetChannelUpdate = (object.assetChannelUpdate !== undefined && object.assetChannelUpdate !== null)
      ? NodeEvent_AssetChannelUpdate.fromPartial(object.assetChannelUpdate)
      : undefined;
    message.assetChannelClosed = (object.assetChannelClosed !== undefined && object.assetChannelClosed !== null)
      ? NodeEvent_AssetChannelClosed.fromPartial(object.assetChannelClosed)
      : undefined;
    message.paymentUpdate = (object.paymentUpdate !== undefined && object.paymentUpdate !== null)
      ? NodeEvent_PaymentUpdate.fromPartial(object.paymentUpdate)
      : undefined;
    message.peerConnected = (object.peerConnected !== undefined && object.peerConnected !== null)
      ? NodeEvent_PeerConnected.fromPartial(object.peerConnected)
      : undefined;
    message.peerDisconnected = (object.peerDisconnected !== undefined && object.peerDisconnected !== null)
      ? NodeEvent_PeerDisconnected.fromPartial(object.peerDisconnected)
      : undefined;
    message.watchtowerConnected = (object.watchtowerConnected !== undefined && object.watchtowerConnected !== null)
      ? NodeEvent_WatchtowerConnected.fromPartial(object.watchtowerConnected)
      : undefined;
    message.watchtowerDisconnected =
      (object.watchtowerDisconnected !== undefined && object.watchtowerDisconnected !== null)
        ? NodeEvent_WatchtowerDisconnected.fromPartial(object.watchtowerDisconnected)
        : undefined;
    return message;
  },
};

function createBaseNodeEvent_Syncing(): NodeEvent_Syncing {
  return {};
}

export const NodeEvent_Syncing: MessageFns<NodeEvent_Syncing> = {
  encode(_: NodeEvent_Syncing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_Syncing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_Syncing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeEvent_Syncing {
    return {};
  },

  toJSON(_: NodeEvent_Syncing): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_Syncing>, I>>(base?: I): NodeEvent_Syncing {
    return NodeEvent_Syncing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_Syncing>, I>>(_: I): NodeEvent_Syncing {
    const message = createBaseNodeEvent_Syncing();
    return message;
  },
};

function createBaseNodeEvent_Synced(): NodeEvent_Synced {
  return {};
}

export const NodeEvent_Synced: MessageFns<NodeEvent_Synced> = {
  encode(_: NodeEvent_Synced, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_Synced {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_Synced();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NodeEvent_Synced {
    return {};
  },

  toJSON(_: NodeEvent_Synced): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_Synced>, I>>(base?: I): NodeEvent_Synced {
    return NodeEvent_Synced.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_Synced>, I>>(_: I): NodeEvent_Synced {
    const message = createBaseNodeEvent_Synced();
    return message;
  },
};

function createBaseNodeEvent_ChannelUpdate(): NodeEvent_ChannelUpdate {
  return { channel: undefined };
}

export const NodeEvent_ChannelUpdate: MessageFns<NodeEvent_ChannelUpdate> = {
  encode(message: NodeEvent_ChannelUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_ChannelUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_ChannelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_ChannelUpdate {
    return { channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined };
  },

  toJSON(message: NodeEvent_ChannelUpdate): unknown {
    const obj: any = {};
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_ChannelUpdate>, I>>(base?: I): NodeEvent_ChannelUpdate {
    return NodeEvent_ChannelUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_ChannelUpdate>, I>>(object: I): NodeEvent_ChannelUpdate {
    const message = createBaseNodeEvent_ChannelUpdate();
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? Channel.fromPartial(object.channel)
      : undefined;
    return message;
  },
};

function createBaseNodeEvent_ChannelClosed(): NodeEvent_ChannelClosed {
  return { channelId: "" };
}

export const NodeEvent_ChannelClosed: MessageFns<NodeEvent_ChannelClosed> = {
  encode(message: NodeEvent_ChannelClosed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_ChannelClosed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_ChannelClosed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_ChannelClosed {
    return { channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "" };
  },

  toJSON(message: NodeEvent_ChannelClosed): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_ChannelClosed>, I>>(base?: I): NodeEvent_ChannelClosed {
    return NodeEvent_ChannelClosed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_ChannelClosed>, I>>(object: I): NodeEvent_ChannelClosed {
    const message = createBaseNodeEvent_ChannelClosed();
    message.channelId = object.channelId ?? "";
    return message;
  },
};

function createBaseNodeEvent_AssetChannelUpdate(): NodeEvent_AssetChannelUpdate {
  return { channelId: "", assetId: "", assetChannel: undefined };
}

export const NodeEvent_AssetChannelUpdate: MessageFns<NodeEvent_AssetChannelUpdate> = {
  encode(message: NodeEvent_AssetChannelUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.assetChannel !== undefined) {
      AssetChannel.encode(message.assetChannel, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_AssetChannelUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_AssetChannelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetChannel = AssetChannel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_AssetChannelUpdate {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      assetChannel: isSet(object.assetChannel) ? AssetChannel.fromJSON(object.assetChannel) : undefined,
    };
  },

  toJSON(message: NodeEvent_AssetChannelUpdate): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.assetChannel !== undefined) {
      obj.assetChannel = AssetChannel.toJSON(message.assetChannel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_AssetChannelUpdate>, I>>(base?: I): NodeEvent_AssetChannelUpdate {
    return NodeEvent_AssetChannelUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_AssetChannelUpdate>, I>>(object: I): NodeEvent_AssetChannelUpdate {
    const message = createBaseNodeEvent_AssetChannelUpdate();
    message.channelId = object.channelId ?? "";
    message.assetId = object.assetId ?? "";
    message.assetChannel = (object.assetChannel !== undefined && object.assetChannel !== null)
      ? AssetChannel.fromPartial(object.assetChannel)
      : undefined;
    return message;
  },
};

function createBaseNodeEvent_AssetChannelClosed(): NodeEvent_AssetChannelClosed {
  return { channelId: "", assetId: "" };
}

export const NodeEvent_AssetChannelClosed: MessageFns<NodeEvent_AssetChannelClosed> = {
  encode(message: NodeEvent_AssetChannelClosed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_AssetChannelClosed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_AssetChannelClosed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_AssetChannelClosed {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
    };
  },

  toJSON(message: NodeEvent_AssetChannelClosed): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_AssetChannelClosed>, I>>(base?: I): NodeEvent_AssetChannelClosed {
    return NodeEvent_AssetChannelClosed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_AssetChannelClosed>, I>>(object: I): NodeEvent_AssetChannelClosed {
    const message = createBaseNodeEvent_AssetChannelClosed();
    message.channelId = object.channelId ?? "";
    message.assetId = object.assetId ?? "";
    return message;
  },
};

function createBaseNodeEvent_PaymentUpdate(): NodeEvent_PaymentUpdate {
  return { payment: undefined };
}

export const NodeEvent_PaymentUpdate: MessageFns<NodeEvent_PaymentUpdate> = {
  encode(message: NodeEvent_PaymentUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_PaymentUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_PaymentUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_PaymentUpdate {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: NodeEvent_PaymentUpdate): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_PaymentUpdate>, I>>(base?: I): NodeEvent_PaymentUpdate {
    return NodeEvent_PaymentUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_PaymentUpdate>, I>>(object: I): NodeEvent_PaymentUpdate {
    const message = createBaseNodeEvent_PaymentUpdate();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseNodeEvent_PeerConnected(): NodeEvent_PeerConnected {
  return { nodeId: "" };
}

export const NodeEvent_PeerConnected: MessageFns<NodeEvent_PeerConnected> = {
  encode(message: NodeEvent_PeerConnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_PeerConnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_PeerConnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_PeerConnected {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: NodeEvent_PeerConnected): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_PeerConnected>, I>>(base?: I): NodeEvent_PeerConnected {
    return NodeEvent_PeerConnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_PeerConnected>, I>>(object: I): NodeEvent_PeerConnected {
    const message = createBaseNodeEvent_PeerConnected();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseNodeEvent_PeerDisconnected(): NodeEvent_PeerDisconnected {
  return { nodeId: "" };
}

export const NodeEvent_PeerDisconnected: MessageFns<NodeEvent_PeerDisconnected> = {
  encode(message: NodeEvent_PeerDisconnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_PeerDisconnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_PeerDisconnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_PeerDisconnected {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: NodeEvent_PeerDisconnected): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_PeerDisconnected>, I>>(base?: I): NodeEvent_PeerDisconnected {
    return NodeEvent_PeerDisconnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_PeerDisconnected>, I>>(object: I): NodeEvent_PeerDisconnected {
    const message = createBaseNodeEvent_PeerDisconnected();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseNodeEvent_WatchtowerConnected(): NodeEvent_WatchtowerConnected {
  return { nodeId: "" };
}

export const NodeEvent_WatchtowerConnected: MessageFns<NodeEvent_WatchtowerConnected> = {
  encode(message: NodeEvent_WatchtowerConnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_WatchtowerConnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_WatchtowerConnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_WatchtowerConnected {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: NodeEvent_WatchtowerConnected): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_WatchtowerConnected>, I>>(base?: I): NodeEvent_WatchtowerConnected {
    return NodeEvent_WatchtowerConnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_WatchtowerConnected>, I>>(
    object: I,
  ): NodeEvent_WatchtowerConnected {
    const message = createBaseNodeEvent_WatchtowerConnected();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseNodeEvent_WatchtowerDisconnected(): NodeEvent_WatchtowerDisconnected {
  return { nodeId: "" };
}

export const NodeEvent_WatchtowerDisconnected: MessageFns<NodeEvent_WatchtowerDisconnected> = {
  encode(message: NodeEvent_WatchtowerDisconnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeEvent_WatchtowerDisconnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent_WatchtowerDisconnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent_WatchtowerDisconnected {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: NodeEvent_WatchtowerDisconnected): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent_WatchtowerDisconnected>, I>>(
    base?: I,
  ): NodeEvent_WatchtowerDisconnected {
    return NodeEvent_WatchtowerDisconnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent_WatchtowerDisconnected>, I>>(
    object: I,
  ): NodeEvent_WatchtowerDisconnected {
    const message = createBaseNodeEvent_WatchtowerDisconnected();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseOrderbookCurrency(): OrderbookCurrency {
  return { protocol: 0, networkId: "", assetId: "" };
}

export const OrderbookCurrency: MessageFns<OrderbookCurrency> = {
  encode(message: OrderbookCurrency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.networkId !== "") {
      writer.uint32(18).string(message.networkId);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderbookCurrency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookCurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.networkId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookCurrency {
    return {
      protocol: isSet(object.protocol) ? protocolFromJSON(object.protocol) : 0,
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
    };
  },

  toJSON(message: OrderbookCurrency): unknown {
    const obj: any = {};
    if (message.protocol !== 0) {
      obj.protocol = protocolToJSON(message.protocol);
    }
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookCurrency>, I>>(base?: I): OrderbookCurrency {
    return OrderbookCurrency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookCurrency>, I>>(object: I): OrderbookCurrency {
    const message = createBaseOrderbookCurrency();
    message.protocol = object.protocol ?? 0;
    message.networkId = object.networkId ?? "";
    message.assetId = object.assetId ?? "";
    return message;
  },
};

function createBaseSwapAmount(): SwapAmount {
  return { from: undefined, to: undefined };
}

export const SwapAmount: MessageFns<SwapAmount> = {
  encode(message: SwapAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== undefined) {
      SwapAmount_From.encode(message.from, writer.uint32(10).fork()).join();
    }
    if (message.to !== undefined) {
      SwapAmount_To.encode(message.to, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = SwapAmount_From.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = SwapAmount_To.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapAmount {
    return {
      from: isSet(object.from) ? SwapAmount_From.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? SwapAmount_To.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: SwapAmount): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = SwapAmount_From.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = SwapAmount_To.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapAmount>, I>>(base?: I): SwapAmount {
    return SwapAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapAmount>, I>>(object: I): SwapAmount {
    const message = createBaseSwapAmount();
    message.from = (object.from !== undefined && object.from !== null)
      ? SwapAmount_From.fromPartial(object.from)
      : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? SwapAmount_To.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseSwapAmount_From(): SwapAmount_From {
  return { amount: undefined };
}

export const SwapAmount_From: MessageFns<SwapAmount_From> = {
  encode(message: SwapAmount_From, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapAmount_From {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapAmount_From();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapAmount_From {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: SwapAmount_From): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapAmount_From>, I>>(base?: I): SwapAmount_From {
    return SwapAmount_From.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapAmount_From>, I>>(object: I): SwapAmount_From {
    const message = createBaseSwapAmount_From();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseSwapAmount_To(): SwapAmount_To {
  return { amount: undefined };
}

export const SwapAmount_To: MessageFns<SwapAmount_To> = {
  encode(message: SwapAmount_To, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      DecimalString.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapAmount_To {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapAmount_To();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapAmount_To {
    return { amount: isSet(object.amount) ? DecimalString.fromJSON(object.amount) : undefined };
  },

  toJSON(message: SwapAmount_To): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = DecimalString.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapAmount_To>, I>>(base?: I): SwapAmount_To {
    return SwapAmount_To.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapAmount_To>, I>>(object: I): SwapAmount_To {
    const message = createBaseSwapAmount_To();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? DecimalString.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePairOrderMatch(): PairOrderMatch {
  return {
    sendingCurrency: undefined,
    receivingCurrency: undefined,
    sendingAmount: undefined,
    receivingAmount: undefined,
    receivingFee: undefined,
    slippage: undefined,
  };
}

export const PairOrderMatch: MessageFns<PairOrderMatch> = {
  encode(message: PairOrderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sendingCurrency !== undefined) {
      OrderbookCurrency.encode(message.sendingCurrency, writer.uint32(10).fork()).join();
    }
    if (message.receivingCurrency !== undefined) {
      OrderbookCurrency.encode(message.receivingCurrency, writer.uint32(18).fork()).join();
    }
    if (message.sendingAmount !== undefined) {
      DecimalString.encode(message.sendingAmount, writer.uint32(26).fork()).join();
    }
    if (message.receivingAmount !== undefined) {
      DecimalString.encode(message.receivingAmount, writer.uint32(34).fork()).join();
    }
    if (message.receivingFee !== undefined) {
      DecimalString.encode(message.receivingFee, writer.uint32(42).fork()).join();
    }
    if (message.slippage !== undefined) {
      DecimalString.encode(message.slippage, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairOrderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairOrderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sendingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receivingCurrency = OrderbookCurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receivingAmount = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receivingFee = DecimalString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.slippage = DecimalString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairOrderMatch {
    return {
      sendingCurrency: isSet(object.sendingCurrency) ? OrderbookCurrency.fromJSON(object.sendingCurrency) : undefined,
      receivingCurrency: isSet(object.receivingCurrency)
        ? OrderbookCurrency.fromJSON(object.receivingCurrency)
        : undefined,
      sendingAmount: isSet(object.sendingAmount) ? DecimalString.fromJSON(object.sendingAmount) : undefined,
      receivingAmount: isSet(object.receivingAmount) ? DecimalString.fromJSON(object.receivingAmount) : undefined,
      receivingFee: isSet(object.receivingFee) ? DecimalString.fromJSON(object.receivingFee) : undefined,
      slippage: isSet(object.slippage) ? DecimalString.fromJSON(object.slippage) : undefined,
    };
  },

  toJSON(message: PairOrderMatch): unknown {
    const obj: any = {};
    if (message.sendingCurrency !== undefined) {
      obj.sendingCurrency = OrderbookCurrency.toJSON(message.sendingCurrency);
    }
    if (message.receivingCurrency !== undefined) {
      obj.receivingCurrency = OrderbookCurrency.toJSON(message.receivingCurrency);
    }
    if (message.sendingAmount !== undefined) {
      obj.sendingAmount = DecimalString.toJSON(message.sendingAmount);
    }
    if (message.receivingAmount !== undefined) {
      obj.receivingAmount = DecimalString.toJSON(message.receivingAmount);
    }
    if (message.receivingFee !== undefined) {
      obj.receivingFee = DecimalString.toJSON(message.receivingFee);
    }
    if (message.slippage !== undefined) {
      obj.slippage = DecimalString.toJSON(message.slippage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PairOrderMatch>, I>>(base?: I): PairOrderMatch {
    return PairOrderMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PairOrderMatch>, I>>(object: I): PairOrderMatch {
    const message = createBasePairOrderMatch();
    message.sendingCurrency = (object.sendingCurrency !== undefined && object.sendingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.sendingCurrency)
      : undefined;
    message.receivingCurrency = (object.receivingCurrency !== undefined && object.receivingCurrency !== null)
      ? OrderbookCurrency.fromPartial(object.receivingCurrency)
      : undefined;
    message.sendingAmount = (object.sendingAmount !== undefined && object.sendingAmount !== null)
      ? DecimalString.fromPartial(object.sendingAmount)
      : undefined;
    message.receivingAmount = (object.receivingAmount !== undefined && object.receivingAmount !== null)
      ? DecimalString.fromPartial(object.receivingAmount)
      : undefined;
    message.receivingFee = (object.receivingFee !== undefined && object.receivingFee !== null)
      ? DecimalString.fromPartial(object.receivingFee)
      : undefined;
    message.slippage = (object.slippage !== undefined && object.slippage !== null)
      ? DecimalString.fromPartial(object.slippage)
      : undefined;
    return message;
  },
};

function createBaseOrderMatch(): OrderMatch {
  return { pair: undefined, swap: undefined };
}

export const OrderMatch: MessageFns<OrderMatch> = {
  encode(message: OrderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pair !== undefined) {
      OrderMatch_Pair.encode(message.pair, writer.uint32(10).fork()).join();
    }
    if (message.swap !== undefined) {
      OrderMatch_Swap.encode(message.swap, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pair = OrderMatch_Pair.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swap = OrderMatch_Swap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderMatch {
    return {
      pair: isSet(object.pair) ? OrderMatch_Pair.fromJSON(object.pair) : undefined,
      swap: isSet(object.swap) ? OrderMatch_Swap.fromJSON(object.swap) : undefined,
    };
  },

  toJSON(message: OrderMatch): unknown {
    const obj: any = {};
    if (message.pair !== undefined) {
      obj.pair = OrderMatch_Pair.toJSON(message.pair);
    }
    if (message.swap !== undefined) {
      obj.swap = OrderMatch_Swap.toJSON(message.swap);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderMatch>, I>>(base?: I): OrderMatch {
    return OrderMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderMatch>, I>>(object: I): OrderMatch {
    const message = createBaseOrderMatch();
    message.pair = (object.pair !== undefined && object.pair !== null)
      ? OrderMatch_Pair.fromPartial(object.pair)
      : undefined;
    message.swap = (object.swap !== undefined && object.swap !== null)
      ? OrderMatch_Swap.fromPartial(object.swap)
      : undefined;
    return message;
  },
};

function createBaseOrderMatch_Pair(): OrderMatch_Pair {
  return { pairOrderMatch: undefined };
}

export const OrderMatch_Pair: MessageFns<OrderMatch_Pair> = {
  encode(message: OrderMatch_Pair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairOrderMatch !== undefined) {
      PairOrderMatch.encode(message.pairOrderMatch, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderMatch_Pair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderMatch_Pair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairOrderMatch = PairOrderMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderMatch_Pair {
    return {
      pairOrderMatch: isSet(object.pairOrderMatch) ? PairOrderMatch.fromJSON(object.pairOrderMatch) : undefined,
    };
  },

  toJSON(message: OrderMatch_Pair): unknown {
    const obj: any = {};
    if (message.pairOrderMatch !== undefined) {
      obj.pairOrderMatch = PairOrderMatch.toJSON(message.pairOrderMatch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderMatch_Pair>, I>>(base?: I): OrderMatch_Pair {
    return OrderMatch_Pair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderMatch_Pair>, I>>(object: I): OrderMatch_Pair {
    const message = createBaseOrderMatch_Pair();
    message.pairOrderMatch = (object.pairOrderMatch !== undefined && object.pairOrderMatch !== null)
      ? PairOrderMatch.fromPartial(object.pairOrderMatch)
      : undefined;
    return message;
  },
};

function createBaseOrderMatch_Swap(): OrderMatch_Swap {
  return { pairOrderMatches: [] };
}

export const OrderMatch_Swap: MessageFns<OrderMatch_Swap> = {
  encode(message: OrderMatch_Swap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pairOrderMatches) {
      PairOrderMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderMatch_Swap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderMatch_Swap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairOrderMatches.push(PairOrderMatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderMatch_Swap {
    return {
      pairOrderMatches: globalThis.Array.isArray(object?.pairOrderMatches)
        ? object.pairOrderMatches.map((e: any) => PairOrderMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderMatch_Swap): unknown {
    const obj: any = {};
    if (message.pairOrderMatches?.length) {
      obj.pairOrderMatches = message.pairOrderMatches.map((e) => PairOrderMatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderMatch_Swap>, I>>(base?: I): OrderMatch_Swap {
    return OrderMatch_Swap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderMatch_Swap>, I>>(object: I): OrderMatch_Swap {
    const message = createBaseOrderMatch_Swap();
    message.pairOrderMatches = object.pairOrderMatches?.map((e) => PairOrderMatch.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
